---
layout:     post
title:      "Linux - 笔记"
subtitle:   "linux learning note "
date:       2019-05-28 20:00:00
author:     "Becks"
header-img: "img/post-bg2.jpg"
catalog:    true
tags:
    - Linux
    - 学习笔记
---

```shell

Ctrl + d # open new terminal window tab

```

**cp**: copy and paste  <br/>
**mv**: move and rename <br/>
**Less**:  View some part of the file (lookup, view line by line / page by page) <br/>
**Touch**: create new file(cannot create directory), change file timestamp   <br/>
**Nano(or gedit)**: txt/code editor   <br/>
**sudo**: grant super user priviledge <br/>
**Top**: provide you dynamic real time view of running system <br/>
**Echo** print, can include variable in "" <br/>
**chmod** add/remove access for user, group, others (u,g,o), 可以是给octal(数字的形式) <br/>
**which**: where software/command located <br/>
**whatis**: display short manual(man command) page description <br/>
**useradd**: create new user  <br/>
**passwd**: change password for user <br/>
**userdel**: delete exisiting user <br/>
**groups**: show which group is currently user connected to <br/>
**groupadd**: add new group in system <br/>
**groupdel**: delete existing group <br/>
**gpasswd -a**: add user to exisiting group <br/>
**gpasswd -d**: delete user from exisiting group <br/>
**df**: the amount of disk space being used by your file system <br/>
**du**: estimate and display the disk space used by files in details <br/>
**free**: display the total amount free and used physical and swap memory in the system  <br/>
**watch**: run command at a regular interval or repeatedly <br/>
**head/tail**: print first / last part of the file <br/>
**find**: Find the file (by name, by time) <br/>
**wc**: print a count of lines, words and characters for each files <br/>
**Cal**: 显示calendar <br/>
**Date**: print  and change system date and time information <br/>
**Multiple Command** ; &&  ||  <br/>
**ifconfig**: interface configuration: used to view and change network interface configuration on your system <br/>



**Shell**: a program that take commands from keyboard and give them to operating system to perform;

Command Line or Shell: aslo called **CLI(Command Line Interface)**

**Terminal**: a tool which you can use to pass your shell commands.  A program that opens a window and lets you interact with the shell

File in Linux system are arranged in **hierarchical directory structure**: organized in a tree-like pattern

## 初始化 LS

```shell
#Open Terminal 快捷键
press ctrl alt T

#show current(home) directory
pwd

clear #clear terminal


# 给options 再到directory
ls [options] [name of directory]

#list all file in current directory
ls
ls ~ #跟上面作用一样，显示home directory

ls Documents/ #Documents必须在当前文件夹下，显示Documents文件夹所有文件
ls Documents/*.html #显示Documents中只包含.html的文件
ls Documents/*.* #show all the files

ls / #显示root的所有文件，注意root的directory跟现在文件夹可能不同

ls .. #显示parent directory 所有文件

ls ../.. #显示parent 的parent directory所有文件
cd ../.. #Go to parent's parent folder

ls -l #list all directory in long format, 显示详细的信息, user, what is rights of files (write? read?), size of file,Date of creating
#drwxr-xr-x: drwxr directory (r) read (w)write, x(execute), read,  -xr (group right): only execute and read, -x (others): only execute 

ls -a # give hidden files also, in linux, .表示hidden files
ls -al #show hidden file and show long format

ls -lS #sort directory by size and show long format
ls -lS > out.txt #put all the show into out.txt file

ls -d */ #只显示所有的directory

ls -R #显示每个子文件夹都包含什么文件

man ls #显示所有ls 的function, 按Q退出

```


## CD

**home directory和root directory** 不一样, root是/, home 是 /Users/ username 的文件夹

```shell
cd / #go to root directory
cd ~ #home directory
cd .. #到parent directory
cd Documents #go to Document Directory
cd /home/programming/Documents/ #功能与上面一样, Go to Document Directory
cd My\ Books # go to My Books folder, 在My Books中间有空格
cd "My Books" #功能与上面一样
cd 'My Books' #功能与上面一样

```



## Cat

cat: 1. Display Txt 2. combine Txt file 3. Create new Txt file

syntax: cat options file1 file2 ... 

```shell
cat Hello World #会打印 echo Hello world
#Ctrl D means the end of cat command 

cat list1.txt #显示list1.txt 所有内容
cat list1.txt list2.txt #显示list1.txt 和list2.txt所有内容，先显示list1的再显示list2的

cat -b list1.txt #把list1.txt的 不是blank的line(空行) 显示序号
cat -n list1.txt #把list1.txt的 所有行(空行或者不空行) 都显示序号
cat -s list1.txt #squeeze 连续 blank line to one blank line

cat -E list1.txt #add $ at the end of each line

man cat #显示cat所有function

cat > test.txt  #把接下来input的内容 output 到test.txt，输完了 按Ctrl+D， test.txt之前内容被remove
cat >> text.txt #把接下来input的内容 append 到test.txt

cat list1.txt list2.txt > out.txt #把mlist1, list2的内容合并，生成out.txt
cat list1.txt list2.txt > list2.txt #这样是不行的，不能把input 当成output file
cat list1.txt >> list2.txt #修改上面一行的error，append list1.txt 到list2.txt

```




## mkdir

```shell
mkdir image #生成image directory
mkdir image/pic #生成pic directory inside image directory
mkdir names/mark #当names 不在当前文件夹下，显示error, No such file or directory
mkdir -p names/mark (mkdir --parents names/mark ) #-p means -- parents
mkdir -p names/{john,tom,bob}  #creat several directory inside current directory, 建立三个文件夹,john, tom,bob
# {john,tom,bob} 不能有空格，否则建立的文件夹是 {john,


```



## rm & rmdir

**rmdir**: remove directory, **rm**: rmove file and directory

```shell

rmdir abc # remove abc的folder
rmdir a/b/c/d/e #只remove 最后e的directory
rmdir -p a/b/c/d/e  #remove 所有的directory structure
rmdir -pv a/b/c/d/e #remove 所有directory structure，并显示(verb)remove的进程
#如果a/b/c/d/e 每个并不是空的文件夹，会显示error, failed to remove directory a/b: Directory not empty

rm -rv a/b 
rm -rv a #与上面一行作用是一样的

```


## CP

CP: copy and paste

```shell

cp options source destination

cp file1.txt file2.txt #if file2.txt not exist will creat file2.txt. Content from file1 will copy to file2 

cp file1.txt dir1 # 把file1.txt copy 到directory 1

cp file1.txt file2.txt dir1 # 把file1.txt 和file2.txt copy 到directory 1

cp -i  file1.txt file2.txt dir1 #如果directory 1 里面有file1.txt -i 会ask 是否要overwrite, 选n, 就会只copy file2 不会copy file1

cp ../f1.txt ../f2.txt . #从parent directory copy f1.txt和f2.txt 到现在directory, 因为没有-i, 会overwrite

cp dir1 dir3 # error， 因为dir1 有文件，不能被copy
cp -R dir1 dir3 # -R means recursive copy,copy everything from dir1 to dir3
#whenever destination (dir3) doesn't exist, it create destination and copy all content from source
#如果存在destination, 只copy paste
cp -vR dir1 dir3 #显示详细的copy 哪些文件


```
![](/img/post/linux/pic1.png)


## mv

mv: rename, move

```shell

mv options source dest

mv f1.txt f2.txt #rename f1.txt 成f2.txt 

mv f1.txt dir1/ #把f1.txt 移动到dir1
#如果dir1 中有f1.txt, move 会overwrite 原有的file 内容

mv -i f1.txt dir1 #move f1.txt 到dir1 folder中, 如果要overwrite 会问
mv -i f1.txt dir1/ #与上面一样的

mv dir1 dir2 #把dir1 移动到dir2 中, content 也会move,  不用-R
#dir1就现在文件夹下不存在了,dir1 在dir2中

#tricky，如果当dir3 不存在
mv dir2 dir3 #dir2中的内容移动到dir3中，所以dir3中只含有dir1，dir2也消失了
#如果dir3 也存在，那么dir3 中有dir2, dir2中有dir1 

mv -v file3.txt dir3 #V, verb, 显示具体怎么移动的
```


## Less

read file and search pattern in the file, 比如用cat print整个文件，当文件很大，当print完成，不能显示文件开头，用less，可以看

```shell

less big.txt   #only show the starting point of the file, 然后用键盘的↓，enter show one more row below at one time
#用键盘的↑，enter show one row above at one time
#键盘的space show page by page below
#键盘的shift+B show page by page above
#键盘的shift+G to the end of file
#键盘先1 + G or g (without shift) to go to the begining of the file
#想找文件从上到下，比如找book, type  /book + enter, 找next, type n
#想找文件从下到上，比如找book, type ?book + enter, 找上一个，type n
#想退出less command, press q



```



## Touch

Touch is the easist way to create new empty file in Linux. It is also used for changing timestamp on existing file or directory 

<span style="background-color: #FFFF00">you cannot create new directory using touch, can only create empty file</span>

```shell

touch file6 #建一个新的empty file6
touch f7.txt #建立一个新的txt, 名字是f7

touch file1.txt #修改file1.txt的timestamp, 不修改内容，只修改了timestamp


```

![](/img/post/linux/pic2.png)



## Nano

Nano is a small and friendly text editor, besides it has interactive search, replace, go to line, and indentation 

```shell
nano file.txt #open txt editor, file open but not show has been created, 因为还没有save

#press ctrl + o, -> means write out
#press ctrl + x  -> quit the file
#press ctrl + k -> cut
#press ctrl + u -> paste

nao abc.cpp #会有color, code highlighting, 不光是cpp, 也可以是Java,c 



```


![](/img/post/linux/pic3.png)

![](/img/post/linux/pic4.png)


## Sudo

Sudo: superuser do: allow you some priviledge as adminstrator or a power user

有时候比如mkdir dir, show permission denied error, 用sudo tell linux command to execute as administrator

比如install G++, GCC, will ask user priviledge 

```shell

sudo mkdir dir #需要provide password, run as administrator 

sudo apt-get install g++ # apt-get install : install software

sudo -s #change priviledge from local user to root 

```





## Top

Top: provide you dynamic real time view of running system. Used to see which program take more of your CPU and which program consuming more of your memory

```shell
top #give you view of system, it refreshing every second
s # can update time, 输入1 refresh every 1 second
i # to filter idle process
k # 把鼠标选中PID, press k, kill process
q # quit the top view

```

PID: process ID, 同一个程序不同时候run pid 可能不一样的 <br/>

![](/img/post/linux/pic5.png)





## Kill

kill process

```shell

kill -flags pid # syntax

piodf unity-control-center #lookup pid by name

kill 3286 # kill pid = 3286 process

kill -KILL 3294 #force to kill process

kill -9 3294 # force to kill  process (flag -9)

ps -ux  #find pid; give a long list of running process (current user)
ps -aux #find pid; give a long list of all running process (all users)
ps -U  Becks #give all process under User Becks
ps -C gnome-terminal #give all process related to program gnome-terminal, 可能连着多个instances
```



## Echo

used for bash scripting to print 

```shell

echo hello world # 在terminal 打印出hello world
echo "hello world" #与上面一样, better use "" for echo

myvar="Mark" #myvar= 不能有空格, assign variable
echo $myvar #print variable

x=10
echo "the value of x is $x" #print the value of x is 10

echo -e 'some \text' #-e use escape,  \t -> tab,   print:  some     ext

```


## File Permissions, Chmod

drwxr-xr-x 1 beckswu staff 22 Jul 23 18:56 file: d means directory <br/>
-rw-rw-r- 1 beckswu staff 没有d 表示normal file, 如果开头是c, 表示character special file。如果是b，表示binary special file

左面第一堆表示owner of file access, 第二堆表示group of file, 第三堆表示permission for everybody else, 1表示symbolic links of the file, 接下来表示owner of the file, next is the group of the file, 22 表示size of the file, July 23 18:56 date of created. file is the name of file

symbolic link is a term for any file that contains a reference to another file or directory in the form of an absolute or relative path and that affects pathname resolution


```shell

#o means other group, + add permission, - minus permission,
chmod o+x file #给file 的other user(第三堆) 加execute permission

chmod g+x file #给file 的group(第二堆) 加execute permission
chmod g-wx file #给file的group 移走write execute permission

chmod ug=rwx file #给user(owner), group read write execute permission 

chmod a-rwx file #给所有的（owerner, group, others) remove read, write, execution permission


chmod u+rw, g=rw, o+r file #给user add read write, 给group read, write permission, 给other add read permission

```



## Directory Permission


```shell

chmod u-w dir #remove user write permission for directory
#cd 进dir, touch f.txt 显示permission denied

chmod u-r dir #remove read access from user
#cd dir 显示 permission denied

chmod u-x dir #remove execute access from user 
#cd dir 或者 ls dir/ 都显示permission denied


```


## Octal & Numerical Permissions

![](/img/post/linux/pic6.png)

![](/img/post/linux/pic7.png)

比如你想给user access read write and x, you need to give number as 7(binary start from right to left for each group)

```shell

chmod 755 file.txt #give user read, write execute(7), give both group and othe group read and execute access

```





## Bash Script

Script: txt file contain sequence of command

```shell

nano myscript.sh #open editor 

#! /bin/bash  #需要contain location of bash
which bash #会告诉哪里有bash，give location 

./myscript.sh #./ 是去run bash script
#显示permission denied 因为file created not have execute permission 

#先给permission 
chmod +x myscript.sh #give permission for all groups
./myscript.sh #显示会成功


```

![](/img/post/linux/pic8.png)

![](/img/post/linux/bash.png)



## which & what

which: where software/command located

what: display short manual page description

```shell
#which ls #give location where ls command located

which firefox # location of bash
which bash # location of bash

whatis ls # short description, to know what ls doing command
whatis grep #short description, to know what is grep command

```



## useradd

create user

```shell

useradd the_name_of_user #syntax

sudo useradd mark -m -s /bin/bash -g users -c "my comment"
#-m:  create default home directory for this user
#-s /bin/bash allow usesr to use shell
#-g assign group, default group is users
#-c "my comment" provide comment to user 
#-G assign/give user defined group
#sudo: because you don't want anybody create user, only root can create user

sudo passwd mark  #change password for user


```



## userdel



```shell

sudo userdel mark #delete user mark (username, password, data), not delete home directory for user

sudo userdel -r mark #delete user (home directory, username, password, data)

sudo -r /home/mark/  #remove all the data from user

```
![](/img/post/linux/userdel.png)



## groups, groupadd, groupdel

group show which group is currently user connected to

```shell
groups #show which group is currently user connected to

cat /etc/group #show all the group in your system,  group <-> user connected to 

sudo groupadd Java #add newgroup in system
sudo groupdel Java #delete existing group

#-a add user to group, -d remove user from group
sudo gpasswd -a mark Java # add mark to the Java group
sudo gpasswd -d mark Java #remove user from Group


```




## bashrc

bashrc is a script executed whenever a new terminal session start in interactive mode

some linux system， .bashrc file exist when a new terminal session start. Some not

Bashrc file is used for setting up environment variable such as Java. When use git, which repo you checked or cloned, use Bashrc

```shell

ls -a #在home directory ls -a 可以看见有.bashrc

nano .bashrc #查看.bashrc
gedit .bashrc #查看 .bashrc

```

可以修改 .bashrc file 比如加上alias ls='ls --color=auto -l', 之后open new terminal, 输入ls, 显示long list of ls 

![](/img/post/linux/bashrc.png)


![](/img/post/linux/bashrc2.png)

## du, df, free

View Resources




```shell
df #the amount of disk space being used by your file system
df -h #the human readable output, 显示多少G, M, k

du #estimate and display the disk space used by files in details
du -h #human readable format
du -sh #-s summary 只给你现在所在directory 文件所占的大小
sudo du -sh #用sudo 原因是因为可能有的file permission denied 需要用sudo 
du -sh /etc/ #show summary used space by etc folder

free #display the total amount free and used physical and swap memory in the system as well as buffer in the kernel
free -b  #-b btye, -k KB, -m MB, -G GB, -T TB

```


## Watch

run scripts for command at a regular interval or repeatedly


```shell

watch free -m #可以看见几秒会更新一次
Ctrl + C #exit watch command
watch -n 1 free -m #让free -m command run every 1 second
watch -n 0,5 free -m #让free -m command run every 0.5 second


```

![](/img/post/linux/watch.png)

## Head Tail

Head: output the first part of the file 
Tail: output the last part of the file


```shell
head log.txt #show first 10 line of file 
tail log.txt #show last 10 line of file 


head -n3 log.txt #show first 3 lines of file
head -3 log.txt #跟上面一样

tail -n3 log.txt #show last 3 lines of file
tail -3 log.txt #跟上面一样

tail -f log.txt #output last 10 lines of file. watch the file, whenever file change, will show last 10 lines of code
ctrl + C #exit 
head  log.txt kern.log #先print 10 lines of log.txt 再print 10 lines of kern.log

head -3 log.txt kern.log #先print 3 lines of log.txt 再print 3 lines of kern.log


```



## Find



```shell

find location -name file_name #syntax

find /home/ -name test.sh #-name search by name, return directory 
find /home/dir1 -name test.* #search in /home/dir1 folder by name, any file start with test. 可以是.txt, .sh
find /home/dir1 -name *.txt #search any file extension is txt
find / -name dmesg #search in the root directory, 也许有permission error 因为有些directory 不允许access
sudo find / -name dmesg 

find /home  -mtime -1  #look at the file created 1 days before, 也可以用加号，+1, + 2


```



## wc

wc: world count, print a count of lines, words and characters for each files


```shell

wc test.txt #打出#lines, #words, #characters
wc -c test.txt #只打出#characters
wc -l test.txt #只打出#lines
wc -w test.txt #只打出#words

wc -L test.txt #只给出number of character in longest line


```

1, 6, 42: 1 number of line, 6 number of words, 42 number of characters

![](/img/post/linux/wc.png)


## Cal

show conventially formatted calendar on your command line

```shell

cal #显示calendar, weekday on the top
ncal  #显示calendar, weekday on the left 
cal 2016 #显示2016的calendar
cal 2 2016 #显示2016年 2月 calendar
cal -3 #give you current month, previous month and next month calendar
#default 是 -1, 比如cal, 等于cal -1
```



## Date

used to print out and change system date and time information

```shell

date #print 现在系统的时间

date -s "11/20/2003 12:48:00" #设置system time 为 11/20/2003 12:48:00

date +%d%h%y #显示13Jan17

date +%d/%h/%y #显示13-Jan-17

man date #可以显示详细的date format的格式


date "+Date: %m/%d/y%n" #显示01/13/17 %n 是空行线



```
设置时间格式
![](/img/post/linux/date.png)


## Run Multiple Terminal(; && || )



```shell

#; sequence matter 
ls; pwd #先run ls 再显示pwd
date; cal ; pwd #先run date, 再run cal, 再pwd

#如果有中间一个command 是错的
date; CAL;  pwd #date, pwd run 成功了, CAL 会显示command not found 

#&& sequence matter, 顺序一个接一个
ls && pwd && date && cal #先run ls, 再pwd, 再date, 再cal

ls && CAL && pwd #先run ls, CAL error, not run pwd

ls || pwd #如果第一个command 成功了，不会run 第二个command

CAL || pwd #CAL command failure, pwd 会被run

```

<span style="background-color: #FFFF00">Difference</span>: ; run every command regardless success/failure of each command. && 如果中间的failure, does not go to the next command


## apt-get

apt-get(urbantu): install, uninstall, update packages. apt: advance packaging tool

对于centos: 用yum, dnf instead of apt-get 

```shell

sudo apt-get update #resync your local package file to the server package file, update all the packages

java -version #check if java installed, and if so check version
php5 -version #check if php installed, 如果没有install 会给出install的hint

sudo apt-get install php5 #安装首先what is required extra dependency to install php5, 也会显示多少space required to install
php5 -v #显示php5 version

sudo apt-get remove php5 #remove php5
sudo apt-get remove --purge php5 #remove all configuration file related to php5
sudo apt-get autoremove  #auto remove the dependency which required for the package(php5) and no longer needed for other packages



```




## ifconfig

ifconfig: interface configuration: used to view and change network interface configuration on your system

```shell
ifconfig #show you some output

ifconfig eth0 #only show eth0 interface

#up, down to disable internet connection 
sudo ifconfig eth0 down #internet connection will be down

sudo ifconfig eth0 up #enable internet 

```

ethO: wired internet cable  <br/>
WLAN0: wireless internet connection <br/>
0: is the first internet interface. 如果有multiple internet interface, 显示eth1, or WLAN2
l0: loop back interface. An interface that system use to communcate to excel


## Tar



```shell


```



## Kill



```shell


```



## Kill



```shell


```








untracked: git 就根本不知道我们有这个文件，我们要把文件 添加到git 当中; add 文件 就到了staged 状态了, 然后就可以commit，commit之后就变成了unstaged 的状态;  unmodified, modified 都是属于unstaged的状态

<span style="background-color: #FFFF00">每次更改文件后需要到先到stage 状态 (git add)才可以commit </span>

## 记录修改

```shell
git log #显示所有更改的commit的信息，比如commit两回，显示两次commit
git log --oneline #显示每个commit用1行
git log --oneline --graph #用图形的方式显示, 当只有一个分支, 会在commit前加上星号成一条线,

#显示现在文件和上次commit的不同
git diff #红色是之前的commit的, 绿色是现在文件

git diff --cached #当文件已经stage, git diff 显示不出不同，需要这句话，显示staged后的文件和上次commit的不同

#当文件stage, 没有commit, 又做了修改，需要下面cmd看不同，如果用git diff --cached，只会显示staged的部分，不会显示又更改的部分
git diff HEAD 
```
<span style="background-color: #FFFF00">当修改已经被stage (git add) 再看git diff是看不出不同的, 如想看不同需要git diff --cached </span>

## 回到从前

**reset** 
```shell

#覆盖上次的commit的, amend 把stage 状态放在上个commit当中,  no edit是不更改上次commit的评论
git commit --amend --no-edit  #改完之后发现message 没变，但是id是会变得

#返回从stage的状态 到modified的状态
git reset 1.py #把 1.py 返回unstaged的状态

#把commit的过后的版本返回到上一个， 调整head 到上一个，上上一个; 
git reset --hard HEAD #把head 移到了现在commit上面 #git status会显示没有任何修改了
git reset --hard HEAD^ #把head 移到前一个commit, git reset --hard HEAD^^ 移到前两个commit

git reset --hard 7a7ecea #把head 移到 7a7ecea这个id上面去 (看id: git status --oneline)
#再git status --oneline 就不能看现在head未来的commit的

#也可以吧head回到未来, 从上上个移动到现在的
git reflog #看每一个的变化, 显示每一个head的移动
git reset --hard 3f27543 #通过reflog 找到未来的head id，可以返回了
git reset --hard HEAD@{0} #也可以把之前复制过来
```
![](/img/post/git-note/gitpic2.PNG)

**checkout** 
```shell
#只让一个文件回到过去
git checkout 7a7ecea -- 1.py  #7a7ecea是之前commit的id,  只恢复1.py; 2.py 还是现在的状态
#之后修改再commit, 会建立新的commit的，git log --oneline 显示这次在过去的commit上面，过去的commit不会像reset一样消失
```

## 管理分支

比如master是client用的，要稳定版，自己要用一个开会的分支
```shell
#比如master的分支, 都是
git branch dev #建立一个名为dev的
git checkout -b dev #建立一个名为dev的, 并把head移动到dev分支上

git branch #显示现在所有的分支, 星号表示现在的分支
git checkout dev #从现在分支切换到dev上, 再git branch, dev分支上显示星号
git branch -d dev #删除dev的分支, 报错，因为现在就在dev分支上, 先切换别的分支，才能删除
git branch -D dev #如果git branch -d dev, 大写的D表示强行删除

#把dev merge到master上来, -m "keep merge in info"把信息记录在log, --no-ff, no faster forward, 默认是faster forward是不会留信息
git merge --no-ff -m "keep merge in info" dev #要确定在master上面不能在dev branch上
#merge 之后再看git log --oneline --graph #会有图像显示branch的分支产生，merge
```


## 分支冲突
<span style="background-color: #FFFF00">**Merge** </span> 

比如 两个分支master, dev各有修改, 当git merge dev 时候有conflict, 然后file里显示什么冲突了, 把冲突的部分删除掉，做修改，修改过后的状态是modified, stage (git add .) 再commit(git commit -m "solve conflict") (or 直接 git commit --am "solve conflict"), 再git log --oneline --graph 会显示两个分支合并了


<span style="background-color: #FFFF00">**rebase** </span> 

比如在branch A上工作 c3是基于c1的, branch B是主分支,然后有天有人提交了bug, 在主分支branch b的上进行了提交, 这时如果想把bug融合到c3上; 

方法是: 先把branch A的c3拿走，空出来, 把c2,c4合并到上面去, 再把c3放到合并以后的地方, <span style="background-color: #FFFF00">注:现在c3基于c4, 以前的c3不复存在了</span> 所以rebase是危险的方式, rebase 后c3的commit id和rebase前c3的id是不一样的


![](/img/post/git-note/gitpic3.PNG)

```shell
#先checkout master,然后再主分支的修改基于dev的修改 (上图的branch A是master, branch b是dev)
git checkout master
git rebase dev #(把master分支基于dev分支)
#如果有conflict, 跟merge一样的, 去修改conflict
#修改完conflict, git branch  发现不在任何一个分支上

#stage + commit 
git rebase --continue #继续rebase
#如果碰到conflict，想放弃rebase
git rebase --abort

git log --oneline --graph #会发现dev的commit插到master上面来了,
```
## 临时修复

比如要改之前的程序, 而现在的改进程序还没有完成, 不想把改进的和要改的程序放在一起, 用stash可以改进的code暂存一下, 等改后之前的, 再继续工作, 有不同的commit, 不会有冲突
```shell
git checkout dev
#git status -s 显示文件已经被更改
git stash #把现在的文件放在缓存区
git status -s #此时就没有任何的modified 文件了
#此时再建一个新的branc: git checkout -b boss; 在这个branch中修改之前的code, stash缓存的更改不会建立在这个branch中

#修改完boss分支后, 再checkout 回dev: 
git checkout dev
git stash pop #就会把之前修改暂存的返回回来
```

<span style="background-color: #FFFF00">当stash后再建立新的branch, stash缓存的内容不会出现的新的branch中, 新的branch只显示上次commit 的内容 </span> 

## GitHub

```shell
git push -u origin master #把master分支推到origin上面, origin指得是online的管理库
git push -u origin dev #把dev分支推到origin上面

git config --get remote.origin.url #查看remote url

#修改已经存在的origin为新的http://....
git remote set-url origin https://  #已经有remote url，改变现有的url
git remote add origin https://      #初始url
```

origin指得是online的管理库, history显示所有的改变, change显示每次commit发生变化, 本地的.git文件也被上传到管理库
