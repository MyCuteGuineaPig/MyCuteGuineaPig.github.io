---
layout:     post
title:      "Linux - 笔记"
subtitle:   "linux learning note "
date:       2019-05-28 20:00:00
author:     "Becks"
header-img: "img/post-bg2.jpg"
catalog:    true
tags:
    - Linux
    - 学习笔记
---

```shell

Ctrl + d # open new terminal window tab

```

**cp**: copy and paste  <br/>
**mv**: move and rename <br/>
**Less**:  View some part of the file (lookup, view line by line / page by page) <br/>
**Touch**: create new file(cannot create directory), change file timestamp   <br/>
**Nano(or gedit)**: txt/code editor   <br/>
**sudo**: grant super user priviledge <br/>
**Top**: provide you dynamic real time view of running system <br/>
**Echo** print, can include variable in "" <br/>
**chmod** add/remove access for user, group, others (u,g,o), 可以是给octal(数字的形式) <br/>
**which**: where software/command located <br/>
**whatis**: display short manual(man command) page description <br/>
**useradd**: create new user  <br/>
**passwd**: change password for user <br/>
**userdel**: delete exisiting user <br/>
**groups**: show which group is currently user connected to <br/>
**groupadd**: add new group in system <br/>
**groupdel**: delete existing group <br/>
**gpasswd -a**: add user to exisiting group <br/>
**gpasswd -d**: delete user from exisiting group <br/>
**df**: the amount of disk space being used by your file system <br/>
**du**: estimate and display the disk space used by files in details <br/>
**free**: display the total amount free and used physical and swap memory in the system  <br/>
**watch**: run command at a regular interval or repeatedly <br/>
**head/tail**: print first / last part of the file <br/>
**find**: Find the file (by name, by time) <br/>
**wc**: print a count of lines, words and characters for each files <br/>
**Cal**: 显示calendar <br/>
**Date**: print  and change system date and time information <br/>
**Multiple Command** ; &&  ||  <br/>
**ifconfig**: interface configuration: used to view and change network interface configuration on your system <br/>
**tar**: 压缩/解压 文件夹/文件 <br/>
**grep**: search and print pattern / word in a text file or a number of text file <br/>
**netstat**: display network connection, routing tables and a number of network interfaces, and view network protocal states 



**Shell**: a program that take commands from keyboard and give them to operating system to perform;

Command Line or Shell: aslo called **CLI(Command Line Interface)**

**Terminal**: a tool which you can use to pass your shell commands.  A program that opens a window and lets you interact with the shell

File in Linux system are arranged in **hierarchical directory structure**: organized in a tree-like pattern

## Linux  基础

cat list1.txt #显示list1.txt 所有内容: ```group_name:password:GID:user_list```: 比如 ```sudo:x:27```, 密码一般不显示，用```x``` 代替. 如果用户的 GID 等于用户组的 GID，那么最后一个字段 user_list 就是空的





| 字符   |  Meaning |
|:----------:|:-------------|
|\* |	匹配 0 或多个字符 |
| ? |	匹配任意一个字符 |
| \[list] |	匹配 list 中的任意单一字符 |
| \[^list] |	匹配 除list 中的任意单一字符以外的字符 |
| \[c1-c2] |	匹配 c1-c2 中的任意单一字符 如：\[0-9] \[a-z] |
| {string1,string2,...}	| 匹配 string1 或 string2 (或更多)其一字符串 |
| {c1..c2} |	匹配 c1-c2 中全部字符 如{1..10} |


```shell
按键	作用
Ctrl+d	键盘输入结束或退出终端
Ctrl+s	暂停当前程序，暂停后按下任意键恢复运行
Ctrl+z	将当前程序放到后台运行，恢复到前台为命令fg
Ctrl+a	将光标移至输入行头，相当于Home键
Ctrl+e	将光标移至输入行末，相当于End键
Ctrl+k	删除从光标所在位置到行末
Alt+Backspace	向前删除一个单词
Shift+PgUp	将终端显示向上滚动
Shift+PgDn	将终端显示向下滚动
```

```shell
#Open Terminal 快捷键
press ctrl alt T

#show current(home) directory
pwd

clear #clear terminal


# 给options 再到directory
ls [options] [name of directory]

#list all file in current directory
ls
ls ~ #跟上面作用一样，显示home directory

ls Documents/ #Documents必须在当前文件夹下，显示Documents文件夹所有文件
ls Documents/*.html #显示Documents中只包含.html的文件
ls Documents/*.* #show all the files

ls / #显示root的所有文件，注意root的directory跟现在文件夹可能不同

ls .. #显示parent directory 所有文件

ls ../.. #显示parent 的parent directory所有文件
cd ../.. #Go to parent's parent folder

ls -l #list all directory in long format, 显示详细的信息, user, what is rights of files (write? read?), size of file,Date of creating
#drwxr-xr-x: drwxr directory (r) read (w)write, x(execute), read,  -xr (group right): only execute and read, -x (others): only execute 

ls -a # give hidden files also, in linux, .表示hidden files
ls -al #show hidden file and show long format

ls -lS #sort directory by size and show long format
ls -lS > out.txt #put all the show into out.txt file

ls -d */ #只显示所有的directory

ls -R #显示每个子文件夹都包含什么文件

man ls #显示所有ls 的function, 按Q退出

```

> FHS（英文：Filesystem Hierarchy Standard 中文：文件系统层次结构标准），多数 Linux 版本采用这种文件组织形式，FHS 定义了系统中每个区域的用途、所需要的最小构成的文件和目录同时还给出了例外处理与矛盾处理。

>  FHS 定义了两层规范，第一层是， / 下面的各个目录应该要放什么文件数据，例如 /etc 应该放置设置文件，/bin 与 /sbin 则应该放置可执行文件等等。
第二层则是针对 /usr 及 /var 这两个目录的子目录来定义。例如 /var/log 放置系统日志文件，/usr/share 放置共享数据等等。

![](/img/post/linux/FHS2.png)


![](/img/post/linux/FHS.png)



#### 环境变量

注意：为了与普通变量区分，通常我们习惯将环境变量名设为大写。

```shell
declare tmp #创建一个名为tmp 变量
#其实也可以不用 declare 预声明一个变量，直接即用即创建，
# 这里只是告诉你 declare 的作用，这在创建其它指定类型的变量（如数组）时会用到。

tmp=shiyanlou

echo $tmp

```

在所有的 UNIX 和类 UNIX 系统中，每个进程都有其各自的环境变量设置，且默认情况下，当一个进程被创建时，除了创建过程中明确指定的话，<span style="color:red">它将继承其父进程的绝大部分环境设置。Shell 程序也作为一个进程运行在操作系统之上，而我们在 Shell 中运行的大部分命令都将以 Shell 的子进程的方式运行
    
通常我们会涉及到的变量类型有三种：
- 当前 Shell 进程私有用户自定义变量，如上面我们创建的 tmp 变量，只在当前 Shell 中有效。
- Shell 本身内建的变量。
- 从自定义变量导出的环境变量。

| 字符   |  Meaning |
|:----------:|:-------------|
| ```set```| 	显示当前 Shell 所有变量，包括其内建环境变量（与 Shell 外观等相关），用户自定义变量及导出的环境变量。|
| ```env```| 	显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。 | 
| ```export```| 	显示从 Shell 中把变量 导出成 环境变量的变量，也能通过它将自定义变量导出为环境变量 | 

你可以更直观的使用 vimdiff 工具比较一下它们之间的差别：

```shell
$ temp=shiyanlou
$ export temp_env=shiyanlou
$ env|sort>env.txt
$ export|sort>export.txt
$ set|sort>set.txt
```

上述操作将命令输出通过管道 | 使用 sort 命令排序，再重定向到对象文本文件中。

```shell
$ vimdiff env.txt export.txt set.txt
```

按变量的生存周期来划分，Linux 变量可分为两类：

- **永久的**：需要修改配置文件，变量永久生效；
- **临时的**：使用 export 命令行声明即可，变量在关闭 shell 时失效。

这里介绍两个重要文件 /etc/bashrc（有的 Linux 没有这个文件） 和 /etc/profile ，它们分别存放的是 shell 变量和环境变量。还有要注意区别的是每个用户目录下的一个隐藏文件：

```shell
.profile 可以用 ls -a 查看
cd /home/shiyanlou
ls -a 
```

<span style="color:red"> 这个 .profile 只对当前用户永久生效。而写在 /etc/profile 里面的是对所有用户永久生效</span>，所以如果想要添加一个永久生效的环境变量，只需要<span style="background-color:#FFFF00"> 打开 /etc/profile，在最后加上你想添加的环境变量就好啦</span>。

![](/img/post/linux/ev.png)


**添加到environment variable**

<span style="color:red">注意这里一定要使用绝对路径。</span>

```shell
$ PATH=$PATH:/home/shiyanlou/mybin 
#如果有程序在mybin 中 可以执行程序用
hello.sh #而不是用./hello.sh

```

上面的方法一旦关闭terminal, 下次再打开，之前定义的Path就没有用了, 解决办法：

在每个用户的 home 目录中有一个 Shell 每次启动时会默认执行一个配置脚本，以初始化环境，包括添加一些用户自定义环境变量等等。<span style="background-color:#FFFF00">zsh 的配置文件是 .zshrc，相应 Bash 的配置文件为 .bashrc</span>。它们在 etc 下还都有一个或多个全局的配置文件，不过我们一般只修改用户目录下的配置文件

我们可以简单地使用下面命令直接添加内容到 .zshrc 中：

```shell
$ echo "PATH=$PATH:/home/shiyanlou/mybin" >> .zshrc #>> append
```

**如何让环境变量立即生效**

在 Shell 中修改了比如 zsh 的配置文件 home 目录下的 .zshrc），每次都要退出终端重新打开甚至重启主机之后其才能生效，很是麻烦，我们可以使用 ```source ``` 命令来让其立即生效，如

```shell
source .zshrc

#source 命令还有一个别名就是 .，上面的命令如果替换成 . 的方式就该是：
. ./.zshrc
#在使用.的时候，需要注意与表示当前路径的那个点区分开。 
```


**修改删除已有变量**

| 命令 | 	说明| 
| :---: | :--- |
| ```${变量名#匹配字串}```| 	从头向后开始匹配，删除符合匹配字串的最短数据 |
| ```${变量名##匹配字串}```| 	从头向后开始匹配，删除符合匹配字串的最长数据 | 
| ```${变量名%匹配字串}```| 	从尾向前开始匹配，删除符合匹配字串的最短数据 |
| ```${变量名%%匹配字串}```| 	从尾向前开始匹配，删除符合匹配字串的最长数据 |
| ```${变量名/旧的字串/新的字串}```| 	将符合旧字串的第一个字串替换为新的字串 |
| ```${变量名//旧的字串/新的字串}```| 	将符合旧字串的全部字串替换为新的字串 | 

比如要修改我们前面添加到 ```PATH``` 的环境变量。为了避免操作失误导致命令找不到，我们先将 ```PATH``` 赋值给一个新的自定义变量 ```path```：

```shell
$ path=$PATH
$ echo $path
$ path=${path%/home/shiyanlou/mybin}
# 或使用通配符,*表示任意多个任意字符
$ path=${path%*/mybin}
```
变量删除
可以使用 ```unset``` 命令删除一个环境变量：

```
$ unset temp
```

#### 搜索文件

- ```whereis```:  简单快速. 这个搜索很快，因为它并没有从硬盘中依次查找，而是直接从数据库中查询。```whereis``` 只能搜索二进制文件(-b)，man 帮助文件(-m)和源代码文件(-s)。
- ```locate```: 快而全: 通过“ /var/lib/mlocate/mlocate.db ”数据库查找，不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 updatedb 命令更新一次，所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 updatedb 命令
- ```which``` 小而精: 只从 PATH 环境变量指定的路径中去搜索命令
- ```find``` 精而细: ```find``` 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索



#### 内建命令与外部命令

> **内建命令**实际上是 shell 程序的一部分，其中包含的是一些比较简单的 Linux 系统命令，这些命令是写在bash源码的builtins里面的，由 shell 程序识别并在 shell 程序内部完成运行，通常在 Linux 系统加载运行时 shell 就被加载并驻留在系统内存中。而且解析内部命令 shell 不需要创建子进程，因此其执行速度比外部命令快。比如：```history、cd、exit``` 等等。

> **外部命令** 是 Linux 系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调入内存。虽然其不包含在 shell 中，但是其命令执行过程是由 shell 程序控制的。外部命令是在 Bash 之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin等等。比如：```ls、vi```等。

简单来说就是：一个是天生自带的天赋技能，一个是后天得来的附加技能。我们可以使用　```type``` 命令来区分命令是内建的还是外部的。例如这两个得出的结果是不同的

```shell
type exit

type vim

#得到这样的结果说明是内建命令，正如上文所说内建命令都是在 bash 源码中的 builtins 的.def中
xxx is a shell builtin

#得到这样的结果说明是外部命令，正如上文所说，外部命令在/usr/bin or /usr/sbin等等中
xxx is /usr/bin/xxx

#若是得到alias的结果，说明该指令为命令别名所设定的名称；
xxx is an alias for xx --xxx
```


## cd

**home directory和root directory** 不一样, root是/, home 是 /Users/ username 的文件夹

```shell
cd / #go to root directory
cd ~ #home directory
cd .. #到parent directory
cd Documents #go to Document Directory
cd /home/programming/Documents/ #功能与上面一样, Go to Document Directory
cd My\ Books # go to My Books folder, 在My Books中间有空格
cd "My Books" #功能与上面一样
cd 'My Books' #功能与上面一样

```


## apt-get

apt-get(urbantu): install, uninstall, update packages. apt: advance packaging tool

对于centos: 用yum, dnf instead of apt-get 

```shell

sudo apt-get update #resync your local package file to the server package file, update all the packages

java -version #check if java installed, and if so check version
php5 -version #check if php installed, 如果没有install 会给出install的hint

sudo apt-get install php5 #安装首先what is required extra dependency to install php5, 也会显示多少space required to install
php5 -v #显示php5 version

sudo apt-get remove php5 #remove php5
sudo apt-get remove --purge php5 #remove all configuration file related to php5
sudo apt-get autoremove  #auto remove the dependency which required for the package(php5) and no longer needed for other packages



```


## bashrc

bashrc is a script executed whenever a new terminal session start in interactive mode

some linux system， .bashrc file exist when a new terminal session start. Some not

Bashrc file is used for setting up environment variable such as Java. When use git, which repo you checked or cloned, use Bashrc

```shell

ls -a #在home directory ls -a 可以看见有.bashrc

nano .bashrc #查看.bashrc
gedit .bashrc #查看 .bashrc

```

可以修改 .bashrc file 比如加上alias ls='ls --color=auto -l', 之后open new terminal, 输入ls, 显示long list of ls 

![](/img/post/linux/bashrc.png)


![](/img/post/linux/bashrc2.png)




## Bash Script

Script: txt file contain sequence of command

```shell

nano myscript.sh #open editor 

#! /bin/bash  #需要contain location of bash
which bash #会告诉哪里有bash，give location 

./myscript.sh #./ 是去run bash script
#显示permission denied 因为file created not have execute permission 

#先给permission 
chmod +x myscript.sh #give permission for all groups
./myscript.sh #显示会成功


```

![](/img/post/linux/pic8.png)

![](/img/post/linux/bash.png)




## cal

show conventially formatted calendar on your command line

```shell

cal #显示calendar, weekday on the top
ncal  #显示calendar, weekday on the left 
cal 2016 #显示2016的calendar
cal 2 2016 #显示2016年 2月 calendar
cal -3 #give you current month, previous month and next month calendar
#default 是 -1, 比如cal, 等于cal -1
```

## cat ／ tac 


cat: 1. Display Txt 2. combine Txt file 3. Create new Txt file

tac:  为倒序显示
syntax: cat options file1 file2 ... 



```shell
cat Hello World #会打印 echo Hello world
#Ctrl D means the end of cat command 

cat list1.txt #显示list1.txt 所有内容
cat list1.txt | sort #显示list1.txt 根据每行sort 后的顺序打印
cat list1.txt list2.txt #显示list1.txt 和list2.txt所有内容，先显示list1的再显示list2的

cat -b list1.txt #把list1.txt的 不是blank的line(空行) 显示序号

#-n 显示行数
cat -n list1.txt #把list1.txt的 所有行(空行或者不空行) 都显示序号
cat -s list1.txt #squeeze 连续 blank line to one blank line

cat -E list1.txt #add $ at the end of each line

man cat #显示cat所有function

cat > test.txt  #把接下来input的内容 output 到test.txt，输完了 按Ctrl+D， test.txt之前内容被remove
cat >> text.txt #把接下来input的内容 append 到test.txt

cat list1.txt list2.txt > out.txt #把mlist1, list2的内容合并，生成out.txt
cat list1.txt list2.txt > list2.txt #这样是不行的，不能把input 当成output file
cat list1.txt >> list2.txt #修改上面一行的error，append list1.txt 到list2.txt

```


## chmod, File Permissions

drwxr-xr-x 1 beckswu staff 22 Jul 23 18:56 file: d means directory <br/>
-rw-rw-r- 1 beckswu staff 没有d 表示normal file, 如果开头是c, 表示character special file。如果是b，表示binary special file

1表示symbolic links of the file, 接下来表示owner of the file, next is the group of the file, 22 表示size of the file, July 23 18:56 date of created. file is the name of file

symbolic link is a term for any file that contains a reference to another file or directory in the form of an absolute or relative path and that affects pathname resolution


第一个字母表示文件类型:

- **d**: 目录
- **l**: 软连接。 硬链接不常用，软链接相当于windows 快捷方式
- **b**: 块设备
- **c**: character file 
- **s**: socket
- **p**: 管道
- **-**: 普通文件

接下来每三个字母或 '-' 是一组, 第一组表示owner access, 第二组表示owner 所属group access, 第三堆表示 everybody else（其他用户）的access, 

- **r** : reading access
- **w** : writing access
- **x** : executing access. 执行权限像windows exe 

不过 Linux 上不是通过文件后缀名来区分文件的类型。你需要注意的一点是，一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息。

<span style="color:red">**g, o, u 分别表示 group, others 和 user** </span>

```shell

#o means other group, + add permission, - minus permission,
chmod o+x file #给file 的other user(第三堆) 加execute permission

chmod g+x file #给file 的group(第二堆) 加execute permission
chmod g-wx file #给file的group 移走write execute permission

chmod ug=rwx file #给user(owner), group read write execute permission 

chmod a-rwx file #给所有的（owerner, group, others) remove read, write, execution permission


chmod u+rw, g=rw, o+r file #给user add read write, 给group read, write permission, 给other add read permission

```

**二进制数字**:

rwx ->  1\*2\*\*2 +1\*2\*\*1 + 1\*2\*\*0 = 7 


```shell
chmod 600 file #表示给owner 6 ( r, w), group 0, other user 0 

chmod 755 file.txt #give user read, write execute(7), give both group and othe group read and execute access
```

Octal & Numerical Permissions

![](/img/post/linux/pic6.png)

![](/img/post/linux/pic7.png)



change file ownership 

```shell
sudo chown becks iphone6 #如果iphone6 不属于becks, 可以改变ownership
```

## chown 

修改文件拥有者
```shell
chmod becks newfile.txt #把文件修改为becks 为onwer
#or
sudo chmod becks newfile.txt 
```


## cp

CP: copy and paste

```shell

cp options source destination

cp file1.txt file2.txt #if file2.txt not exist will creat file2.txt. Content from file1 will copy to file2 

cp file1.txt dir1 # 把file1.txt copy 到directory 1

cp file1.txt file2.txt dir1 # 把file1.txt 和file2.txt copy 到directory 1

cp -i  file1.txt file2.txt dir1 #如果directory 1 里面有file1.txt -i 会ask 是否要overwrite, 选n, 就会只copy file2 不会copy file1

cp ../f1.txt ../f2.txt . #从parent directory copy f1.txt和f2.txt 到现在directory, 因为没有-i, 会overwrite

cp dir1 dir3 # error， 因为dir1 有文件，不能被copy
cp -R dir1 dir3 # -R means recursive copy,copy everything from dir1 to dir3
#whenever destination (dir3) doesn't exist, it create destination and copy all content from source
#如果存在destination, 只copy paste
cp -vR dir1 dir3 #显示详细的copy 哪些文件


```
![](/img/post/linux/pic1.png)



## date

used to print out and change system date and time information

```shell

date #print 现在系统的时间

date -s "11/20/2003 12:48:00" #设置system time 为 11/20/2003 12:48:00

date +%d%h%y #显示13Jan17

date +%d/%h/%y #显示13-Jan-17

man date #可以显示详细的date format的格式


date "+Date: %m/%d/y%n" #显示01/13/17 %n 是空行线



```
设置时间格式
![](/img/post/linux/date.png)


## dd

```dd```命令用于转换和复制文件，不过它的复制不同于```cp```。 Linux 的很重要的一点，一切即文件，在 Linux 上，硬件的设备驱动（如硬盘）和特殊设备文件（如/dev/zero和/dev/random）都像普通文件一样，只是在各自的驱动程序中实现了对应的功能，```dd``` 也可以读取文件或写入这些文件。这样，```dd```也可以用在备份硬件的引导扇区、获取一定数量的随机数据或者空数据等任务中。```dd```程序也可以在复制时处理数据，例如转换字节序、或在 ASCII 与 EBCDIC 编码间互换。

```dd```的命令行语句与其他的 Linux 程序不同，因为它的命令行选项格式为```选项=值```，而不是更标准的```--选项 值```或```-选项=值 (比如tar -f file)```。```dd```默认从标准输入中读取，并写入到标准输出中，但可以用选项```if（input file，输入文件)```和```of（output file，输出文件）```改变。

| 命令 | 	说明| 
| :---: | :--- |
| ```of``` | 输出流 |
| ```if``` | 输入流 |
| ```bs``` | block size, 用于指定块大小（缺省单位为 Byte，也可为其指定如'K'，'M'，'G'等单位）
| ```count``` | 用于指定块数量 | 
前面说到dd在拷贝的同时还可以实现数据转换，那下面就举一个简单的例子：将输出的英文字符转换为大写再写入文件：| 
| :---: | :--- | |


<span style="color:red">下面两个例子在打完了这个命令后，继续在终端打字，作为你的输入</span>

```shell
# 输出到文件
$ dd of=test bs=10 count=1 # 或者 dd if=/dev/stdin of=test bs=10 count=1
# 输出到test 文件,  总共有10 bytes

# 输出到标准输出
$ dd if=/dev/stdin of=/dev/stdout bs=10 count=1

```

指定只读取总共 10 个字节的数据，当我输入了“hello shiyanlou”之后加上空格回车总共 16 个字节（一个英文字符占一个字节）内容，显然超过了设定大小。使用du和cat命令看到的写入完成文件实际内容确实只有 10 个字节（那个黑底百分号表示这里没有换行符）,而其他的多余输入将被截取并保留在标准输入。


![](/img/post/linux/dd.gif)


前面说到dd在拷贝的同时还可以实现<span style="background-color:#FFFF00">**数据转换**</span>，那下面就举一个简单的例子：将输出的英文字符转换 -> 大写再写入文件：

```shell
 dd if=/dev/stdin of=test bs=10 count=1 conv=ucase
 ```
![](/img/post/linux/dd2.gif)


**使用 dd 命令创建虚拟镜像文件**

从/dev/zero设备创建一个容量为 256M 的空文件：
```shell
dd if=/dev/zero of=virtual.img bs=1M count=256
du -h virtual.img
```

使用 ```mkfs``` 命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）

你可以在命令行输入 ```sudo mkfs``` 然后按下```Tab```键，你可以看到很多个以 ```mkfs``` 为前缀的命令，这些不同的后缀其实就是表示着不同的文件系统，可以用 ```mkfs``` 格式化成的文件系统。 我们可以简单的使用下面的命令来将我们的虚拟磁盘镜像格式化为ext4文件系统：

```shell
sudo mkfs.ext4 virtual.img
```
![](/img/post/linux/dd3.png)

可以看到实际 mkfs.ext4 是使用 mke2fs 来完成格式化工作的。mke2fs 的参数很多，不过我们也不会经常格式化磁盘来玩，所以就掌握这基本用法吧，等你有特殊需求时，再查看 man 文档解决。

更多关于文件系统的知识，请查看wiki： [文件系统](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F#Linux_.E6.94.AF.E6.8F.B4.E7.9A.84.E6.AA.94.E6.A1.88.E7.B3.BB.E7.B5.B1)  [ext3](https://zh.wikipedia.org/wiki/Ext3), [ext4](https://zh.wikipedia.org/wiki/Ext4)

如果你想知道 Linux 支持哪些文件系统你可以输入```ls -l /lib/modules/$(uname -r)/kernel/fs```（我们的环境中无法查看）查看。


**使用 mount 命令挂载磁盘到目录树**

用户在 Linux/UNIX 的机器上打开一个文件以前，包含该文件的文件系统必须先进行挂载的动作，此时用户要对该文件系统执行 mount 的指令以进行挂载。该指令通常是使用在 USB 或其他可移除存储设备上，而根目录则需要始终保持挂载的状态。又因为 Linux/UNIX 文件系统可以对应一个文件而不一定要是硬件设备，所以可以挂载一个包含文件系统的文件到目录树。

Linux/UNIX 命令行的 mount 指令是告诉操作系统，对应的文件系统已经准备好，可以使用了，而该文件系统会对应到一个特定的点（称为挂载点）。挂载好的文件、目录、设备以及特殊文件即可提供用户使用。

我们先来使用mount来查看下主机已经挂载的文件系统

```shell
sudo mount
```
![](/img/post/linux/mount.png)

输出的结果中每一行表示一个设备或虚拟设备,每一行最前面是设备名，然后是 on 后面是挂载点，type 后面表示文件系统类型，再后面是挂载选项（比如可以在挂载时设定以只读方式挂载等等）。

那么我们如何挂载真正的磁盘到目录树呢，mount命令的一般格式如下：
```shell
mount [options] [source] [directory]
```
一些常用操作：
```
mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点]
```
现在直接来挂载我们创建的虚拟磁盘镜像到/mnt目录：

```shell
mount -o loop -t ext4 virtual.img /mnt 
# 也可以省略挂载类型，很多时候 mount 会自动识别

# 以只读方式挂载
mount -o loop --ro virtual.img /mnt
# 或者mount -o loop,ro virtual.img /mnt
```

使用 umount 命令卸载已挂载磁盘

```shell
# 命令格式 sudo umount 已挂载设备名或者挂载点，如：
sudo umount /mnt
```

[具体见 Chapter 7.3.1](https://www.shiyanlou.com/courses/1/learning/?id=62)

## Directory Permission


```shell

chmod u-w dir #remove user write permission for directory
#cd 进dir, touch f.txt 显示permission denied

chmod u-r dir #remove read access from user
#cd dir 显示 permission denied

chmod u-x dir #remove execute access from user 
#cd dir 或者 ls dir/ 都显示permission denied


```

## du, df, free

du（estimate file space usage）命令与df（report file system disk space usage）

View Resources

```df``` : 查看磁盘容量, 
![](/img/post/linux/df1.png)

但在实际的物理主机上会更像这样：

![](/img/post/linux/df2.png)

物理主机上的 /dev/sda2 是对应着主机硬盘的分区，<span style="color:red">后面的数字表示分区号，数字前面的字母 a 表示第几块硬盘（也可能是可移动磁盘）</span>，你如果主机上有多块硬盘则可能还会出现 /dev/sdb，/dev/sdc 这些磁盘设备都会在 /dev 目录下以文件的存在形式。

接着你还会看到"1k-块"这个陌生的东西，它表示以磁盘块大小的方式显示容量，后面为相应的以块大小表示的已用和可用容量，在你了解 Linux 的文件系统之前这个就先不管吧，我们以一种你应该看得懂的方式展示：

```df -h```: human reable 显示

![](/img/post/linux/df3.png)


**使用 du 命令查看目录的容量**

| Flag | 	说明| 
| :---: | :--- |
| ```-a```| 同```--all``` 显示目录中所有文件的大小 |
| ```-d``` | 参数指定查看目录的深度 |
| ```-h``` | 同 ```--human-readable``` 以K，M，G为单位，提高信息的可读性 | 
| ```-s``` |  #同 ```--summarize``` 仅显示总计，只列出最后加总的值 |

```
# 默认同样以 块 的大小展示
du 
# 加上`-h`参数，以更易读的方式展示
du -h


# 只查看1级目录的信息
du -h -d 0 ~
# 查看2级
du -h -d 1 ~
```
常用参数

```shell
du -a #同```--all``` 显示目录中所有文件的大小 
du -s #同--summarize 仅显示总计，只列出最后加总的值。
```

![](/img/post/linux/df4.png)

```shell
df #the amount of disk space being used by your file system
df -h #the human readable output, 显示多少G, M, k

du #estimate and display the disk space used by files in details
du -h #human readable format
du -sh #-s summary 只给你现在所在directory 文件所占的大小
sudo du -sh #用sudo 原因是因为可能有的file permission denied 需要用sudo 
du -sh /etc/ #show summary used space by etc folder

free #display the total amount free and used physical and swap memory in the system as well as buffer in the kernel
free -b  #-b btye, -k KB, -m MB, -G GB, -T TB

```


## echo

used for bash scripting to print 

```shell

echo hello world # 在terminal 打印出hello world
echo "hello world" #与上面一样, better use "" for echo

myvar="Mark" #myvar= 不能有空格, assign variable
echo $myvar #print variable

x=10
echo "the value of x is $x" #print the value of x is 10

echo -e 'some \text' #-e use escape,  \t -> tab,   print:  some     ext

```
## file 

file 命令查看文件的类型

```shell
file /bin/ls
file file.txt
```



## find

find 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索

这条命令表示去 /etc/ 目录下面 ，搜索名字叫做 interfaces 的文件或者目录。这是 find 命令最常见的格式，千万记住 find 的第一个参数是要搜索的地方：


```shell
sudo find /etc/ -name interfaces
```
> 注意 find 命令的路径是作为第一个参数的， 基本命令格式为 ```find [path] [option] [action]```。

与时间相关的命令参数：

| 命令 | 	说明| 
| :---: | :--- |
|```-atime```| 	最后访问时间 |
|```-ctime```| 	最后修改文件内容的时间 |
|```-mtime```| 	最后修改文件属性的时间 |

下面以 -mtime 参数举例：

- ```-mtime n```：n 为数字，表示为在 n 天之前的“一天之内”修改过的文件
- ```-mtime +n```：列出在 n 天之前（不包含 n 天本身）被修改过的文件
- ```-mtime -n```：列出在 n 天之内（包含 n 天本身）被修改过的文件
- ```-newer file```：file 为一个已存在的文件，列出比 file 还要新的文件名

![](/img/post/linux/find.png)

```shell
#列出 home 目录中，当天（24 小时之内）有改动的文件：
find ~ -mtime 0

#列出用户家目录下比 Code 文件夹新的文件：
find ~ -newer /home/shiyanlou/Code
```

```shell

find location -name file_name #syntax

find /home/ -name test.sh #-name search by name, return directory 
find /home/dir1 -name test.* #search in /home/dir1 folder by name, any file start with test. 可以是.txt, .sh
find /home/dir1 -name *.txt #search any file extension is txt
find / -name dmesg #search in the root directory, 也许有permission error 因为有些directory 不允许access
sudo find / -name dmesg 

find /home  -mtime -1  #look at the file created 1 days before, 也可以用加号，+1, + 2


```

## gedit

gedit is the default text editor

```shell
touch shell.sh
gedit shell.sh #打开shell.sh 文件进行编辑
```


## grep

grep: global regular expression print. can be used to search pattern / word in a text file or a number of text file with grep command

```shell

#
man tar > file.txt 

grep "options" file.txt #keyword I want to search and file name, 
#grep 是case sensitive的, 上面的search options 不会search Options,

grep -i "options" file.txt #make search not case sensitive, 也会search Options

grep -n "options" file.txt #在file 中search并显示file.txt的options, 并显示在哪行

grep -n "Some options" file.txt #在file 中search并显示Some options


#used in multiple files
grep -n "Some options" f1.txt, f2.txt f3.txt f4.txt #在多个file 中search并显示Some options
grep -n "Some options" * #在现在folder中的所有file search并显示Some options 的行

grep -nv "Some options" f1.txt #显示f1.txt 不包含Some options的行

grep -help #显示有的flag, options 用grep command

```
![](/img/post/linux/grep.png)


## groups, groupadd, groupdel

group show which group is currently user connected to

```shell
groups #show which group is currently user connected to

cat /etc/group #show all the group in your system,  group <-> user connected to 

sudo groupadd Java #add newgroup in system
sudo groupdel Java #delete existing group

#-a add user to group, -d remove user from group
sudo gpasswd -a mark Java # add mark to the Java group
sudo gpasswd -d mark Java #remove user from Group


```


## head .tail

Head: output the first part of the file 
Tail: output the last part of the file, ```-f``` 不停的读取某个文件并显示


```shell
head log.txt #show first 10 line of file 
tail log.txt #show last 10 line of file 


head -n3 log.txt #show first 3 lines of file
head -3 log.txt #跟上面一样

tail -n3 log.txt #show last 3 lines of file
tail -3 log.txt #跟上面一样

tail -f log.txt #output last 10 lines of file. watch the file, whenever file change, will show last 10 lines of code
ctrl + C #exit 
head  log.txt kern.log #先print 10 lines of log.txt 再print 10 lines of kern.log

head -3 log.txt kern.log #先print 3 lines of log.txt 再print 3 lines of kern.log


```




## ifconfig

ifconfig: interface configuration: used to view and change network interface configuration on your system

```shell
ifconfig #show you some output

ifconfig eth0 #only show eth0 interface

#up, down to disable internet connection 
sudo ifconfig eth0 down #internet connection will be down

sudo ifconfig eth0 up #enable internet 

```

ethO: wired internet cable  <br/>
WLAN0: wireless internet connection <br/>
0: is the first internet interface. 如果有multiple internet interface, 显示eth1, or WLAN2
l0: loop back interface. An interface that system use to communcate to excel


## kill

kill process

```shell

kill -flags pid # syntax

pidof unity-control-center #lookup pid by name

kill 3286 # kill pid = 3286 process

kill -KILL 3294 #force to kill process

kill -9 3294 # force to kill  process (flag -9)

ps -ux  #find pid; give a long list of running process (current user)
ps -aux #find pid; give a long list of all running process (all users)
ps -U  Becks #give all process under User Becks
ps -C gnome-terminal #give all process related to program gnome-terminal, 可能连着多个instances
```

## locate

通过“ /var/lib/mlocate/mlocate.db ”数据库查找，不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 updatedb 命令更新一次，所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 updatedb 命令（在我们的环境中必须先执行一次该命令）。它可以用来查找指定目录下的不同文件类型，如查找 /etc 下所有以 sh 开头的文件：(注意，它不只是在 /etc 目录下查找，还会自动递归子目录进行查找)

```shell
sudo apt-get update
sudo apt-get install locate
locate /etc/sh
```

查找 /usr/share/ 下所有 jpg 文件：
```shell
$ locate /usr/share/\*.jpg #注意要添加 * 号前面的反斜杠转义，否则会无法找到。
```

如果想只统计数目可以加上 ```-c``` 参数，```-i``` 参数可以忽略大小写进行查找，whereis 的 ```-b```、```-m```、```-s``` 同样可以使用。


## less

read file and search pattern in the file, 比如用cat print整个文件，当文件很大，当print完成，不能显示文件开头，用less，可以看

```shell

less big.txt   #only show the starting point of the file, 然后用键盘的↓，enter show one more row below at one time
#用键盘的↑，enter show one row above at one time
#键盘的space show page by page below
#键盘的shift+B show page by page above
#键盘的shift+G to the end of file
#键盘先1 + G or g (without shift) to go to the begining of the file
#想找文件从上到下，比如找book, type  /book + enter, 找next, type n
#想找文件从下到上，比如找book, type ?book + enter, 找上一个，type n
#想退出less command, press q



```

```shell
more file
#Enter 向下滚动一行
#Space 向下滚动一屏
#h     帮助
#q     退出
```





## mkdir

```shell
mkdir image #生成image directory
mkdir image/pic #生成pic directory inside image directory
mkdir names/mark #当names 不在当前文件夹下，显示error, No such file or directory
mkdir -p names/mark (mkdir --parents names/mark ) #-p means -- parents, 比如当names 不存在的时候，这样可以建立, 如果不加p, 会报错
#-p is the same as --parents

mkdir -p names/{john,tom,bob}  #creat several directory inside current directory, 建立三个文件夹,john, tom,bob
# {john,tom,bob} 不能有空格，否则建立的文件夹是 {john,


```


## mv ／ rename

mv: rename, move

```shell

mv options source dest

mv f1.txt f2.txt #rename f1.txt 成f2.txt 

mv f1.txt dir1/ #把f1.txt 移动到dir1
#如果dir1 中有f1.txt, move 会overwrite 原有的file 内容

mv f1.txt f2.txt dir1/ #move 多个文件到dir1

mv -i f1.txt dir1 #move f1.txt 到dir1 folder中, 如果要overwrite 会问
mv -i f1.txt dir1/ #与上面一样的

mv dir1 dir2 #把dir1 移动到dir2 中, content 也会move,  不用-R
#dir1就现在文件夹下不存在了,dir1 在dir2中

#tricky，如果当dir3 不存在
mv dir2 dir3 #dir2中的内容移动到dir3中，所以dir3中只含有dir1，dir2也消失了
#如果dir3 也存在，那么dir3 中有dir2, dir2中有dir1 

mv -v file3.txt dir3 #V, verb, 显示具体怎么移动的
```

如果想实现批量重命名, mv 就不行了, 不过它要用 perl 正则表达式来作为参数

```shell
touch file{1..5}.txt #批量创建5个文件

# 批量将这 5 个后缀为 .txt 的文本文件重命名为以 .c 为后缀的文件:
rename 's/\.txt/\.c/' *.txt

# 批量将这 5 个文件，文件名和后缀改为大写:
rename 'y/a-z/A-Z/' *.c
```

## nano

nano is a small and friendly text editor, besides it has interactive search, replace, go to line, and indentation 

```shell
nano file.txt #open txt editor, file open but not show has been created, 因为还没有save

#press ctrl + o, -> means write out
#press ctrl + x  -> quit the file
#press ctrl + k -> cut
#press ctrl + u -> paste

nao abc.cpp #会有color, code highlighting, 不光是cpp, 也可以是Java,c 



```


![](/img/post/linux/pic3.png)

![](/img/post/linux/pic4.png)



## netstat

netstat is to display network connection, routing tables and a number of network interfaces, and view network protocal states 

```shell

netstat -a #show all connections which are available on your system whether it is TCP or UDP or UNIX connection,
#上面aslo display the status if it connected, listening, or established

# | means after | whatever second command is used will implement the output of the first command  
netstat -a | less #use the output of netstat to display with less command 

netstat -at | less #-t means just show the TCP connection

netstat -au | less #-u means just show the UDP connection

netstat -l | less #-l means just show listenning state

netstat  -lt | less #-lt means just show listening and TCP connection

netstat -lu | less #-lu means just show listenning and UDP connection

netstat -s | less  #-s show the statistic of connection, you can see which type of connection it is and properties of the packet what is happening

netstat -st | less #-st show the statistic of TCP connection

netstat -su | less #-su show the statistic of UDP connection 

netstat -pt | less #-pt show PID of TCP connection 

netstat -px | less #-px show PID of UNIX connection

netstat -n  | less #-n show the numeric port of connection

netstat -c # show the connection continuously, it refresh by itself

netstat -ie   #-ie extended interface, it is the same output as ifconfig 

netstat -an | grep ":80"  #-an show numeric port of all conection and search which port has :80 

```


## nl

- ```-b``` : 指定添加行号的方式，主要有两种：
   - ```-b a```:表示无论是否为空行，同样列出行号("cat -n"就是这种方式)
   - ```-b t```:只列出非空行的编号并列出（默认为这种方式）
- ```-n``` : 设置行号的样式，主要有三种：
    ```-n ln```:在行号字段最左端显示
    ```-n rn```:在行号字段最右边显示，且不加 0
    ```-n rz```:在行号字段最右边显示，且加 0
- ```-w``` : 行号字段占用的位数(默认为 6 位)

```shell
nl -b a file # 是否空行都列出行号
```


## rm & rmdir

**rmdir**: remove directory, **rm**: rmove file and directory

```shell

rmdir abc # remove abc的folder
rmdir a/b/c/d/e #只remove 最后e的directory
rmdir -p a/b/c/d/e  #remove 所有的directory structure
rmdir -p a/b/c/d/e #remove 所有directory structure，
#如果a/b/c/d/e 每个并不是空的文件夹，会显示error, failed to remove directory a/b: Directory not empty

rm -rv a/b #并显示(verb)remove的进程
rm -rv a #与上面一行作用是一样的,

rm -f file #强制删除文件

```


## sudo

sudo: superuser do: allow you some priviledge as adminstrator or a power user

有时候比如mkdir dir, show permission denied error, 用sudo tell linux command to execute as administrator

比如install G++, GCC, will ask user priviledge 

```shell

sudo mkdir dir #需要provide password, run as administrator 

sudo apt-get install g++ # apt-get install : install software

sudo -s #change priviledge from local user to root 

```



## tar

tar: Tape Archive, compress and extract file 

在 Linux 上面更常用的是 tar 工具，tar 原本只是一个打包工具，只是同时还是实现了对 7z、gzip、xz、bzip2 等工具的支持，这些压缩工具本身只能实现对文件或目录（单独压缩目录中的文件）的压缩，没有实现对文件的打包压缩，所以我们也无需再单独去学习其他几个工具，tar 的解压和压缩都是同一个命令，只需参数不同，使用比较方便。

| flag | 	说明| 
| :---: | :--- |
| ```-c``` | 创建一个tar包文件 | 
| ```-f``` | 指定创建文件名  注意文件名必须紧跟在 -f 参数之后，比如不能写成 ```tar -fc shiyanlou.tar```，可以写成 ```tar -f shiyanlou.tar -c ~``` |
| ```-v``` | 可视的的方式输出打包的文件 |
| ```-p``` | 留文件的属性 |
| ```-h```| 备份链接指向的源文件而不是链接本身 |
| ```－x``` | 解包一个文件 | 
| ```－t``` | 只查看文件不解包 | 
| ```-C``` | 解包到指定目录 |




创建一个 tar 包：
```shell
cd /home/shiyanlou
tar -P -cf shiyanlou.tar /home/shiyanlou/Desktop
#上面命令中，-P 保留绝对路径符，-c 表示创建一个 tar 包文件，-f 用于指定创建的文件名，
```

解包一个文件（```-x``` 参数）到指定路径的已存在目录（```-C``` 参数）：
```shell
mkdir tardir
tar -xf shiyanlou.tar -C tardir
```

只查看不解包文件 -t 参数：
```shell
tar -tf shiyanlou.tar
```

保留文件属性和跟随链接（符号链接或软链接），有时候我们使用 tar 备份文件当你在其他主机还原时希望保留文件的属性（```-p``` 参数）和备份链接指向的源文件而不是链接本身（```-h```` 参数）：
```shell
$ tar -cphf etc.tar /etc
```

对于创建不同的压缩格式的文件，对于 tar 来说是相当简单的，需要的只是换一个参数

| 压缩文件格式 | 	参数 | 
| :---: | :--- |
| ```*.tar.gz```	| ```-z```|
| ```*.tar.xz```	| ```-J```|
| ```*tar.bz2```	| ```-j```|

我们只需要在创建 tar 文件的基础上添加 -z 参数，使用 gzip 来压缩文件：

```shell
tar -czf shiyanlou.tar.gz /home/shiyanlou/Desktop
```

解压 ```*.tar.gz``` 文件：
```shell
tar -xzf shiyanlou.tar.gz
```

```shell

tar -cvf test.tar test #cvf: create verb, f filename, 把test folder compress 成命名为test tar 压缩文件
tar -xvf test.tar #xvf x: extract v verb, f filename,  把test.tar extract 压缩文件

#有时候用 tar.gz  gz stands for gzip format

tar -cvfz test.tar.gz f.txt #z 表示生成gz file, z必须在c flag 之后, 压缩文件成tar.gz 
tar -xvfz test.tar.gz f.txt #解压 gz 文件

man tar > tar.txt #把tar 的man output 到tar.txt 中

```



## top

top: provide you dynamic real time view of running system. Used to see which program take more of your CPU and which program consuming more of your memory

```shell
top #give you view of system, it refreshing every second
s # can update time, 输入1 refresh every 1 second
i # to filter idle process
k # 把鼠标选中PID, press k, kill process
q # quit the top view

```

PID: process ID, 同一个程序不同时候run pid 可能不一样的 <br/>

![](/img/post/linux/pic5.png)



## touch

Touch is the easist way to create new empty file in Linux. It is also used for changing timestamp on existing file or directory 

<span style="background-color: #FFFF00">you cannot create new directory using touch, can only create empty file</span>

```shell

touch file6 #建一个新的empty file6
touch f7.txt #建立一个新的txt, 名字是f7

touch file1.txt #修改file1.txt的timestamp, 不修改内容，只修改了timestamp

touch file{1..10}.txt #创建 file1.txt , file2.txt , ... ,file10.txt

```

![](/img/post/linux/pic2.png)


## type 

区分内建命令与外部命令, 详见Linux基础,  内建命令与外部命令


## useradd /adduser

create user

```shell

useradd the_name_of_user #syntax

sudo useradd mark -m -s /bin/bash -g users -c "my comment"
#-m:  create default home directory for this user
#-s /bin/bash allow usesr to use shell
#-g assign group, default group is users
#-c "my comment" provide comment to user 
#-G assign/give user defined group
#sudo: because you don't want anybody create user, only root can create user

sudo passwd mark  #change password for user


```

adduser 和 useradd 的区别是什么？
答：useradd 只创建用户，创建完了用 当前用户的passwd 去设置新用户的密码。adduser 会创建用户，创建目录，创建密码（提示你设置），做这一系列的操作。其实 useradd、userdel 这类操作更像是一种命令，执行完了就返回。而 adduser 更像是一种程序，需要你输入、确定等一系列操作。

## userdel



```shell

sudo userdel mark #delete user mark (username, password, data), not delete home directory for user

sudo userdel -r mark #delete user (home directory, username, password, data)

sudo -r /home/mark/  #remove all the data from user
#或者用
sudo  deluser mark --remove-home

```
![](/img/post/linux/userdel.png)






## vim

vim 的6种模式

**普通模式(Normal mode)**

> 在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。

> Vim强大的编辑能来自于其普通模式命令。普通模式命令往往需要一个操作符结尾。例如普通模式命令dd删除当前行，但是第一个"d"的后面可以跟另外的移动命令来代替第二个d，比如用移动到下一行的"j"键就可以删除当前行和下一行。另外还可以指定命令重复次数，2dd（重复dd两次），和dj的效果是一样的。用户学习了各种各样的文本间移动／跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效地进行文本编辑。

> 在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按a（append／追加）键或者i（insert／插入）键。

**插入模式(Insert mode)**

> 在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。

> 在插入模式中，可以按ESC键回到普通模式。

**可视模式(Visual mode)**

> 这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的"文本对象"也能和移动命令一样用在这个模式中。

**选择模式(Select mode)**

> 这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。

**命令行模式(Command line mode)**

> 在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（:键），搜索（/和?键）或者过滤命令（!键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。

**Ex模式(Ex mode)**

> 这和命令行模式比较相似，在使用:visual命令离开Ex模式前，可以一次执行多条命令。
> 这其中我们常用到就是普通模式、插入模式和命令行模式，本课程也只涉及这三个常用模式的内容



```shell
vim test #用vim 创建或打开test 文件
i # 进入插入 模式 
a # 进入插入模式 append
ESC or Ctrl + [ #进入普通模式
： #进入命令模式
:w #保存文档 但不会推出 
:wq #输入wq 表示 save and exit 
:w 文件名 #将文档另存为其他文件名或存到其他路径下

cat test #打印刚写的test file
```

**从普通模式进入命令行模式(Command line mode)**

| 命令 | 	说明| 
| :---: | :--- |
| ```:q!``` | 	强制退出，不保存 | 
| ```:q``` | 	退出 | 
| ```:wq!``` | 	强制保存并退出 | 
| ```:w <文件路径>``` | 	另存为 | 
| ```:saveas 文件路径``` | 	另存为 | 
| ```:x```	|  保存并退出 | 
| ```:wq```	|  保存并退出 | 
| ```:set number``` | 显示行数 |


**普通模式** 下输入``Shift+zz``即可保存退出vim

```shell
vim #打开vim 编辑器，但不会打开任何文件
:e iphone #创建一个名为iphone的文件


#输入以下:
12345678
abcdefghijk
shiyanlou.com

Esc #进入普通模式
```
 
**普通模式下移动光标**

可以用方向键或者 h,j,k,l 移动光标

|按键	| 说明 | 
| :---: | :--- |
| ```h``` | 	左 | 
| ```l```	|  右（小写L）| 
| ```j```	|  下 | 
| ```k``` | 	上 | 
| ```w``` | 	移动到下一个单词开头 |
| ```e``` | 到当前单词的结尾  |
| ```b``` |	到前一个单词的开头 |
| ```ge``` |	到前一个单词的结尾 |
| ```0或^``` |	到行头 |
| ```$``` |	到行尾 |
| ```f<字母>``` |	向后搜索<字母>并跳转到第一个匹配的位置(非常实用)，只能是第一个字母 |
| ```F<字母>``` |	向前搜索<字母>并跳转到第一个匹配的位置 |
| ```t<字母>``` |	向后搜索<字母>并跳转到第一个匹配位置之前的一个字母(不常用) | 
| ```T<字母>``` |	向前搜索<字母>并跳转到第一个匹配位置之后的一个字母(不常用) | 
| ```b``` | 	移动到上一个单词 |
| ```nG(n Shift+g)``` |	游标移动到第 n 行(如果默认没有显示行号，请先进入命令模式，输入```:set nu```以显示行号) |
| ```gg``` |	游标移动到到第一行 |
| ```G(Shift+g)``` |	到最后一行 |
| ```Ctrl+o``` | 可以使用 ```Ctrl+o``` 快速回到上一次(跳转前)光标所在位置,这个技巧很实用，比如当你在写代码时，忽然想起有个 bug，需要修改，这时候你跳过去改好了，只需要按下 ```Ctrl+o``` 就可以回到你之前的位置。|
 

**普通模式下删除vim文本信息**
进入普通模式，使用下列命令可以进行文本快速删除：

| 命令 | 	说明 | 
| :---: | :--- |
| ```x or .``` | 	删除游标所在的字符 | 
| ```X``` | 	删除游标所在前一个字符 | 
| ```Delete``` | 	同x | 
| ```dd``` | 	删除整行(实际上是剪切) | 
| ```dw or daw``` | 	删除一个单词（不适用中文）, ```daw``` delete a word | 
| ```dnw``` | 用具体数字代替n, 表示删除n个单词, e.g. ```d3w``` delete 3 words |
| ```d$或D``` | 	删除至行尾 | 
| ```d^``` | 	删除至行首 | 
| ```dG``` | 	删除到文档结尾处 | 
| ```d1G``` | 	删至文档首部 | 
| ```N<command>``` | 用具体数字代替n 表示重复后面的操作. e.g. ```2dd``` 表示一次删除2行 |


**普通模式下复制粘贴 copy & paste**

| 命令 | 	说明 | 
| :---: | :--- |
| ```yy```| 复制游标所在的整行（```3yy```表示复制3行） |
| ```y^ or y0``` |  制至行首。不含光标所在处字符 |
| ```y$``` |  复制至行尾。含光标所在处字 |
| ```yw``` | 复制一个单词 |
| ```y2w```|  复制两个单词 |
| ```yG``` |  复制至文本末 |
| ```y1G``` | 复制至文本开头  |
| ```p``` | p(小写)代表粘贴至光标后（下）|
| ```P``` | P(大写)代表粘贴至光标前（上）| 
| ```ddp``` | 剪切粘贴，交换上下行， 可以先```dd``` 然后到指定行 ```p```, 实现行之间剪切粘贴 |


**普通模式下替换 replace 和撤销(Undo)命令**

| 命令 | 	说明 | 
| :---: | :--- |
| ```r+<待替换字母>```|	将游标所在字母替换为指定字母 |
| ```R```|	连续替换，直到按下Esc | 
| ```cc```|	替换整行，即删除游标所在行，并进入插入模式|
| ```cw```|	替换一个单词，即删除一个单词，并进入插入模式 |
| ```C(大写)```|	替换游标以后至行末 |
| ```~```|	反转游标所在字母大小写(小写变大写，或者大写变小写) |
| ```u{n}```|	撤销一次或n次操作 |
| ```U(大写)```|	撤销当前行的所有修改 |
| ```Ctrl+r```|	redo，即撤销undo的操作 |

**普通模式下快速调整缩 format**


| 命令 | 	说明 | 
| :---: | :--- |
| ```>>```	|  整行将向右缩进  |
| ```<<```	|   整行向左回退 |
| ```:set shiftwidth```	|  进行设置可以控制缩进和回退的字符数 |
| ```:set shiftwidth?```	| 获取目前的设定值  |
| ```:set shiftwidth=10```  | 设置缩进为10个字符 |
| ```:ce``` | ce(center)命令使本行内容居中 | 
| ```:ri``` | ri(right)命令使本行文本靠右 |
| ```:le``` | le(left)命令使本行内容靠左 | 

**vim的功能设定**

下面设定值， 设定值退出vim后不会保存。要永久保存配置需要修改vim配置文件。 vim的配置文件~/.vimrc(在/etc/vim/vimrc)，可以打开文件进行修改，不过务必小心不要影响vim正常使用

| 命令 | 	说明 | 
| :---: | :--- |
| ```set nu``` or ```set number```| 显示行数 | 
| ```:set或者:se```	|  显示所有修改过的配置 | 
| ```:set al```	| l 显示所有的设定值 | 
| ```:set option?```	|  显示option的设定值 | 
| ```:set nooption```	|  取消当前设定值 | 
| ```:set autoindent(ai)```	|  设置自动缩进 | 
| ```:set autowrite(aw)```	|  设置自动存档，默认未打开 | 
| ```:set background=dark或light```	| ，设置背景风格 | 
| ```:set backup(bk)```	|  设置自动备份，默认未打开 | 
| ```:set cindent(cin)```	|  设置C语言风格缩进 |  



**普通模式下快速调整缩 find**


| 命令 | 	说明 | 
| :---: | :--- |
| ```/``` | ```/ ``` 键入需要查找的字符串 按回车后就会进行向下查找， ```n``` 查找下一个内容, ```N``` 查找上一个内容 |
| ```?``` | ```? ``` 与```/``` 类似，但是是向上查找 |
| ```:noh``` | 可取消搜索 | 
| ```\*``` | 寻找游标所在处的单词 | 
| ```\#``` |  同上，但 ```\# ```是向前（上）找，```\*```则是向后（下）找 | 
| ```g\*``` | 同```\*``` ，但部分符合该单词即可 |
| ```g\#``` | 同```\#``` ，但部分符合该单词即可 |

使用 vim 打开文件进行编辑, 搜索有高亮，需要在配置文件 .vimrc 中设置 ```set hls``` 


**普通模式 选择**

| 命令 | 	说明 | 
| :---: | :--- |
| ```v``` | 进入字符选择模式，就可以移动光标，光标走过的地方就会选取。再次按下v后就会取消选取 |
| ```Shift+v``` | 会把整行选取，可以上下移动光标选更多的行，同样，再按一次 Shift+v 就可以取消选取 |
| ```Ctrl+v```| 这是区域选择模式，可以进行矩形区域选择，再按一次 Ctrl+v 取消选取 |

在可视模式下输入 ```d``` 删除选取区域内容 <br/>
在可视模式下输入 ```y```复制选取区域内容

e.g. 
- 在普通模式下``9G```跳转到第9行,输入```Shift+v（小写V）```，进入可视模式进行行选择，选中5行，按下```>>```缩进，将5行整体缩进一个shiftwidth
- 在普通模式下输入 ```Ctrl+v（小写V```，进入可视模式进行矩形区域选择，选中第一列字符然后 press```x```删除整列



**从普通模式进入插入模式**

| 命令 | 	说明 | 
| :---: | :--- |
| ```i```	| 在当前光标处进行编辑 | 
| ```I```	| 在行首插入 | 
| ```A```	| 在行末插入 | 
| ```a```	| 在光标后插入编辑 | 
| ```o```	| 在当前行后插入一个新行 | 
| ```O```	| 在当前行前插入一个新行 | 
| ```cw``` | 	替换从光标所在位置后到一个单词结尾的字符 | 


**普通模式下 多个vim窗口**

| 命令 | 	说明 | 
| :---: | :--- |
| ```new``` | 打开新的vim 窗口 | 
| ```:sp 1.txt``` |  打开新的水平分屏视窗来编辑1.txt |
| ```:vsp 2.txt``` |  打开新的垂直分屏视窗来编辑2.txt |
| ```Ctrl+w s ``` | 将当前窗口分割成两个水平的窗口 |
| ```Ctrl+w v``` |  将当前窗口分割成两个垂直的窗口 |
| ```Ctrl+w q``` |  即 :q 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即:q! |
| ```Ctrl+w o``` |  打开一个视窗并且隐藏之前的所有视窗 |
| ```Ctrl+w j``` |  移至下面视窗 |
| ```Ctrl+w k``` |  移至上面视窗 |
| ```Ctrl+w h``` |  移至左边视窗 |
| ```Ctrl+w l``` |  移至右边视窗 |
| ```Ctrl+w J``` |  将当前视窗移至下面 |
| ```Ctrl+w K``` |  将当前视窗移至上面 |
| ```Ctrl+w H``` |  将当前视窗移至左边 |
| ```Ctrl+w L``` |  将当前视窗移至右边 |
| ```Ctrl+w -``` |  减小视窗的高度 |
| ```Ctrl+w +``` |  增加视窗的高度 |



**使用vim编辑多个文件**

```shell
vim 1.txt 2.txt #默认进入1.txt 
```
默认进入1.txt文件的编辑界面

- 命令行模式下输入 ```:n``` 编辑 2.txt 文件，可以加 ```!``` 即 ```:n!``` 强制切换，之前一个文件的输入没有保存，仅仅切换到另一个文件
- 命令行模式下输入 ```:N``` 编辑 1.txt 文件，可以加 ```!``` 即 ```:N!``` 强制切换，之前文件内的输入没有保存，仅仅是切换到另一个文件


| 命令 | 	说明 | 
| :---: | :--- |
| ```e 3.txt```	| 打开新文件3.txt | 
| ```e#```	|  #回到前一个文件 |
| ```e! 4.txt```	| 新打开文件4.txt，放弃正在编辑的文件 | 
| ```ls```	| 可以列出以前编辑过的文档 | 
| ``` 2.txt```	|（或者编号）可以直接进入文件2.txt编辑 | 
| ``` 2.txt```	|（或者编号）可以删除以前编辑过的列表中的文件项目 |  
| ```f```	| 显示正在编辑的文件名 |
| ```f new.txt```	| 改变正在编辑的文件名字为new.txt |
| ```vim -r 1.txt``` 进入文档后, ```vim -r 1.txt``` | 因为断电等原因造成文档没有保存，可以恢复 |


**创建加密文档**

```
vim -x file1
```
输入密码 确认密码 这样在下一次打开时，vim就会要求你输入密码


**命令模式 vim执行外部命令**

在命令行模式中输入!可以执行外部的shell命令

| 命令 | 	说明 | 
| :---: | :--- |
| ```:!ls```	| 用于显示当前目录的内容 |
| ```:!rm```	|  FILENAME 用于删除名为 FILENAME 的文件 |
| ```:w```	|  FILENAME可将当前 VIM 中正在编辑的文件另存为 FILENAME 文件 |


**查看帮助**

| 命令 | 	说明 | 
| :---: | :--- |
| ```F1```| 普通模式下按F1打开vim自己预设的帮助文档 |
| ```:h shiftwidth```| 打开名为shiftwidth的帮助文件 |
| ```:ver```| 显示版本及参数 | 



## watch

run scripts for command at a regular interval or repeatedly


```shell

watch free -m #可以看见几秒会更新一次
Ctrl + C #exit watch command
watch -n 1 free -m #让free -m command run every 1 second
watch -n 0,5 free -m #让free -m command run every 0.5 second


```
![](/img/post/linux/watch.png)


## wc

wc: world count, print a count of lines, words and characters for each files


```shell

wc test.txt #打出#lines, #words, #characters
wc -c test.txt #只打出#characters
wc -l test.txt #只打出#lines
wc -w test.txt #只打出#words

wc -L test.txt #只给出number of character in longest line


```

1, 6, 42: 1 number of line, 6 number of words, 42 number of characters

![](/img/post/linux/wc.png)


## whereis 

简单快速搜索

```shell
whereis who #找who command 来自哪个文件夹

whereis find 

```

你会看到 whereis find 找到了三个路径，两个可执行文件路径和一个 man 在线帮助文件所在路径，<span style="background-color:#FFFF00">这个搜索很快，因为它并没有从硬盘中依次查找，而是直接从数据库中查询</span>。whereis 只能搜索二进制文件(-b)，man 帮助文件(-m)和源代码文件(-s)。如果想要获得更全面的搜索结果可以使用 locate 命令。

![](/img/post/linux/whereis.png)

## which & what

which 本身是 Shell 内建的一个命令，我们通常使用 which 来确定是否安装了某个指定的软件，</span style="background-color:#FFFF00">因为它只从 PATH 环境变量指定的路径中去搜索命令《/span>：


which: where software/command located

what: display short manual page description

```shell
#which ls #give location where ls command located

which firefox # location of bash
which bash # location of bash

whatis ls # short description, to know what ls doing command
whatis grep #short description, to know what is grep command

```



## who 

who 显示terminal 信息

| 参数   |  Meaning |
|:----------:|:-------------|
| -a |	打印全部 terminal 打开信息，比如 伪终端名称，打开时间. 比如打开了两个terminal, 会显示两行  |
| -d |	打印死掉的进程 |
| -m |	同who am i, 显示当前终端打开的信息 |
| -q |	打印当前所有打开的 terminal 用户数及用户名 |
| -u |	打印当前所有打开的 terminal 登录用户登录详细信息, 类似 -a |
| -r |	打印运行等级 ||


## zip / unzip

| Flag | 	说明 | 
| :---: | :--- |
| ```-r``` | 表示递归打包包含子目录的全部内容 | 
| ```-q``` | 参数表示为安静模式，即不向屏幕输出信息 | 
| ```-o``` | 表示输出文件，需在其后紧跟打包输出文件名| 
| ``` -[1-9]``` | 压缩级别 1 表示最快压缩但体积大，9 表示体积最小但耗时最久 |
| ```-e``` | 使用 ```-e``` (encryption) 参数可以创建加密压缩包： |
| ```-l``` | 解决Windows 系统与 Linux/Unix 在文本文件格式上的一些兼容问题, ```-l``` 参数将 LF 转换为 CR+LF 来达到以上目的 |

```shell
cd /home/shiyanlou
zip -r -q -o shiyanlou.zip /home/shiyanlou/Desktop
#后面使用 du 命令查看打包后文件的大小
du -h shiyanlou.zip
file shiyanlou.zip
```

设置压缩级别为 9 和 1（9 最大，1 最小），重新打包：
```shell
zip -r -9 -q -o shiyanlou_9.zip /home/shiyanlou/Desktop -x ~/*.zip #~ 表示 home directory
zip -r -1 -q -o shiyanlou_1.zip /home/shiyanlou/Desktop -x ~/*.zip
```

最后那个 ```-x``` 是为了排除我们上一次创建的 zip 文件，否则又会被打包进这一次的压缩文件中(新的压缩文件中没有上次压缩的文件)，注意：<span style="background-color:#FFFF00">这里只能使用**绝对路径**，否则不起作用</span>。

我们再用 du 命令分别查看默认压缩级别、最低、最高压缩级别及未压缩的文件的大小：

- ```h```， --human-readable（顾名思义，你可以试试不加的情况）
- ```d```， --max-depth（所查看文件的深度）

```shell
$ du -h -d 0 *.zip ~ | sort #同时显示当前文件下所有zip 和 home directory 文件大小
```

**创建加密 zip 包**

```shell
zip -r -e -o shiyanlou_encryption.zip /home/shiyanlou/Desktop
```

注意： 关于 zip 命令，因为 Windows 系统与 Linux/Unix 在文本文件格式上的一些兼容问题，比如换行符（为不可见字符），在 Windows 为 CR+LF（Carriage-Return+Line-Feed：回车加换行），而在 Linux/Unix 上为 LF（换行），所以如果在不加处理的情况下，在 Linux 上编辑的文本，在 Windows 系统上打开可能看起来是没有换行的。如果你想让你在 Linux 创建的 zip 压缩文件在 Windows 上解压后没有任何问题，那么你还需要对命令做一些修改：

```
$ zip -r -l -o shiyanlou.zip /home/shiyanlou/Desktop
```

需要加上 -l 参数将 LF 转换为 CR+LF 来达到以上目的。


**unzip**

| Flag | 	说明 | 
| :---: | :--- |
| ```-q``` | 参数表示为安静模式，即不向屏幕输出信息 | 
| ```-l``` | 不想解压只想查看压缩包的内容你可以使用 ```-l``` 参数 | 
| ```-d``` | 指定路径 |

```shell
unzip shiyanlou.zip
#使用安静模式，将文件解压到指定目录：
unzip -q shiyanlou.zip -d ziptest
```
上述指定目录不存在，将会自动创建。

```shell
#如果你不想解压只想查看压缩包的内容你可以使用 -l 参数：
unzip -l shiyanlou.zip
```

注意： 使用 unzip 解压文件时我们同样应该注意兼容问题，不过这里我们关心的不再是上面的问题，而是中文编码的问题，通常 Windows 系统上面创建的压缩文件，如果有有包含中文的文档或以中文作为文件名的文件时默认会采用 GBK 或其它编码，而 Linux 上面默认使用的是 UTF-8 编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题（有时候它会自动帮你处理），为了解决这个问题，我们可以在解压时指定编码类型。

使用 ```-O（英文字母，大写 o```）参数指定编码类型：
```shell
unzip -O GBK 中文压缩文件.zip
```


## Run Multiple Terminal(; && || )



```shell

#; sequence matter 
ls; pwd #先run ls 再显示pwd
date; cal ; pwd #先run date, 再run cal, 再pwd

#如果有中间一个command 是错的
date; CAL;  pwd #date, pwd run 成功了, CAL 会显示command not found 

#&& sequence matter, 顺序一个接一个
ls && pwd && date && cal #先run ls, 再pwd, 再date, 再cal

ls && CAL && pwd #先run ls, CAL error, not run pwd

ls || pwd #如果第一个command 成功了，不会run 第二个command

CAL || pwd #CAL command failure, pwd 会被run

```

<span style="background-color: #FFFF00">Difference</span>: ; run every command regardless success/failure of each command. && 如果中间的failure, does not go to the next command




## FUN

《黑客帝国》电影里满屏幕代码的“数字雨”，在 Linux 里面你也可以轻松实现这样的效果，你只需要一个命令 cmatrix 。

```shell
sudo apt-get update; sudo apt-get install cmatrix
```

装好之后先不要急着执行，为了看到更好的效果，我们需要先修改终端的主题配色，在终端上面的【选项】中修改，修改为黑底绿字：

还可以改变代码的颜色：

```shell
cmatrix -C red
```

火炉
```shell
sudo apt-get install libaa-bin 
aafire
```

