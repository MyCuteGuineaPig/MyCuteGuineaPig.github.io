---
layout:     post
title:      "cmake - 笔记"
subtitle:   "Cmake learning note "
date:       2019-05-30 20:00:00
author:     "Becks"
header-img: "img/post-bg2.jpg"
catalog:    true
tags:
    - C++
    - Cmake
    - 学习笔记
---


```shell

cmake_minimum_required(VERSION 3.14.5) #VERSION  必须大写，否则报错
project(MyProject VERSION 1.0)

add_executable(cmake-good main.cpp) #make exectuable, 生成exe会叫cmake-good

```

```shell

#build CMakeFiles
cmake .  #引用source directory
 
#build exe
cmake --build . #引用already configured binary directory, 必须要有cache的文件, cache文件会由cmake . 生成 
# windows 环境中 会把exe 建立在Debug folder 中, 因为默认是DEBUG

cmake --build . --config Debug 
#等同于上边的command,
#cmake will run underlying msbuild tool to build VS Solution

```


## Linked a library


比如下面C++ header 和cpp 文件

```c++

//---------------hello.h 

namespace Hello{
    void sayhello();
}

//---------------hello.cpp 

#include "hello.h"

#include <iostream>

void hello::say_hello(){
    coud << " hi "<<endl;
}


//---------------main.cpp 

#include <iostream>

#include "hello.h"

using namespace std;

int main(){
    hello::say_hello();
}

```


如果这么按照上面的方式executable 那么写cmake, run exe时候会有link error， 解决方法是加上add_library 和 target_link_libraries, 


**<span style="background-color:#FFFF00">add_library()</span>** 第一个参数是link library名字(可以随意建立) + library 模式(static or shared), 第二个参数 是头文件，第三个参数 cpp文件

**<span style="background-color:#FFFF00">target_link_libraries()</span>** 第一个参数是executable, link到谁， 第二个参数是link interface mode, 第三个参数 被link的library

<span style="color:red">加上add_library 和 target_link_libraries run cmake --build . (on windows) or make (on linux), 不用run cmake . </span>, 因为会automatically detect 如果CmakeLists.txt 被更改了 (out of date), 如果更改了，会自动run cmake .

```shell
cmake_minimum_required(VERSION 3.14.5) #VERSION  必须大写，否则报错
project(MyProject VERSION 1.0)

add_library( 
    say-hello  #创建一个link library
    hello.h
    hello.cpp
)

add_executable(cmake-good main.cpp) #make exectuable, 生成exe会叫cmake-good

target_link_libraries(cmake-good PRIVATE say-hello) #把建立的library 和main link到一起
#第一个argument是executable, link到谁， 第二个argument是link interface mode, 第三个argument 被link的library


```

再run Debug\cmake-good.exe 会打印出我们想要的结果

注: we don't specify the type of library, but it build a static library(default), 如果我们specified SHARED, 如下面，就会建立一个shared linked library

```shell

add_library( 
    say-hello SHARED  #创建一个shared linked library
    hello.h
    hello.cpp
)

add_library( 
    say-hello STATIC  #创建一个static linked library
    hello.h
    hello.cpp
)



```

在linux 上，ldd 可以看linker dependency of lib,<span style="background-color:#FFFF00"> 如果是shared library, ldd 可以看见libsay-hello (我们上面创建的lib)的dependency, 如果是static, ldd就看不见这个library </span>

```shell
ldd cmake-good

```

我们可以更改add_library static library的选项 成shared, <span style="background-color: #FFFF00">通过cmake -D BUILD_SHARED_LIBS=TRUE . , 即使我们不声明add_library 成shared, 也会生成shared library </span>

```shell

cmake -D BUILD_SHARED_LIBS=TRUE .

```



## CMAKE in Visual Studio

ZERO-CHECK： check if CMAKE configuration file is out of date and needs to regenerate VS studio project. All projects will depend on ZERO CHECK project. You can aslo build ZERO CHECK within Visual Studio itself to regenerate the configuration within visual studio without building any projects

当compile project, can run as executable by right-click set as start project then start debugger.  

cat: 1. Display Txt 2. combine Txt file 3. Create new Txt file

当在visual studio 里面更改Debug 到release， 不用重新run cmake 直接build project即可, 




## mkdir

```shell
mkdir image #生成image directory
mkdir image/pic #生成pic directory inside image directory
mkdir names/mark #当names 不在当前文件夹下，显示error, No such file or directory
mkdir -p names/mark (mkdir --parents names/mark ) #-p means -- parents
mkdir -p names/{john,tom,bob}  #creat several directory inside current directory, 建立三个文件夹,john, tom,bob
# {john,tom,bob} 不能有空格，否则建立的文件夹是 {john,


```



![](/img/post/git-note/gitpic1.png)
