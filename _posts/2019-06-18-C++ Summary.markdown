---
layout:     post
title:      "C++ Primer - 笔记"
subtitle:   "C++ Primer Summary "
date:       2019-06-18 20:00:00
author:     "Becks"
header-img: "img/post-bg2.jpg"
catalog:    true
tags:
    - Batch
    - 学习笔记
---


![](/img/post/C++/type.PNG)

- function return reference 可以用non-reference 去接, non-reference 接的话借的是copy 
- namespace 中function 不是在class 但是声明了 static 是  give **internal linkage**, meaning that it is only accessible within the translation unit that contains the definition. Without static, it has external linkage, and is accessible in any translation unit. So you'd use static (or, alternatively, an unnamed namespace) when writing a function that's only intended for use within this unit; the internal linkage means that other units can define different functions with the same name without causing naming conflicts.

**iteral type**: (int, int pointer, int reference, double, enum, char, char array char pointer) scalar type, reference type, an array of literal type; <span style="color:red">注:string 不是literal type</span>

A class is a literal type
- has a trivial destructor(自己没有定义destructor 并且 non-static member object 也没有定义destructor )
- every constructor call and any non-static data member that has brace- or equal- initializers is a constant expression, ```int i = 4; int j {5};```
- is an aggregate type, or has at least one constexpr constructor or constructor template that is not a copy or move constructor, and
- has all non-static data members and base classes of literal types

```c++
struct B { ~B() {} };//not literal type

```
```c++
class X {
  int i = 4;
  int j {5};
public:
  X(int a) : i{a} {}  //initializes with a and 5
  
  X() = default;      //initializes with 4 and 5
  
};
```

## 2. Variable and Basic Types

<span style="background-color: #FFFF00">**Initialization is not assignment**</span>. Initialization happens when a variable is given a value *when it is created*.(创建变量时 赋予它一个初始值). **Assignment** obliterates an object's current value and replaces that value with a new one (
<span style="background-color: #FFFF00">把对象当前值擦除，用一个新值代替</span>)

#### (a). Initialization, Definition, Declaration, Scope
 
**(1). List Initialization**

```c++
//下面四种初始化都正确

int units_sold = 0;
int units_sold = {0};
int units_sold {0};
int units_sold(0);
```

<span style="background-color: #FFFF00">List Initialization will throw error if the initializer might lead to the loss of information. (编译器将会报错，如果使用列表初始化且初始值存在丢失信息的风险).</span> 如果不用List Initialization 就不会, 会implicit convert


```c++
long double id = 3.1415026536;
int a{ld}, b = {ld}; //error: 存在丢失信息风险

int c(ld), d = ld; // 转化执行，但是丢失了部分值 (truncated)

```

**(2). Default Initialization**

Most classess let us define objects without <span style="color: red">explict initializers</span>. Such classes supply an appropriate default value. e.g. std:string empty; empty implicitly initialized to the empty string. 

Note: Uninitialized objects of built-in type defined inside a function body have undefined value. Objects of class type that we do not explicitly initialize have a value that is defined by the class.

**(3). Variable Declarations and Definitions**

 - <span style="background-color: #FFFF00">**A declaration makes a name known to the program. A definition creates the associated entity.**</span>
- A variable **declaration**  <span style="background-color: #FFFF00"> specifies the type and name of a variable</span>. A variable definition is a declaration. In addition to specifying the name and type, a **definition** also <span style="background-color: #FFFF00"> allocates storage and may provide the variable with an initial value</span>. 变量声明规定了变量的类型和名字，在这一点上定义与之相同. 但除此之外, 定义还申请存储空间, 也可能会为变量赋一个初始值
- <span style="background-color: #FFFF00"> Variable must be defined exactly once but can be declared many times</span> 变量只能被定义一次，但可以被声明多次
- 如果想声明一个变量而非定义它，在变量前添加extern

```c++
extern int i; //声明i而非定义i

int j; //声明并定义j
```

任何包含了显示初始化的声明既是定义. 给extern 表含的变量一个初始值，抵消了extern的作用

```c++
extern int i = 5; //定义
```

**(4). Nested Scopes**

<span style="background-color: #FFFF00"> 用 :: 访问global variable (explicitly request global variable) </span>

```c++
int reused = 42;
int main(){
    cout << resused <<endl; // 42

    int reused = 0; //新建局部变量，覆盖全局变量

    cout << resused <<" global " << ::resused <<endl; // 0 , 42

}
```




#### (b). Compound Types

A **compount type** is a type that is defined in terms of another type, which is references and pointers

1. reference, pointer:
    - <span style="background-color: #FFFF00">等号两边类型(type)必须相同 </span> type modifier(&, \*) 不一定相同, <span style="background-color: #FFFF00">除了一个特殊情况 const reference</span>
         - 比如 ```double dval = 3.14;,int &refVal5 = dval;//error``` 
2. 对于const非reference 非pointer, 等号左右两边等号类型可以不同. 
3. **对于const reference 等号两边可以不同类型，compiler会做转换**  ```const double pi = 3.14; const int & i = pi;```


**Reference** At here, reference is only lvalue reference not rvalue reference

<span style="background-color: #FFFF00"> reference must be assigned at initlization, non-const reference 不能assign rvalue, must be lvalue </span>. 程序把引用和初始值绑定(bind)到一起，而不是将初始值拷给引用, 引用无法绑定到另一个对象. <span style="color: red"> **A reference is not an object**. Instead, a reference is just another name for an already existing object </span>


```c++
int val = 1024;
int &refval = val, &r = i; // correct

refval = 2; //val = 2

int &refval2; //error

int &refval3 = 10 ;//error: initializer must be an object

double dval = 3.14;
int &refVal5 = dval; // error: initializer must be an int object
```

We can define multiple references in a single definition

```c++
int i2 = 2048; // i and i2 are both ints 

int i3= 1024, &ri = i3; // i3 is an int;ri is a reference bound to i3 

int &r3 = i3, &r4 = i2; // both r3 and r4 are references
```


**Pointer**

- assign pointer <span style="color:red">需要assign 的类型和被assign 类型compatible</span>. 
- <span style="background-color:#FFFF00">**Pointer is a object whereas reference is not object**</span>
- <span style="background-color: #FFFF00">It is error to copy or try to access the value of an invalid pointer</span>. As when we use an uninitialized variable, <span style="color: red">this error is one that the compiler is unlikely to detect(编译器不会检查access invalid pointer)</span>. The result of accessing an invalid pointer is undefined. 
-  Given two valid pointers of the same type, we can compare them use<span style="background-color: #FFFF00"> the equality(==) or inequality(!=) operator, Two pointers are equal if they hold the same address (两个指针存放的地址相同) </span>
- <span style="background-color: #FFFF00">修饰符 (type modifier \*)仅仅是修饰一个variable</span>,  而非修饰整行所有变量.  Each declarator can relate its variable to the base type differently from the other declarators in the same definition.```int* p1, p2```, p1 是 int pointer, p2 是int, , 如果两个都是pointer 用```int* p1, *p2```
- deference ```*``` 返回类型是reference,所以可以用```int *p = &i; *p = 5;//change object```

```c++
double dval;
double *pd = &dval; //ok: initializer is the address of a doub;e

double *p2 = pd;//ok: initializer is a pointer to double

int *pi = pd;//error: types of pi and pd differ, 一个int,一个double

pi = &dval; //error: assigning the address of a double to a pointer to int

//上面两个error 都会compile fail


int Ival;
double *dpi = &Ival;//error: types of pi and pd differ, 一个int,一个double, 也是compile error


```

<span style="background-color:#FFFF00">& 赋值是改变等号左侧 pointer指代对象, \* 不改变指代对象，改变的是指代对象的值 </span>
```c++
int r = 1;
int *p = &r;
int *p2 = p;
    
*p2 = 10; //change pointed value, aslo change value of the object pointer points to

cout << *p <<" , "<<*p2  <<" , "<< r <<endl; //print 10 ,10, 10

int c = 5;
p = &c; //change object that pointer points to

cout << *p  <<" , "<< r <<" , "<< c<<endl;//print 5, 10 , 5

```

```c++
int i = 1024, *p = &i, &r = i;// i is an int; p is a pointer to int; r is a reference to int

int* p1, p2;//p1 is a pointer to int; p2 is an int (not pointer), 

//上面的*， 仅仅修饰了p1, 而非让所有变量的类型一样都是int pointer

int *p1, *p2; // both p1 and p2 are pointers to int
```


**void pointer**: <span style="background-color: #FFFF00">A void* pointer holds an address, but the type of the object at that address is unknown:  </span>. Generally,we use a void* pointer to deal with memory as memory, rather than using the pointer to access the object stored in that memory. 



**Pointers to Pointers**

```c++
int ival = 1024;
int *pi = &ival; // pi points to an int

int **ppi = &pi; // ppi points to a pointer to an int


cout << "The value of ival\n"
    << "direct value: " << ival << "\n" 
    << "indirect value: " << *pi << "\n"
     << "doubly indirect value: " << **ppi << endl;//print 1024, 1024, 1024

```

**References to Pointers**: A reference is not an object. Hence, we may not have a pointer to a reference. However, because a pointer is an object, we can define a reference to a pointer:


```c++

int i = 42; 
int *p; //p is a pointer to int

int *&r = p;  // r is a reference to the pointer p

//cannot write as  int &*r = p; 

//because reference(not object) don't have pointer, but pointer has reference


r = &i;// r refers to a pointer; assigning &i to r makes p point to i

*r = 0; 
// dereferencing r yields i, the object to which p points; changes i to 0


```

<span style="background-color: #FFFF00"> **离变量名最近的符号(symbol， 上面例子 &r 的符号& ) 对变量类型有最直接的影响, 因此r是一个引用;**</span>

#### (c). Const Qualifier

1. 非reference, 非 pointer,Const Initialize时候 等号两边type可以不一样, e.g. 
    - ```int a = 0; const double b = a;```
    - ```double a = 0; const int b = a;```
2. reference or pointer, Const Initialize时候 等号两边type 必须strictly 一样

**(1). Reference**

1. ```const```value 必须<span style="color:red">initialize when define</span> 
2. **Const Value-Value**: 
    - **non const -> const**  value e.g.```int val = 5; const int cst = val;```, <span style="background-color:#FFFF00"> 因为const value是通过复制生成，改变原来值，不会改变const value值</span> e.g. ```int val = 3; const int cstRef = val;val = 10;```, ```cstRef = 3``` , ```val = 10``` 
    - **const -> non const**  const (reference or without reference)  initilize non const value; ```const int & cstRef = 3; int val = cstRef```.
3. **Const Ref-Ref**:
    - **Const Ref -> Ref**  <span style="color:red">**Error**</span>  <span style="background-color:#FFFF00"> const reference 不能bind 到non-const reference，因为reference is not object </span> ```const int & ref = 3; int &i = ref; //error```,
    - **Ref -> Const Ref** ✔️ ```int val = 3; int & ref = val; const int &cstRef = ref;```
4. **Ref-Value**:
    - **Ref -> Const Value** ✔️, ```int val = 3; int & ref = val; const int cstRef = ref;```
    - **Const Value -> Ref** <span style="color:red">**Error**</span> ```const int cstRef = 3; int & ref = cstRef;```, 因为Referene 不是object, 这么做有更改Const 可能性
    - **Const Ref -> Value** ✔️, ```const int & cstRef = 3; int val = cstRef;```
    - **Value-> Const Ref** ✔️, ```int val = 3; const int & cstRef = val;```
    - **Const Ref -> Const Value** ✔️,```const int & cstRef = 5;const int val = cstRef;```
    - **Const Value -> Const Ref** ✔️,```const int val = 5;const int & cstRef = val;```
5. ```const reference```, 如果type 不匹配 or 用rvalue expression, 会生成一个**temporary object**, 这样如果改了原来的值, ```const reference```不会改 (因为```const reference```连得是temporary object) e.g. ```double val = 3.14; const int & cstRef = val; ```
    - 如果不是const reference, ```double val = 3.14; int & cstRef = val;  ``` 因为没有**中间值**生成, 改变```val```的值,有改变const reference 风险, <span style="color:red">**Error**</span>
6. ```const reference```生成后 <span style="background-color:#FFFF00">不能直接更改，但可能会被间接更改(没有temporary object生成)</span> ```int val = 3;const int & cstRef = val;val = 10;``` , ```val = cstRef = 10```


const value 必须initialize when define 

```c++
const int i = get_size(); // ok: initialized at run time 

const int j = 42; // ok: initialized at compile time 

const int k; // error: k is uninitialized const

```
 
const value 可以生成non const value (反之也可以), 但是const reference 不可以生成 nonconst reference (nonconst reference 可以生成const reference)
```c++
int val = 42;
const int cst = val; // ok: nonconst val -> const val

const int &  cstRef = val;
int jVal= cst; // ok:const val -> nonconst val

int & jRef = cstRef; //error const Ref -> non const Ref

int &jVal2 = val;
const int & cstRef2 = jVal2; //ok: non const Ref -> const Ref

```

```const int bufSize = 512;``` <span style="color: red"> the compiler will usually replace uses of the variable with its corresponding value during compilation.</span> That is, the compiler will generate code using the value 512 in the places that our code uses bufSize. Compiler会找到代码中所有用到bufSize的地方，然后用512代替。


```c++
//不能用非const reference 指向const object

const int ci = 1024;
int &r2 = ci;// error: non const reference to a const object

int i = 42;
```

**One exception for const references**: initailize const from any expression that can be converted to the type of the reference. <span style="background-color: #FFFF00">当initilize const reference, 我们可以用任意表达式. </span>

```c++
int i = 42;
const int &r1 = i; // we can bind a const int& to a plain int object 

const int &r2 = 42; // ok: r1 is a reference to const

const int &r3 = r1 * 2; // ok: r3 is a reference to const

int &r4 = r1 * 2; // error: r4 is a plain, non const reference

```
to understand this exception in initialization rules:

```c++
double dval = 3.14;
const int &ri = dval; //okay,

dval = 6.28;
cout<<ri << ","<<dval<<endl; //print 3, 6.14


int Ival = 5;
const int & ri2 = Ival; //okay,
const int & ri3 = Ival*2; //okay,
    
Ival = 30;
cout<<ri2<<" ,"<<ri3 << ","<<Ival<<endl; //print 30, 10, 30

```

上面例子中.To sure object to which ```ri``` is bound is an int, compiler transforms the code into something like (但不适用```ri2```, 因为initialize ```ri2```时, 没有生成temporary object). In this case, ```ri``` is bound to a **temporary object**. A temporary object is an unnamed object created by the compiler when it needs a place to store a result from evaluating an expression. 

```c++
const int temp = dval;//create a temporary const int from the double

const int &ri =temp;//bind ri to that temporary

const int temp2 = Ival*2;//create a temporary const int from the int

const int &ri3 =temp2;//bind ri to that temporary

```


**A Reference to const May Refer to an Object That Is Not const**: 当```const reference```initialized时, 并没有generate **temporary object**, 可能会被间接更改```const refernce```的value

```c++
int i = 60;
int&r1=i; //r1 boundto i

const int &r2 = i; //r2 also bound to i; but cannot be used to change i


r1=0; // r1 is not const; i is now 0
//r2 = 0;//error: r2 is a reference to const

cout<<i<< ", "<<r1<<", "<<r2<<endl; //print 0, 0 , 0

```

**(2). Pointer and const**

1. Level Const
   - **low-level const**(object is const): const <span style="background-color: #FFFF00">在pointer 左面</span>表data is const, cannot change underlying data value. but can point to different underlying. <br/>
   - **top-level const**(pointer is const): const <span style="background-color: #FFFF00">在pointer 右面有pointer在时候表示 pointer is const (**a const pointer**), 如果没有pointer 在表示数据const (```const int a = 0```</span>, 不能改变指向对象，但可以改变the value of underlying object)
2. <span style="background-color: #FFFF00">The distinction between **top-level** and **low-level** matters when we copy an object</span>. When we copy an object, **top-level consts can be ignored:** e.g. ```const * const int = const * int```
    -  <span style="background-color: #FFFF00">对于pointer之间的copy, 如果忽略Low Level const</span>, <span style="color:red">**Error**</span> 
       - **Pointer of Const -> Pointer**:  <span style="color:red">**Error**</span> e.g. ```int val = 42; const int * p3Low = val;int * p3 = p3Low;//error```
       - **Const Value -> Pointer**  <span style="color:red">**Error**</span> e.g. ```const double cstVal = 3.14; double *ptr = &cstVal; //error```
       - **Const Pointer -> Pointer**:✔️ 因为可以忽略top-level constant e.g. ```int i = 0; int * const p = &i; int *a = p;```
    - 对于value 到 const pointer 的copy, 可以忽略low-level const
       -  **Value -> Const Pointer** ✔️  e.g. ```int val = 1; int const * const pLowTop = & val;```
       -  **Const Pointer -> Value** ✔️ ```int j = 0; const int * cstPtr = & j; int val = *cstPtr;```
       -  **Pointer -> Const Pointer** ✔️ ```int i = 0, *a = & i; const int * const p = a;```
3.  The types of a pointer and the object to which it points must match(等号左右两边类型必须match). 


```c++
int i = 0;
int *const p1Top = &i; // const is top-level; we can't change the value of p1Top

const int ci = 42; //  const is top-level; we cannot change ci

const int *p2Low = &ci; //  const is low-level; we can change p2Low

const int *const p3LowTop = p2; // right-most const is top-level, left-most is not

const int &r = ci; // const in reference types is always low-level


//top level constant can be ignored

i = ci; // ok: copying the value of ci; top-level const in ci is ignored 

p2Low = p3LowTop; // ok: pointed-to type matches; top-level const in p3LowTop is ignored


```

<span style="background-color: #FFFF00">On the other hand, low-level const is never ignored.(lower-level 从不会被忽略)</span>.  When we copy an object, both objects must have the same low-level const qualification or there must be a conversion between the types of the two objects(拷贝 输出对象必须具有相同的底层const 资格). In general, we can convert a nonconst to const but not the other way round:

```c++
int *p = p3LowTop; // error: p3LowTop has a low-level const but p doesn't

p2Low = p3LowTop; // ok: p2Low has the same low-level const qualification as p3LowTop

p2Low = &i; // ok: we can convert int* to const int*

int &r = ci; // error: can't bind an ordinary int& to a const int object 

const int &r2 = i; // ok: can bind const int& to plain int

```

The first exception is that we can use a pointer to const to point to a nonconst object: 可以用const pointer指向non-const object

```c++
const double cstVal = 3.14; // pi is const; its value may not be changed

double *ptr = &cstVal; // error: ptr is a plain pointer

const double *cptrLow = &cstVal; // ok: cptr may point to a double that is 

*cptrLow = 42; // error: cannot assign value to *cptr

double dval = 3.14; // dval is a double; its value can be changed
 
cptrLow = &dval; // ok: but can't change dval through cptr

```

```c++
double pi = 3.14159;
const double *const pip = &pi; 
// pip is a const pointer (在pointer右边的const) to a const object

```

#### (d). Constexpr

A **constant expression**: value cannot change and can be evaluated at compile time. A **literal** is a constant expression. By declaring **constexpr**, we can ask compiler to verify that a variable is a constant expression.  

Const 的缺点, 有时候我们需要**constant expression**, 但用**const**, 生成却不是**constant expression**. 比如, 下面例子even though```sz``` is a ```const```, the value of its initializer is not known until <span style="color:red">run time</span>
```c++
const int limit = 20;
//limit is a constant expression

const int sz = get_size(); 
//sz is not a constant expression

constexpr int sz2 = get_size(); 
//只有当get_size() is a constexpr function, sz2才是constexpr function

```

The type we can use in a **constexpr** declaration are known as **literal types**.
- <span style="background-color: #FFFF00"> arithmetic, reference, pointer types are **literal types**</span>, 
- <span style="background-color: #FFFF00"> 自己定义的class, **string** types 不是**literal types**, 不能用于define varaibles as **constexpr**</span>. varaibles defined inside a function 因为没有fixed address, 不能用**constexpr**,
- The **address** of an object defined  <span style="color:red">outside</span> of any function is **constant expression**, and **some objects have fixed address** so may used to initialzie a **constexpr** pointer.

- **Pointers and constexpr**

```c++
const int * p = nullptr; 
//p is a pointer to a const int (low level)

constexpr int * q = nullptr
//q is a const pointer to int (top level)

```
p and q are quite different. The difference is ```constexpr``` imposes a ```top-level const``` on pointer

```c++
constexpr int * pTop = nullptr; 
//pTop is a constant pointer to int that is null

const int tempInt = 10;
pTop = & tempInt; //Error, cannot assign const int to int * const


int j = 0;
constexpr int i = 42; // i is const int

constexpr const int * pLowTop = &i; 
// pLowTop is const pointer to the const int i

constexpr int * p1Top = & j
//p1Top is a const pointer to the int j

constexpr int * pTop2 = &i; 
// error, fix it is const int * pLow = & i

```

#### (e). Type Aliases

**Type Alias** is a name that is a synonym for another type 

1. **typedef**: ```typedef double wages```, typedef can also include type modifiers (such as reference, pointer) that define compound types 
2. **using**: ```using SI = Sales_item;```

**Pointers, Const, and Type Aliases**

```c++
typedef char *pstring;
const pstring cstr = 0; 
//cstr is a constant pointer to char

//是pointer const， 而不是数据类型data type是const 

const pstring* ps; //ps is a pointer to a constant pointer to char

```

```const pstring```(不等于 ```const char * ```) is constant pointer to char, not a pointer to ```const char```, <span style="color:red">如果直接replace the alias with its correspoinding type 是错误的, **Error**</span>, 如果想要pointer to ```const char```, 需要重新定义```typedef const char * pstring```


#### (f). Auto 

- **auto** tells the compiler to deduce the type from the initializer. By implication, a variable that uses **auto** as its type specifier <span style="background-color: #FFFF00">must have an initializer</span>.
- **auto** can define multiple variables in single line, 但是initializers for all the variables in the declaration must <span style="background-color: #FFFF00">have types that are consistent</span>
- **auto** is not always exactly the same as initializer types. 当用auto时候，<span style="background-color: #FFFF00">top level const通常会被忽略, low-level const 会被kept</span>, <span style="color:red"> 用```auto``` deduced ```int&``` is int, deduce ```const int&```是```int&```</span> 
- 用```auto &``` or ```auto*``` to auto-deduced type, <span style="background-color: #FFFF00">会keep top level, low-level const</span>
- 不能用**auto** to deduce the type from a list of initializer ```auto a = {1,2,3}; //error```
- <span style="background-color: #FFFF00">用```auto``` deduced array 是pointer type</span>

可以定义多个variables in single line, 但是需要都是一个类型(type)的
```c++
auto i = 0, *p = &i;
//okay i is int and p is pointer to int

auto sz = 0, pi = 3.14; 
//error: inconsistent type for sz and pi

```

忽略top-level const and keep lower-level const 
```c++
int i = 0, &ref = i;
auto a = ref; // a is an int


const int cval = i, &cstRef = cval;
auto b = cval; //b is an int (top-level const dropped)

auto c = cstRef; //c is an int& (cr is an alias for cval whose top-level const dropped)

auto d = & i; //d is an int*

auto e = &cval; 
//e is const int * (& of a const is low-level const)

```

auto + reference
```c++
auto & g = cval; // g is a const int & 

auto & h = 42; //error, can't bind a plain reference to a literal

const auto & j = 42; //const reference

```

Deduced 的type 必须consistent 
```c++
auto k = cval, &l = i; // k is int, l is int& 

auto & m = cval, *p = & cval;
//m is const int&, *p 是  const int * (a pointer to const int)

auto &n = i, *p2 = & cval;
//error, n is int&, p2 is const int * (not int*)

```

#### (g). Decltype 

- **decltype**: compiler analyzes the expression to determine its <span style="background-color: #FFFF00">type</span> but does <span style="background-color: #FFFF00">not evaulate the expression </span>
- <span style="color:red">**decltype** array 是array type, 而不是pointer type</span>
- handles **top-level const** subtly different from **auto**
    - **variables**: <span style="background-color: #FFFF00">include **top-level const** and reference</span>
    - **expression**: we can get the type that expression yields. <span style="background-color: #FFFF00">注:Dereference operator(\*) yields type as reference</span>
    - **function**, ```decltype(functionName)``` 返回的是function type, not a pointer to function type.
    - **decltype** and **auto** difference: deduction done by **decltype** depends on the form of its expression. 
        - <span style="background-color: #FFFF00">切记```decltype((variable))```结果永远是引用，```decltype(variable)``` 只有当variable 本身是引用时, 结果才是引用</span>

compiler 不会called ```f```, 但是uses the type that such a call would return as type of ```sum```. 

```c++
decltype(f()) sum = x; //sum has whatever type f returns 

```

use decltype for variable, returns type including **top-level const**

```c++
const int cval = 0, & cRef = cval;
decltype(cval) x = 0; //x is const int

decltype(cRef) y = x; //y is const int& 

decltype(cRef) z;//error: z is const int& which must be initalized

```

use decltype for expression. ```decltype(r)``` is a reference type. but ```r+0``` is an expression that yieds a **nonreference type**. **Dereference operator** is an example of an expression for ```decltype``` returns a **reference**. When we deference a pointer, we get the object to which the pointer points  ```decltype(*p)``` is ```int&``` not ```int```.

```c++
int i = 42, *ptr = & i, &ref = i;
decltype(r + 0) b; //addition yields an int, b is int (uninitialized)

decltype(*p) c; //error: c is int& and must be initialized

```

当我们apply ```decltype``` wrap the variable's name in one ore more parentheses, compiler will evaluate the operand as an expression. A variable is an expression that can be the left-hand side of an assignment. As a result, ```decltype``` on such an expression yields a reference.


```c++
decltype((i)) d; //error: d is int& and must be initialized

decltype(i) e;//ok: e is an int (uninitialized)

```

<br/> <br/> <br/>

## 3. Strings, Vectors, and Arrays

很多需要dynamic memory can use a vector or a string to manage the necessary storage. <span style="background-color: #FFFF00">vectors and strings avoid the complexities involved in allocating and deallocating memory.</span>

#### (a). Namespace using Declarations

- ```std::cin``` use the **scope operator(::)** says want to use the name ```cin``` from the namespace ```std```
- ```using namespace::name``` : A **using declaration** let us use a name from a namespace without qualifying the name with a ```namespace_name:: ```prefix
- <span style="background-color: #FFFF00"> Headers should not not include using declarations</span>. 原因: the contents of a header are copied into the including program's text. If a header has a ```using``` declaraction. 那么every program that includes that header gets that same ```using``` declaraction. As a result, program didn't intend to use the specified library name <span style="color:red">might encounter unexpected name conflicts.</span>

#### (b). String 

**(1). Initialization**

- ```string s2(s1)``` ```s2``` is a copy of ```s1``` 
- ```string s2 = s1``` 与```s2(s1)``` 作用一样
- ```string s3("value")``` ```s3``` is a copy of **string literal**， not including the null(null在const char\*的结尾处)
- ```string s3 = "value"```, 与```string s3("value")```一样, copy of **string literal**
- ```string s4(n,'c')```, initialize ```s4``` with n copies of character ```c```

用```=``` 初始化叫做**copy initialization**, 忽略等号的初始化 是**direct initialization**

```c++
string s5 = "hiya"; //copy initilization 

string s6("hiya"); //direct initialization

string s7(10, 'c'); //direct initialization

```
**(2). Getline**

we can use ```getline``` function instead of ```>>``` operator. This function reads the given stream up to the end of the line (*not including the newline*) to store in string.  

```c++
string line 
//read input a line at a time untile end-of-file

while(getline(cin,line)) // or use while(cin >> line)
    
    if(!line.empty())
        cout << line << endl;
```

**(3). compare**

1. 如果两个strings 长度不一样 且 每个位置char都一样, 那么较短的string ```< ``` 较长的
2. 如果有位置不一样, 那么对比那个位置两个char, 根据字母表，靠前的char的string 更小

```c++
string str = "Hello";
string phrase = "Hello World";
string slang = "Hiya";
//str < phrase, phrase < slang 

```

**(4). Adding Literals and strings**

当我们用string + character literals时,<span style = "background-color:#FFFF00"> 必须保证```+```号左右两侧至少有一个是string type </span>

```c++
string s1 = "hello";
string s4 = s1 + ", "; // ok: adding a string and a literal 

string s5 = "hello" + ", "; // error: no string operand string

s6 = s1 + ", " + "world"; // ok: each + has a string operand string

s7 = "hello" + ", " + s2; // error: can't add string literals

//因为 s7 = ("hello" + "), " + s2; ("hello" + ") no strings

```

**(5). Dealing with char in string**

- ```isalnum(c)```: true if c is a letter or digit
- ```isalpha(c)```: true if c is a letter
- ```iscntrl(c)```: true if c is a control character. <span style="color:red">A control character is a character that does not occupy a printing position on a display. 比如换行 ```\n``` </span>
- ```isdigit(c)```: true if c is a digit
- ```isgraph(c)```: true if c is not a space but is printable, <span style="color:red">A graph character是可以用来打印的character, 除了空格</span>
- ```islower(c)```, ```isupper(c)```: true if c is a lowercase/upper letter 
- ```isprint(c)```: true if c is a printable character. <span style="color:red">printable character =  space + graph character </span>
- ```ispunct(c)```: true if c is punctuation character (不是control character, a digit, a letter or a printable whitespace)
- ```isspace(c)```: true if c is whitespace(i.e. a space, tab, vertical tab, return(回车符), newline(换行符), or formfeed)
- ```isxdigit(c)```: true if c is 十六进制(hexadecimal digit)
- ```tolower(c)```, ```toupper(c)```: 如果c是大/小写字母, 变小/大写, 否则不变

**(6). Change char in string**

use for loop and reference 
```c++
string s("Hello World!!!");
for (auto &c : s) // for every char in s (note: c is a reference)

    c = toupper(c); 
cout << s << endl;
```

#### (c). Vector

We can define ```vector``` to hold objects of most any type. Becauses <span style="background-color:#FFFF00"> references are not objects, **we cannot have a vector of references** </span>

**(1). Initialization**

- ```vector<T>v1```: vector hold objects of type T and v1 is empty 
- ```vector<T>v2(v1)```: v2 has a copy of each element in v1
- ```vector<T>v2 = v1```: v2 is copy of the each element in v1
- ```vector<T>v3(n,val)```: v3 has n elements with value val
- ```vector<T>v4(n)```: v3 has n copies of a  <span style="color:red">value-initialized object</span>(e,g, int 默认是0, string 默认是空)
- ```vector<T>v5{a,,b,c...}```: v5 has as many elements as initializers;  <span style="color:red">elements are initialized by corresponding initializers</span>
- ```vector<T>v5 = {a,b,c}```; 与上面一样

 
当我们提供两个数, 比如 对于```vector<int>```, 两个数可以表示size and value, 也可以表示size 为2的两个intial values, 用花括号或者方括号会有歧义. 这时<span style="background-color:#FFFF00">  ```()```are used to construct object whereas ```{}``` is use to initialize the object,</span> . 对于```vector<string>```, ```{}```,<span style="background-color:#FFFF00"> 如果compiler 发现```{}``` 不能initialize object, 会尝试去```()```来代替```{}```initialize</span> 

```c++
vector<int>v1(10,1); //initialize vector 10 个 1

vector<int>v2{10, 1}; //initialize vector 包括 10 和 1

vector<string>v3("hi"); //error


vector<string>v4{10}; //有10个默认的string

vector<string>v5{10, "hi"}; //有10个"hi"

//v4 and v5 the initializers can't be element initializers. 

//compiler looks for other ways to initialize the object from given values

```



如果用copy constructor, 需要type consistent,
```c++
vector<int>ivec;
vector<string>svec(ivec); //error

```

要使用```size_type```, 需要注明类型
```c++
vector<int>::size_type; //正确

vector::size_type; //错误

```

**(2) Vector Grow Efficiently***

**Key Concept: Vector Grow Efficiently**: 定义空的vector 更有效. <span style="background-color:#FFFF00">It is often unnecessary- can result in poorer performance—to define a vector of a specific size (例外是all elements actually need the same value).</span> It is more **efficient** to define an <span style="background-color:#FFFF00">**empty vector and add elements**</span> as the values we need become known at run time.

for loop vector 不能改变vector的大小(size) (add, delete)


#### (d). Iterators

All of library **containers** have **iterators**. but only a few of them support the subscript operator 

- ```begin``` returns an iterator that deontes the first element. <span style="background-color:#FFFF00">如果object是const, 返回的是```const_iterator```,如果object不是const, 返回的是```iterator```</span>
- ```end``` position **one past the end** (尾元素的下一个位置), does not denote an element, 所以 <span style="color:red">it may not be incremented or deferenced</span>
- if a vector is const, 只能使用 ```const_iterator```type. Within a non const vector , we can use either ```iterator``` or ```const_iterator```
- ```>, >=, <, <=``` Iterator 比较, 如果Iterator refer的element 另一个iterator 指得element 在前面出现, 就是小于

```c++
vector<int>::iterator it;
string::iterator it2;//it can read and write

vector<int>::const_iterator it3; //it3 can read but not writer


const vector<int>cv;
auto it1 = cv.begin(); //return vector<int>::const_iterator

auto it3 = v.cbegin(); // eturn vector<int>::const_iterator

```


**(1). Dereference and Member Access**

```(*it)->member``` is a synonym as ```it->member```

```c++
(*it).empty() //dereference it and calls the member empty on object

*it.empty // error: attempts to fech the the member empty from iterator 

//but iterator has no member named empty

```
**(2). Some vector Operations Invalidate Iterators**

比如vector insert 也许会invalidate iterators: It is import to realize 当用iterator loop 不要add remove elements to the container which iterator refer. 


#### (e). Arrays

- Unlike **vector**, <span style="background-color:#FFFF00">**array** have fixed size; we cannot add elements to an array. </span>
- 因为arrays have fixed size, they sometimes offer better run-time performance for specialized applications, 但是相应也损失了一些灵活性(flexibility)
- array size是part of array's type. The dimension must be known at compile time, which is [**constant expression**](#Constexpr)
- 默认值初始化会令数组含有未定义的值 (a default-initialized array of )
- As with vector, arrays hold objects. <span style="background-color:#FFFF00">Thus **there are no array of references**, 但可以有reference to array</span>.
- <span style="background-color:#FFFF00">When define an array, we must specify a type. We cannot use **auto** to deduce the type from a list of initializers</span>

```c++
unsigned cnt = 42; //not constant expression

constexpr unsigned sz = 42; //constant expression

int arr[10]; // array of 10 ints

int *parr[sz]; // array of 42个 pointers to int 

string bad[cnt]; //error: cnt is not constant expression

string strs[get_size()]; //okay if get_size is constexpr, error otherwise

```

**(1). Initializaing Array Element**

- 如果用list initialize the elements in array, 可以忽略维度. 
    - <span style="background-color:#FFFF00">If we omit the dimension, the compiler infers dimension from the number of initializers, </span>
    - <span style="background-color:#FFFF00"> 如果specify a dimension, the number of initializers 不能超过 the specified size.</span>
- ```char arrays``` are special to have an additonal form. <span style="background-color:#FFFF00">can initialize from a string literal and string literals end with a **null character** </span>. That null character is copied into the array along with the characters in the literal. <span style="background-color:#FFFF00">用list initialization， 需要声明```\0```否则不会加上, 如果不用string literal, 会自动加上```\0``` </span>
- <span style="background-color:#FFFF00"> cannot initialize an array as copy of another array. 也不能assign one array to another </span> 有一些compiler 允许array assignment as a compiler extension. 但是最好不要用这种nonstandard方法


```c++
const unsigned sz = 3;
int ia1[sz] = {0,1,2}; //array of 3 inits with invalue 0, 1, 2

int a2[] = {0, 1, 2};  //array of 3 dimension3

int a3[5] = {0, 1, 2}; // equivalent to a[3] = {0,1,2,0,0}

string a4[3] = {"hi", "bye"}; // same as a4[] = {"hi", "bye", ""}

int a5[2] = {0,1,2}; // error: too many initializers

```

char array initialization
```c++
char a1[] = {'C', '+', '+'}; // list initialization, no null

char a2[] = {'C', '+', '+', '\0'}; // list initialization, explicit null 

char a3[] = "C++"; // null terminator added automatically

const char a4[6] = "Daniel"; // error: no space for the null!

```

不能用copy initialize, 也不能assign array to another 
```c++
int a[] = {0, 1, 2}; // array of three ints

int a2[] = a; // error: cannot initialize one array with another 

a2 = a; // error: cannot assign one array to another

```

**(2). Understanding complicated Array Declarations**

因为an array is an object, we can define both pointers and references to arrays. Define arrays that hold pointer 比较直接, defining a pointer or reference to an array 稍微复杂. <span style="color:red">简单方法是从inside括号 from outside 再从右向左度，离变量近的类型对变量有直接影响</span>

- ```int *arrayPtr[10];```,  是array, size 为10, 有10个 pointer to int
- ```int (*Parray)[10];```, 是pointer, 指向 size 为10 的 int array
- ```int (&arrRef)[10];```, 是reference, refer size 为10 的 int array
- ```int *(&arry)[10] = ptrs```, 是reference, refer size 为10的array, array hold pointer to int

```c++
int *arrayPtr[10]; //arrayPtr is an array of 10 个 pointers to int 

int &refs[10] = ...; //error: no arrays of references

int (*Parray)[10] = & arr; //Parray 是pointer points to an array of 10个 int

int (&arrRef)[10] = arr; //arrRef refers to an array of 10 个 ints

```

**(3). Access the Elements**

当我们use a variable to subscript an array, we should define variable to have type ```size_t```, it defined in the ```cstddef```header, which is the c++ version of ```stddef.h``` header from C library. The difference between array and vector subscript 是 subscript operator```[]```` used in vector 只能applies to operands of vector, 而array subscript operator 是C++ 语言自己定义的

```c++
unsigned scores[11] = {};
for(auot i: scores)
    cout<<i<<endl;
```

**(4). Pointers and Arrays**

- <span style="background-color:#FFFF00">when we use an array, compiler 通常converts the array to a pointer</span>
-  We can obtain a pointer to an array element by taking the address of that element using address-of operator(```&```); e.g. ```int nums[] = {1,2,3}; int * p = &nums[0];```
- <span style="background-color:#FFFF00">when we use an object of array type, we are really using a pointer to the first element in that array</span>, array实际上是指向第一个element的pointer, operations on pointer.
    - <span style="background-color:#FFFF00">当我们用array as an initializer, defined using auto, the deduced type is a pointer, not an array </span>
    - <span style="background-color:#FFFF00">但是用到```decltype```, 还是会deduced 出array, 不会是pointer</span>
- 可以用 pointer initialize vector ```int arr[] = {0,1,2,3,4,5}; vector<int>iv(begin(arr), end(arr)); vector<int>iv2(arr + 1, arr+4);```, ```iv2```的vector分别来自```arr[1], arr[2],arr[3]```


```c++
string nums[] = {"one", "two", "three"}; // array of strings 

string *p = &nums[0]; // p points to the first element in nums

string *p2 = nums; // equivalent to p2 = &nums[0]

```

用array as intializer for **auto**, deduced type是pointer, not array 

```c++
int ia[] = {0,1,2,3,4,5}; // ia is an array of ten ints

auto ia2(ia); //ia2 is an int* that points to the first element in oa

ia2 = 42; // error : ia2 is a pointer, can't assign an int 

auto ia3(&ia[0]); //now it's clear that ia3 has type int*

```

decltype(array) is array

```c++
decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9}; // decltype(ia)  is array not pointer

int i = 0, *p = &i;
ia3 = p; // error: can't assign an int* to array 

ia3[4] = i; // ok: assigns the value of i

```

**(5). Pointers Are Iterators**

Pointers to array elements (array) support the same operations as **iterators** on vector and string. We can use pointers to traverse the elements in an array.Array的```begin``` 和 ```end``` 返回的是pointer of object


```c++
int arr[] = {0,1,2,3,4,5};
int *p = arr; // p points to the first element in arr

++p; // p points to arr[1]

int *begin = begin(arr);//pointer to the first element in arr

int *last = end(arr); // pointer one past the last element in arr

```

**(6). Pointer Arithmetic**

- 当add an integer to a pointer(array), the result is a new pointer, the new pointer points to the element the given number ahead of (or behind ) the original pointer. 当用两个pointers 相减, 得到the distance between those pointers. The pointers must point to elements in the same array 
- <span style="background-color:#FFFF00">我们可以比较两个指针, 当这两个指针来自于同一个数组</span> ```int * b = arr, *e = arr + 5; if(s<e)...```, 如果不来自同一个数组, 不能比较, 因为比较毫无意义
- 指针运算. The result of subtracting two pointers a library type named ```ptrdiff_t```, like ```size_t```, the ```ptrdiff_t``` type is a machine-specific type and is defined in the cstddef header, 因为相间可能有negative distance, <span style="background-color:#FFFF00">```ptrdiff_t``` is a signed integral type.</span> 
- 可以用pointer +/- 整数, 再deference resulting pointer, ```int last = *(arr + 4); ``` 括号是必须的当deference from pointer arithmetic
- <span style="background-color:#FFFF00">`**we can use subscript operator on any pointer as long as thet pointer points to  an element (or one past the last element) in an array, 可以用+/- number 用作subscript**</span>
    - Array 和 vector/string subscript operators 不同是, <span style="color:red">`the library types(vector/string) force the index with **unsigned**, 但是built-in subscript operator 可以是negative value(is not an unsigned type)</span>

```c++
constexpr size_t  sz = 5;
int arr[sz] = {1,2,3,4,5};
int *ip=arr; //equivalent to int *ip = &arr[0];

int *ip2 = ip + 4;//ip2 points to arr[4], the last element in arr

int *ip3 = ip + 10;//error : arr has only 5 elements

auto n = end(arr) - begin(arr); // n is 5, the number of elements in arr

```

比较指针

```c++
int *b = arr, *e = arr + sz; 
while (b < e) {
    // use *b ++b;

}

int i = 0, sz = 42;
int *p = &i, *e = &sz;
while (p < e)
    // undefined: p and e are unrelated; comparison is meaningless! 

```

上面的也同样适用于null pointer and for pointers that point to an object that is not an array(两个指针必须指向同一个对象or 该对象下一个位置). if ```p``` is null pointer, 可以加减integral constant expression whose value is 0 to p. 我们也可以用null pointer 减去null pointer = 0

Deference
```c++
int ia[] = {0,2,4,6,8}; // array with 5 elements of type int

int last = *(ia + 4); // ok: initializes last to 8, the value of ia[4]

//括号是必须的

int last2 = *ia + 4; // = 0(ia[0]) + 4 = 4
```

subscript operator
```c++
int arr[] = {0,2,4,6,8};
int *p = arr+2; //p points to the third element in arr

int j = p[1]; // p[1] = *(p+1); = arr[3] = 6;

int k = p[-2]; // p[1] = *(p-2); = arr[0] = 0;
```
 
**(7). C-Style Character Strings**

- C-style strings are not a type, 而是convention to use character strings. Strings that follow this convention 储存在character arrays and **null terminated \0** 
- C library string.h provides a set of functions 在C++中 functions 被定义在 cstring header
    - ```strlen(p)```: 返回p的长度, <span style="color:red">not counting the null</span>
    - ```strcmp(p1,p2)```: compares p1 and p2 for equality. Returns 0 if p1 == p2, a positive value if p1 > p2, a negative value if p1 < p2
    - ```strcat(p1,p1)``` : Appends p2 to p1. Returns p1. <span style="color:red">p1必须large enough to hold result </span>
    - ```strcpy(p1,p2)``` : copies p2 into p1. Returns p1. <span style="color:red">p1必须large enough to hold result</span>


用strlen 必须有```\0``` terminate. 如果没有 null terminated, the result is undefined. The most likely effect of  this is that ```strlen``` will keep looking through the memory taht follows ```ca``` until it encounter a null character
```c++
char ca[] = {'C', '+', '+'}; // not null terminated

cout << strlen(ca) << endl; // disaster: ca isn't null terminated

```

Compare string: when we use an array, we really use a pointer to the first element in the array. 下面例子因为pointer do not address the same object, so the comparison is undefined. 我们可以用 ```strcp```对比const char array的content
```c++
const char ca1[] = "A string example";
const char ca2[] = "A different string";
if (ca1 < ca2) // undefined: compares two unrelated addresses


if (strcmp(ca1, ca2) < 0) // same effect as string comparison s1 < s2

```

concat： 对于string, 可以直接用加号, 但是<span style="color:red">doing the same with two arrays would be an error.</span>. 因为expression tries to add two pointers which is illegal and meaningless.  如果largeStr不足够大, 很有可能引发error.如果我们更改largeStr, 又要重新检查它的size. Programs with suck ecode are **error-prone**
```c++
//对于string, 可以直接
string largeStr = s1 + " " + s2;

// disastrous if we miscalculated the size of largeStr
strcpy(largeStr, ca1); // copies ca1 into largeStr

strcat(largeStr, " ");  // adds a space at the end of largeStr

strcat(largeStr, ca2); // concatenates ca2 onto largeStr

```

**(8). Mixing Library strings and C-Style Strings**

- initialize string from a string literal  ```string s("Hello World")```
- **string -> const char pointer: c_str()** returns a a pointer to the beginning of a null-terminated character array that holds the same data in string```const char *str = s.c_str()```. It is not guaranteed to be valid indefinitely.  任何s的subsequent use 也许改变 s value 从而invalidate this array. <span style="background-color:#FFFF00"> 所以最好是先copy string 再call c_str(), 或者call c_str() copy 一份</span>


```c++
string s = "abc";
const char* p = s.c_str();s
s = "xyz";
cout<<p[1]<<endl; //print y

```


#### (f). Multidimensional Arrays

严格讲, no multidimensional arrays in C++, 实际上是refered to arrays of arrays. 

**(1).Initialization**
- initialize all elements to 0 ```int arr[10][20][30] = {0}; ``` 只能初始化0，不能初始化别的数
- initialize whole array ```int ia[2][2] = {\{0, 1},  {2,3}};``` or ```int ia[2][2] = { 0,1,2,3};```
- initialize 第一列的数 ```int ia[3][4] = {\{0}, {4}, {8}};```, 只有```ia[0][0] = 0```, ```ia[1][0] = 4```, ```ia[2][0] = 8```, 其他数都是0.
- initialize 第一行的数 ```int ix[3][4] = {0,3,6,9};``` 只初始化第一行，剩下都是0



```c++
int ia[3][4];

// array of size 10; each element is a 20-element array whose elements are arrays of 30 ints

int arr[10][20][30] = {0}; //initialize all elements to 0

int ia[3][4] = { {0, 1, 2, 3},  // three elements; each element is an array of size 4 

    {4, 5, 6, 7},   {8, 9, 10, 11} };
//The nested braces are optional , 等于下面的

int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};

// explicitly initialize only element 0 in each row, 只初始化每行第一个元素，剩下是0

int ia[3][4] = { \{ 0 }, { 4 }, { 8 } };

// explicitly initialize row 0; the remaining elements are value initialized

int ix[3][4] = {0, 3, 6, 9}; 

int (&row)[4] = ia[1]; // binds row to the second 4-element array in ia

```

**(2). loop through array**

注意外层for loop, 我们用了reference, 因为我们避免 normal array to pointer conversion.因为<span style="background-color:#FFFF00"> auto deduced array type是pointer(指向该数组首元素的指针)</span>, 比如下面最后的例子不用reference, deduced to pointer, 无法compiled 

```c++
size_t cnt = 0;
for (auto &row : ia) // for every element in the outer array

    for (auto &col : row) { // for every element in the inner array 
           ++cnt; 
    }

for (const auto &row : ia) // for every element in the outer array

     for (auto col : row) // for every element in the inner array

        cout << col << endl;

//上面的array 如果不用reference, auto deduced type是pointer 

for (auto row : ia) //

     for (auto col : row) // 

        cout << col << endl;
```


**(3). Pointers and Multidimensional Arrays**

- 当程序使用多维数组名字时, <span style="background-color:#FFFF00">会自动将其转化成a pointer to the first element in the array</span>
- when you define a pointer to a multidimensional array, remember that a multidimensional array is a an array of arrays
- iterate 时候可以用auto 去deduced array type, deduced 的是一个pointer to 最外层的指针

```c++
int ia[3][4]; //有三行, 每行有4个

int (*p)[4] = ia; //p is a pointer 指向array of 4 ints 

//上面（）不能省去, int *p[4], 是array of size 4, hold int pointer

//ia指向的是第一行的array (size of 4)

p = &ia[2]; //p points to the last element in ia


//iterate
for(auto p = ia; p != ia + 3; ++p){
    //q points to the first element of an array of 4 ints, q points to an int

    //use auto to deduced array is pointer

    for (auto q = *p; q != *p+4; ++q)
        cout << * q << " ";
    cout<<endl;
}

for(auto p = begin(ia); p != end(ia); ++p){
    //q points to the first element of an array of 4 ints, q points to an int

    //use auto to deduced array is pointer

    for (auto q = begin(*p); q != end(p); ++q)
        cout << * q << " ";
    cout<<endl;
}

```

**(4). Type Aliases Simplify**

- ```using int_array = int[4];``` 
- ```typedef int int_array[4];```


```c++
typedef int int_array[4];
for(int_array * p = ia; p!= ia + 3; ++p)
    for(int * q = *p; q!=*p + 4; ++q)
        oout << *q <<endl;
```

<br/>  <br/>  <br/>

## 4. Expressions


**Overloading Operators**: the type of operands(运算对象的类型) and the result 取决于 how the opeartor is defined. 但是the number of operands and ther precedence(优先级) and the associativity (结合律) of the operator cannot be changed (运算对象个数, 优先级, 结合律不能改变)

#### (a). lvalue / rvalue 

- When use an object as **rvalue**, <span style="background-color:#FFFF00"> We use an object value(**its contents**)</span>. 当we use an object as **lvalue**,  <span style="background-color:#FFFF00">we use the object's identity (**its location in memory**). </span>
- **lvalue expression** yields an object or function. However, some lvalues such as ```const``` objects may not be left-hand operand of an assignment  
- We can use lvalue when rvalue is required, but we cannot use rvalue when an lvalue is required ( <span style="background-color:#FFFF00">在需要rvalue时, 可以用lvalue替代; 但是当一个lvalue使用, 不能用rvalue来替代</span>). When we use lvalue in place of an rvalue, the object's contents(its value) are used 
- 具体使用: 
  - Assignment 等号左面需要(nonconst) lvalue as its left-hand operand and yields its left-hand operand as lvalue 
  - <span style="color:red">The address-of operator(&) requires an lvalue operand (运算对象), and returns a pointer to its operand as rvalue</span>
  - Built-in dereference and subscript operators(vector, string), iterator dereference all yield lvalue 
  - Built-in 和 iterator 的 increment, decrement operators 也需要lvalue as operands
    - <span style="background-color:#FFFF00">prefix operators (```++i```) return the object itself as **lvalue**, postfix```i++``` return a copy of the object's original value as **rvalue**</span>
    - <span style="background-color:#FFFF00">用```decltype```时候, 当我们apply ```decltype```时候, 假如```p```是 ```int*```, deference yields a lvalue```decltype(*p)``` is ```int&```. Address-of operator yields an rvalue, ```decltype(&p)``` is ```int**```

#### (b). Precedence and Associativity 

when Precedence and associativity matter

```c++
int ia[] = {0, 2,4,6,8}; 

int last = *(ia + 4); //6 + 4 = 10

last = *ia + 4; //0 + 4 = 4

```

- The precedence of postfix / prefix increment 高于deference 
    - ```*pbeg++``` is equivalent to ```*(pbeg++)```, ```pbeg++``` increment ```pbeg``` and return a copy of previous value as rvalue 
    - ```*++pbeg``` is equivalent to ```*(++pbeg)``` increment value and return as **lvalue** and dereference
- dereference has a lower precedence than dot,
    -   ```(*p).size()```如果我们忽略了括号, ```*p.size()``` error 因为pointer doesn't have member size. ```p->size()```<span style="background-color:#FFFF00"> yields an **lvalue**. The dot operator yields an lvalue if the object from which the member(成员所属对象) is fetched is an lvalue; otherwise the result is an rvalue. </span>
- The conditional operator has fairly low precedence (比较对象优先级低). When we embed a conditional expression in a larger expression, 通常需要parathesize 
- Assignment has low precedence(优先级很低) compared to conditional operator, 所以想要先赋值, 用括号
- Precedences specifies how the operands are grouped 但是 同一个expression <span style="background-color:#FFFF00">say nothing about order of operands evaluated.</span>  比如: ```int i = f1() * f2(); ``` 我们知道```f1``` and ```f2``` must be called before 乘法. 但是no way of knowing whether ```f1``` 先执行还是 ```f2``` 先执行
    -  **准侧**: 
        1. 当不确定时, 用括号,
        2. if you change the value of an operand, don't use that operand elsewhere in the same expression. (Exception： 有优先级存在, 当更改是本身, 同时更改后本身又是下个运算的operands, ```*++iter```,  ```++iter``` 更改了```iter```本身, 再用deference operator, no issue. 因为```++``` 先于 ```*``` 运算)


The precedence of postfix / prefix increment 高于deference
```c++
auto pbeg = v.begin();
// print elements up to the first negative value 

while (pbeg != v.end() && *beg >= 0)
    cout<<*pbeg++<<endl; //print the current value and advance pbeg

```

The conditional operator has fairly low precedence
```c++
cout << ((grade < 60) ? "fail" : "pass");  // prints pass or fail


cout << (grade < 60) ? "fail" : "pass"; // prints 1 or 0!  取决于grade < 60 is true or false

cout << (grade < 60); // prints 1 or 0,

cout ? "fail" : "pass"; // test cout and then yield one of the two literals 

// depending on whether cout is true or false


cout << grade < 60 ? "fail" : "pass"; // error: compares cout to 60

cout << grade; //返回的是cout, less-than has lower precedence than shift, so print grade first

cout < 60 ? "fail" : "pass"; // then compare cout to 60!


```


Assignment has low precedence, 下面例子如果不用括号, the operands to ```!=``` would be evaluate first, then ```i = true / false```
```c++
int i;
while ((i = get_value()) != 42) {
    // do something ... 
    
}
```

For operators that do not specify evaluation order, <span style="color:red">it is an error for an expression to refer to and change te same object.</span> Expression that do so have undefined behavior 比如

```c++
int i = 0;
cout << i << ", " << ++i <<endl;// undefined 

//因为可能打印0, 1 or 1, 1

```

比如下面的, no guarantees whichfunctin are called first. 如果下面的function 是独立的 and do not affect the state of the same objects or perform IO, then it is okay. 如果functions do affect the same object（比如同一个class的不同function, 会change class state）. then expression in error and has undefined behavior.
```c++
f() + g() * h() + j()
```

#### (c). Arithmetic Operators

**overflow** happens when a value is computed that is <span style="color:red">outside the range of values</span>. 比如下面例子,shorts are 16 bits. maximum short is 32767. the value wrapped around. The sign bit which had been 0 is set to 1, resultung in a negative value. 在其他system, the result might be different(也许会crash entirely).  On many systems, there is no compile-time or run-time warning when an overflow occurs. 

```c++
short val = 32767; //max value if shorts are 16 biys

val += 1; //this calculation overflows

cout << val; //print -32769

```

对于除法, C++11 新标准是商一律向0取整(truncate toward 0), ```(m/n)*n + m%n = m```, 比如m,n是正数,```(-m)/n``` 和 ```m/(-n)``` 都等于```-(m/n)```,  ```(-m)%n``` 和 ```m%(-n)``` 都等于```-(m%n)```, 

```c++
21%6;    /* resultis3 */    21/6; /* resultis3 */
21%7; /* resultis0 */       21/7; /* resultis3 */ 
-21%-8; /* resultis -5 */   -21/-8; /* resultis2 */ 
21%-5; /* resultis1 */      21/-5; /* resultis -4 */
```

**Logical Operator**

不可以写成 ```if(i<j<k)``` 因为```i<j```产生是true or false, 就变成```true/false < k```

#### (d). Assignment Operators

- Assignment is **right associative**. 
- <span style="background-color:#FFFF00">prefix operators (```++i```) return the object itself as **lvalue**, postfix```i++``` return a copy of the object's original value as **rvalue**</span>,  <span style="color:red">postfix may be costly. 因为要储存一个copy 再做increment/decrement</span>
- 没有括号优先级时<span style="background-color:#FFFF00">Operands can be evaluated at any order</span> .e.g when one subexpression changes the value of an operand that is used in another subexpression. 

```c++
int ival, jval;
ival = jval = 0;//jval = 0 返回 jval 赋值给ival

int ival, *pval;
ival = pval = 0; //error: they are different type, multiple assignment must have the same type.

//and no conversion from int * to int  

```


```c++
//对于compound assignment, the left-hand operand is evaluated only once

+=  -=  *=  /=  %= // arithmetic operators

<<=  >>=  &=  ^= |= // bitwise operators


//对于普通的the operand evaludated twice: 第一次是右侧的expression, 第二次是赋值给左侧

a = a op b;//等同于

```

The problem is both left- and right-hand operands use beg and right-hand operand changes beg. The assignment is undefined, 不知道是赋值时候是 ```*beg = ``` 还是 ```*(beg+1) = ```, 因为不知道是赋值先```*beg=toupper()``` 还是 ```*beg = *beg++```先

```c++
while (beg != s.end() && !isspace(*beg))
    *beg = toupper(*beg++); // error: this assignment is undefined


//可能会这样处理 or it may evaluate in some other way

*beg = toupper(*beg); // execution if left-hand side is evaluated first 

*(beg + 1) = toupper(*beg); // execution if right-hand side is evaluated first

```

#### (e). Bitwise Operators

- There are no guarantees for how sign bit is handled, we strongly recommend using unsigned types with bitwise operators (对于unsigned 没有要求, 建议使用signed)
-  Bitwise Shift operators yield a value that is copy of left-hand operand 但是 <span style="color:red"> right-hand operand must not be negative. </span> e.g. ```5<<-3``` <span style="color:red"> **Error**</span>
-  left shift operator ```<<``` insert 0-valued bit on the right. 而 right shift operator ```>>``` depends on the type of left-hand operand: 如果operand is unsigned, then operator insert 0 bits 在左侧, 如果signed, insert copies of sign bit or 0 bits 在左侧 
- <span style="color:red">Shift Operators (aka IO Operators) are **Left Associative**</span> ```cout << "hi" << " there" << endl;``` 等同于 ```( (cout << "hi") << " there" ) << endl;```
- The shift operators have midlevel precedence: lower than the arithmetic operators but higher than the relational, assignment, and conditional operators. <span style="background-color:#FFFF00"> (位移低于算数，高于比较), 意味着我们经常需要括号去正确 group operators </span>

Example. 用每一个bit 表示学生通过or fail 测验, 看第27名同学

```c++
unsign long quiz1 = 0;
quiz1 |= 1 << 27 //记录第27名同学通过测验

quiz1 &= ~(1 << 27) //记录第27名同学fail测验

bool status = quiz1 & (1<<27) //学生27是否通过测验

```
#### (f). Sizeof Operators

- ```sizeof``` 返回一个类型大小 /表达式结果类型(return type)大小 所占字符数, returns the size  in bytes of an expression or a type name. ```sizeof (type)``` or  ```sizeof expr```
- ```sizeof``` is a <span style="background-color:#FFFF00">**constant expression**</span> of type ```size_t```. 
- The operator is right associative. 
- ```sizeof *p```, <span style="background-color:#FFFF00">p可以是invalid</span>
- result applying sizeof  
  - ```sizeof char``` = 1 guaranteed 
  - sizeof reference returns the size of 被引用对象
  - sizeof pointer 得到指针本身空间大小 (the size neeed hold a pointer)
  - sizeof a deferenced pointer, 返回指针所指对象的所占空间小, 指针不需要有效
  - sizeof an array is the size of the entire array (整个数组的size of entire array). 等于 sizeof element 乘以 the number of elements. <span style="background-color:#FFFF00">注意sizeof does not conver the array to a pointer.</span>
  - sizeof a string or vector<span style="background-color:#FFFF00">该类型固定部分的大小(the size of fixed part of these types)，不会计算对象中元素占用了多少空间 (does not return the size used by the object's element)</span> 

```sizeof *p;``` <span style="background-color:#FFFF00">```sizeof``` 满足右结合律 并且与 ```*```优先级一样 </span>, 从右向左顺序组合， 等价于 ```sizeof(*p)```, 其次sizeof 不会求运算对象(operands)的值, 即使是无效(invalid, 即uninitialized)也没有任何影响, <span style="background-color:#FFFF00">在```sizeof``` 中, deferenence is safe , 因为指针实际上没有真正使用, ```sizeof``` 不需要真的deference 指针，也能只能它所指向的对象类型 </span> . 

在C++11中，<span style="background-color:#FFFF00">可以用**scope operator** to ask the size of memeber of a class type. </span>, 因为sizeof 运算无须提供一个具体对象,
```c++
Sales_data data, *p;
sizeof(Sales_data); // 存储Sales_data 类型所占空间大小

sizeof data; // size of data's type, i.e., sizeof(Sales_data)

sizeof p; // size of a pointer

sizeof *p; // size of the type to which p points, 即 sizeof(Sales_data) 

sizeof data.revenue; // size of the type of Sales_data's revenue member 

sizeof Sales_data::revenue; // alternative way to get the size of revenue

```

```c++
constexpr size_t sz = sizeof(ia)/sizeof(*ia);
int arr2[sz]; // ok sizeof returns a constant expression

```

#### (g). Comma Operators

- comma operator 含有两个运算对象(operands), 从左向右顺序依次求值
- <span style="background-color:#FFFF00">guarantees the order of evaluation</span>
- <span style="color:red">从左向右计算依次求值,先求左侧的表达式的值，然后将结果丢弃掉</span>，the result of comma expression 是右侧的表达值. The result is an lvalue if the right-hand operand is an lvalue 

```c++
vector<int>::size_type cnt = ivec.size(); 
for (vector<int>::size_type ix = 0; ix != ivec.size(); ++ix, --cnt) 
    ivec[ix] = cnt;
```

#### (h). Type Conversions

**(1). Implicit Conversion**

The compiler 自动转化运算对象
- 如果算数运算或者关系运算对象有多种类型，需要准换成统一类型
    - 算数转化： 把类型转化成最宽的类型, 比如 一个类型是long double, 无关其他是什么类型，都被转化成long double. 如果有float, 那么整数型会被转化成float
    - In most expression, 比int 类型小的整形(short) 首先提升为较大的整形(integral type)
    - In condition, non-bool expression convert to bool
    - In initializations, the initializer is converted to the ype of the variable; In assignments, 右侧运算被convert to 左侧运算
    - 如果某个运算符运算对象不一致， 这些运算对象将转化成同一类型, 但是如果某个运算对象是unsigned, 结果就依赖于机器中各个整数类型相对大小了， 转化类型要么都是unsigned, 要么都是signed的
- **Integral promotions(整型提升)**: convert  small integral types to a larger integral type. The types ```bool```, ```char```, ```signed char```, ```unsigned char```, ```short```, and ```unsigned short``` are promoted to ```int``` if all possible values of that type fit in an int. Otherwise, the value is promoted to ```unsigned int```.
- 较大的char(```wchar_t,char16_t, char32_t```)提升成```int, unsigned int, long, unsigned long, long long, unsigned long long```, 前提是转化类型能容纳原来类型所有可能的值
- 一个signed, 一个unsigned 
    - when unsigned type 大于等于signed type ， signed -> unsigned. 如果signed 是负数, 有副作用(比如 -1 会变成255)
    - when unsigned type  小于signed type , 结果依赖于机器, 如果unsigned的值都可以存入signed, 则 unsigned -> signed, 如果不能, signed -> unsigned 
    - e.g. long, unsigned int, 如果int 和long 大小相同, 则long -> unsigned int. 如果long 类型占用空间大于int, unsigned int -> long 

```c++
int ival = 3.541 + 3; //the compiler migh warn loss of precision

3.1415159L + 'a' // 'a' -> int(97) -> long double 

float f; char c; short s;
f + c; //c -> int -> floatt

s + c; //s -> int, c-> int 


int i; unsigned int ui; unsigned short us;
long l;  unsigned long ul; 
i + ul; //i -> unsigned long 

us + i; //根据unsigned short 和int 所占空间大小比较

ui + l;//根据unsigned int 和 long 所占空间大小比较

```

- Array -> Pointer ```int ia[10]; int * ip = ia;```
    - <span style="background-color:#FFFF00">当Array 用在```decltype```, ```&```, ```sizeof``` 以及 ```typeid```中不会发转化, </span>, 或者当引用初始化数组也不会 ```int (&arrRef)[10] = &ia```
- Pointer Conversion:  <span style="background-color:#FFFF00">a pointer to any nonconst type can be converted to ```void*```, any a pointer to any type can be converted to a ```const void *```</span> 
- Pointer -> Bool: If pointer value is zero, the conversion yield false, otherwise true  ```char * cp = get_string(); if(cp)```
- to Const: 允许pointer to a non const type to a pointer to the const type and reference. e.g. T is the type, 可以convert a pointer / reference to T into a pointer or reference to <span style="color:red"> const</span> T 
- Conversion defined by Class Types: Class types 可以定义conversions that the compiler will aplly automatically. The compiler apply only one class-type conversion at a time. e.g. ```string s; while(cin >> s); ``` while 把 cin 转化成bool  


```c++
int i;
const int &j = i; // convert a nonconst to a reference to const int

const int *p = &i; // convert address of a nonconst to the address of a const 

int &r = j, *q = p; // error: conversion from const to nonconst 

```

**(2). Explicit Conversion**

Use **cast** to request explicit conversion. (有时候不得不用cast, 但是cast 这种方法本质上是非常危险的), cast 只有cast reference 不是copy, pointer, value都是copy

```c++
//const cast pointer 是copy value 
const char* cp = "123";
char * newp = const_cast<char*>(cp);
newp = "abc";
cout<< cp <<" , " << newp<<endl; //print 123, abc


double cp = 10;
double& newp = static_cast<double&>(cp);
double newp2 = static_cast<double&>(cp);
newp = 20;
newp2 = 30;
cout<< cp <<" , " << newp<<" , "<< newp2<<endl; //20, 20, 30 

```

**static_cast** is often use when a large arithmetic type is assigned to a smaller type. 一般来说 如果compiler 发现一个较大的类型试图赋值给较小的类型, 会generate warning.  <span style="color:red">但是当我们do a explicit cast, the warning message is turned off.</span> 

static cast is useful when perform a version that compiler不会自动转换的. 例如, <span style="background-color:#FFFF00">we can use static_cast to retrieve pointer value that was stored in a ```void*```pointer</span>

```c++
void* p = &d; // ok: address of any nonconst object can be stored in a void*

 // ok: converts void* back to the original pointer type

double *dp = static_cast<double*>(p);
```

用```static_cast```强制转换原来类型时, 我们应该确保指针的值保持不变, 也就是说强制转化的结果与原始的地址相等. We must certain  that the type to which we cast the pointer is the actual type of that pointer. <span style="color:red">If the types not match, the result is undefined  </span>


**const_cast** : change only a  <span style="background-color:#FFFF00">low-level const</span> in operand. cast away the const. 一旦cast away const, the compiler不会发出警告when writing to that object. If object is orginally not a const, using cast to obtain write access is legal. However using a const_cast in order to write to a const object is undefined.


```c++
const char *pc;
char *p = const_cast<char*>pc; //okay but writing through p is undefined, 因为pc是const

const char *cp;
// error: static_cast can't cast away const

char *q = static_cast<char*>(cp);
string txt = static_cast<string>(cp); // ok: converts string literal to string 

string txt = const_cast<string>(cp); // error: const_cast only changes constness

```



**reinterpret_cast**: generally performs a low-level reinterpretation of the bit pattern of its operands. 为运算对象的位模式提供较低层次上的重新解释

```c++
int *ip;
char *pc = reinterpret_cast<char*>(ip);
string str(pc); //result in bizarre run-time behavior.

//pc指的真实对象是int 而非char. 如果把pc当成普通char指针，就会发生running error

```

上面例子提供了使用reinterpret_cast非常危险, 类型改变了，但compiler没有任何警告或者错误的信息提示. 比如上面中```pc```实际指向```int *```, 但使用```pc```时候, 会认定它是```char*```类型. compiler没法知道它存放是指向int 的指针

**old style cast**

```c++
type (expr); // function-style cast notation 

(type) expr; // C-language-style cast notation

char *pc = (char*) ip; // ip是指向整数的指针

//效果与使用reinterpret_cast一样

```
<br/> <br/> <br/>

## 5. Statements

The **null statement** is a empty statment ```;```

```c++
while(iter != svc.end()); //while 循环主体

    ++iter; //iter is not part of the loop, run after while
```

**Dangling(悬垂) else**: 规定了else与最近的if匹配, 比如下面的if else 从初衷来看是为了跟外层的if 匹配, 但是不管怎么锁紧都是跟内层if 比配的. 如果想让与外层if 匹配，需要花括号

```c++
if (grade > 6)
    if (grade  > 10 )
        cout <<" excellent";
else //与  if (grade  > 10 ) 匹配，实际上是6 < grade < 10进入这个else

//而不是grade < 6进入else

    cout << "fail"
```

**Do while**: 不要在条件部分定义变量, 然后在while 中判断
```c++
do{
    int i = 1;
}while( i != 1) // error: declaration in a do condition

```

**Break/continue** 只作用于最近的for, while, switch 
```c++
switch(buf[0]) { 
    case '-':
        for (auto it = buf.begin()+1; it != buf.end(); ++it)
        {
            if (*it == ' ')
                break;//作用于for, 不会break case

        } 
```

**Goto**:
-  与switch 类似, 不可以定义初始化的值 然后带出scope (cannot transfter control of initialized varaible 从初始化的scope到variable被用的scope)
- A jump backward over an already executed definition is okay(跳回一个已经执行的定义是ok). Jumping back to a point before a variable is defined destroys the variable and constructs it again

```c++
    goto end;
    int ix = 10; // error: goto bypasses an initialized variable definition

end: 
    // error: code here could use ix but the goto bypassed its declaration 

    ix = 42;

```
```c++
begin:
    int sz = get_size(); 
    if (sz <= 0) {
        goto begin;
    }
// Here sz is destroyed when the goto executes. 

//It is defined and initialized 一个新的sz when jump back to begin

```

#### (a). switch 

- switch 中的case, switch 必须是[integral constant expression](#constexpr) (整型常量表达式),<span style="background-color:#FFFF00"> 所以不能用string, double 作为switch 或者case 条件, 可以用simple char(not char*, not char array), int, enum, string\[index] (it's char)</span>
- 任何两个case 不能相同
- <span style="background-color:#FFFF00">如果没有break, 当一个case match， 会执行接下来所有的case until program explicitly interrupts it</span>, 但是最后一个case 不一定加break, 但为了安全最好加上, 如果有新的case, 这样不用担心前面break
- 有时候想两个或多个case 值共享一组操作(common set of actions), we omit a break, allowing program to fall through multiple case labels
- **default**: 如果没有任意match上, 进入default, 如果default 是空的, 加上default 也是有用的，因为告诉读者我们考虑了全部情况
- Variable Definitions inside the Body of a switch: 
    - <span style="color:red">如果定义并初始化的值, it is illegal to bring to outscope</span>
    - <span style="color:red">如果定义没有初始化，是可以的; </span>


```c++
int ival = 42;
char ch = getVal();
switch (ch){
    case 3.14: //error noninteger as case label

    case ival: // error nonconstant as case label

}

string a = "123";
switch(a) // error not integral constant expression

```

stack several case together with no break.只要ch是元音，都执行相同代码
```c++
unsigned vowelCnt = 0; 
switch (ch) {
    // any occurrence of a, e, i, o, or u increments vowelCnt

    case 'a':
    case 'e':
    case 'i':
    case 'o':
    case 'u':
        ++vowelCnt;
        break;
}

//因为case 之后不一定要换换换行

// alternative legal syntax

switch (ch)
{
    case 'a': case 'e': case 'i': case 'o': case 'u':
        ++vowelCnt;
        break;
}
```
当omit break时候, 会执行所有的case, 比如```ch = 'e'```,  ```eCnt```, ```iCnt```, ```oCnt```, ```uCnt```, ```d```, 都会加1

```c++
switch (ch) {
    case 'a':
        ++aCnt; // oops: should have a break statement

    case 'e':
        ++eCnt; // oops: should have a break statement

    case 'i':
        ++iCnt; // oops: should have a break statement

    case 'o':
        ++oCnt; // oops: should have a break statement

    case 'u': 
        ++uCnt;

    default:
        d++;
}
```

可以在别的case 中定义variable, 在别的case中使用; 但是不可以在别的case中 定义并初始化值, 然后在别的scope 使用
```c++
case true:
// this switch statement is illegal because these initializations might be  bypassed

    string file_name; // error: implicit初始化, file_name = ""

    int ival = 0;// error: control bypasses an explicitly initialized variable

    int jval; // ok: because jval is not initialized
    
    break; 

case false:
    // ok: jval is in scope but is uninitialized
    
    jval = next_num(); // ok: assign a value to jval

    if (file_name.empty()) // file_name is in scope but wasn't initialized

```


#### (b). Range for statment  

```c++
for (declaration : expression)
     statement
```

expression must represent a sequence(必须是一个序列), 例如 a braced initializer list({1,2,3}), an array, or an object such as vector or string (has iterator)


#### (c). Exception Handling

- when throw error, need to initialize error by give a string or c-style character style
- Each exception classes define a member function named ```what```, function takes no arguments and return c-style character style (即 ```const char*```), 返回的对象是copy of string used to initialize the object; 对于没有初始值的exception,```what``` returns 由compiler 决定 
- If no appropriate catch is found, execution is transferred to a library function ```terminate```. 该函数行为与系统有关 but is guaranteed to stop further execution of the program

```c++
try{
    throw runtime_error("Data must refer to same object");
}catch(runtime_error err){
    cout <<err.what(); //print Data must refer to same objec

}
```

- ```exception``` header defines 最通用的 exception class, 它只报告exception occur 但没有额外信息
- ```stdexcept``` header files 几个general-purpose exception classes ```exception ```, ```runtime_error```,```range_error```, ```overflow_error```, ```underflow_error```, ```logical_error```, ```domain_error```, ```invalid_argument```, ```length_error```(试图建立一个超出该类型最大长度的对象), ```out_of_range```
- ```new``` header defines the ```bad_alloc``` exception type
- ```type_info``` header defines the ```bad_cast``` exception type 
- 只能用default initialization ```exception```,  ```bad_alloc```, ```bad_cast```  不允许提供initializer for these exception types



<br/> <br/>  <br/>

## 6. Functions

#### (a). Function Basic

**Calling a Function**. A function does 2 things. 1. <span style="color:red"> Initializes the function's parameter</span> from corresponding argument, and it <span style="color:red">transfer control</span> to function. 2. Execution of <span style="color:red">the *calling* function(主调函数) is suspended</span> and execution of <span style="color:red">the *called* function begins</span>(被调函数, 函数主题)

当function 执行完成: the return statement does 2 things. 1. return the value in the return 2. <span style="color:red">transfers control out of the *called* function back to the *calling function*</span>

**Parameters and Arguments(形参和实参)**<span style="color:red">Arguments are the initializers for a function’s parameters.</span> e.g. **int fact(int val); fact(5)**, 5 是argument and ```val```是parameter

**Function Parameter List**: A function's parameter list 可以为空, 但不能省略. Parameter names are optional. However, there is no way to use an unnamed parameter. 如果parameter unnamed, 表示function 没有使用它，但是called 时候不代表argument 会减少
```c++
void f1(){ /* ... */ } // implicit void parameter list

void f2(void){ /* ... */ } // explicit void parameter list

```

**Function Return Type**: return type can be void. <span style="background-color:#FFFF00">但是不能是array type or function type.</span>, 但是可以return a pointer to array or a function. 

**local variable**: 如果局部变量和外面变量名字一样, <span style="color:red">
局部变量会hide declarations of the same name made in outer scope</span>

**automatic objects**: object exist only while a block is executing. 在执行完block, value of automatic objects 被销毁, the values of automatic objects are undefined.

**local static objects**: is intialized when the first time execution pass through object definitions. 直到program terminate destoryed. 如果不提供初始值, 将执行value initailized 意味着local statics of built-in type are initialized to 0 (内置类型的静态 被初始化为0) 

```c++
size_t count_calls(){
    static size_t ctr = 0; //value will persist across calls

    return ++ctr;
} 
```
**Function Declarations**: 可以被declared (声明)多次, 但只能定义一次. 声明不需要函数主体, 用一个分号代替即可(也可以省略parameter的名字) ```void pint(vector<int>&li);```

These 3 elements—return type, function name, and parameter types—describe the function’s interface. They specify all the information we need to call the function. Function declarations are also known as the function **prototype**.

#### (b). Argument Passing

**(1). Pointer Parameter**: nonreference type, <span style="background-color:#FFFF00">when we copy pointer, the value of the pointer is copied. After the copy, two pointers are distinct(pointer地址不同的, 但指向相同的对象, which means 如果更改function 内部的pointer 指代对象不会影响外面的pointer). </span>, 因为pointer give indirect access the object, 所以可以通过指针修改object的值

```c++
//case 1: pointer is different 

void reset(int *ip){
    int j = 10;
    ip = &j;
}

int i = 0, *p = &i;
reset(p);
cout << *p << " , "<<i<<endl; //print 0, 0 


//case 2: 可以改变object的值

void reset(int *ip){
    *ip = 10;
}
int i = 0, *p = &i;
reset(p);
cout << *p << " , "<<i<<endl; //print 10, 10 

```

**(2) Reference Parameter**: Can use Reference Parameters to return additional information

**(3). const Parameters and Arguments**: <span style="background-color:#FFFF00">when we copy an argument to initialize a parameter. top-level const are ignored. 顶层const被ignore</span> We can pass either a const or a nonconst object to a parameter that has a top-level const:

因为顶层const 被忽略掉, 所以两个fun, 两个reset function是一样的function
```c++
void fcn(const int i) // 可以pass int or const int 

void fcn(int i) //也可以接受int, const int

void reset(int const * const ip); 
//可以pass const int * p, 也可以是pass const int * const p

void reset(int const * ip);
//是两个一样的reset function

```

**(4). Use Reference to const When Possible**：如果只pass reference without const，可能给读者错误导function可能改变value; 另外<span style="color:red">用reference, we cannot pass a const object, a literal, or an object requires conversion to a plain reference parameter </span>

```c++
find_char(string& str, char ch);
void isSentence(const string & s){
    return find_char(s, 'a'); //error 因为不能pass const reference to reference 

}
```

**(5). Array Parameters**

数组有两个性质: 1. cannot copy an array 2. when use array, it convert to a pointer. <span style="background-color:#FFFF00"> 因为不能拷贝, cannot pass by value. 因为array convert to pointer, 当pass array, we actutally pass a pointer to the array's first element.</span>. <span style="background-color:#FFFF00">当call function时, array size is irrelevant</span>

下面是几个函数declarations are equivalent; 每一个function 都是有一个parameter of type ```const int*```, 如果都在一个程序中写出下面三个function, compiler会显示<span style="color:red">redefintion error.</span> 
```c++
// each function has a single parameter of type const int*

void print(const int*);
void print(const int[]); //可以看出来, 函数意图是作用于数组

void print(const int[10]); //这我们期望有多少个元素, 实际不一定

int i = 0, j[2] = {0, 1};
print(&i); // ok: &i is int*

print(j); // ok: j is converted to an int* that points to j[0],

//the size of array is irrelevant

```

<span style="background-color:#FFFF00">function parameter 是 array, **size doesn't matter**</span>
```c++
void print(int arr[3]){
   cout << arr[0]<<endl;
}

int a [6] = {0,1,2,3,4,5};
print(a); //print 0

```	
	

因为arrays are passed as pointer, functions 通常不知道size of the array, caller必须提供额外的信息

方法一：Using a Marker to specify the extent of an Array. e.g. C-style character strings 有null character at the end. <span style="color:red">**缺点是**: not work well that don't have end-marker like ```int```</span>
```c++
void print(const char *cp)
{
    if (cp) // if cp is not a null pointer character

        while (*cp) // so long as the character it points to is not a null

            cout << *cp++; // print the character and advance the pointer

}
```

方法二: Using the Standard Library Conventions, pass pointers to the frist and one past the last element in the array.
```c++
void print(const int *beg, const int *end)
{
    while (beg != end)
        cout << *beg++ << endl; // print element and advance pointer

}

int j[2] = {0,1};
print(begin(j), end(j));
```

方法三: Explicitly Passing a Size Parameter: which is common in C and older C++ programs. The function executes safely as long as the size passed is no greater than the actual size of the array.

```c++
void print(const int ia[], size_t size)
{
    for (size_t i = 0; i != size; ++i)
        cout << ia[i] << endl;
}

intj[]={0,1}; 
print(j, end(j) - begin(j));
```

**(6).Array Reference Parameters** 只有需要change the value, 采用Array reference, 如果不改变value, 用 pointer to const, 当有引用时, <span style="background-color:#FFFF00">只能传入与引用size 一样维度的array,**size matters**</span>, 比如下面的function, 只能传入size = 10的  

```c++
void print(int (&arr)[10])
//括号不能少

//int &arr[10]: error, reference is not object, 不能定义array of reference

{ 
    for (auto elem : arr) 
        cout << elem << endl;
}

int i = 0, j[2] = {0, 1};
int k[10] = {0,1,2,3,4,5,6,7,8,9};
print(&i);// error: argument is not an array of ten ints 

print(j); // error: argument is not an array of ten ints 

print(k); // ok: argument is an array of ten ints

```

**(7). Passing a Multidimensional Array**: 实际上没有真正的多维数组. Multidimensional array is passed as a pointer to its first element (因为时多维数组, the first element 还是 a pointer to the first element). <span style="background-color:#FFFF00">The size of the second (and any subsequent) dimension is part of the element type and must be specified (**second dimension size matters**)</span>

```c++
void print(int (*matrix)[10], int rowSize) { /* . . . */ }
//declares matrix as a pointer to an array of ten ints.

// equivalent definition

void print(int matrix[][10], int rowSize) { /* . . . */ }
```

**(8). main: Handling Command-Line Options**: argv 第一个元素指向程序名字或者空的字符串, 接下来的传入argument provided by command line. <span style="color:red">最后一个element is guaranteed to 0</span>.

```c++
int main(int argc, char *argv[]) 
//也等于

int main(int argc, char **argv) 

//如果传入 prog -d -o ofile data0

argv[0] = "prog"; argv[1] = "-d"; argv[2] = "-o";
argv[3] = "ofile"; argv[4] = "data0"; argv[5] = 0;
```

**(9). Functions with Varying Parameters**: 处理不同数量argument: <span style="background-color:#FFFF00">如果argument类型相同, we can pass **initializer_list**的标准库, 如果函数类型不同, we need to a special kind of function (variadic template)</span>. 还有一个parameter type (ellipsis) 可以用于传入varying number of arguments. (注意ellipsis should be only used in programs that need to interface to C functions)


An **initializer_list** is a library type that represents an array of values of the specified type. This type is defined in the initializer_list header. 
- <span style="background-color:#FFFF00">unlike vector, element in **initializer_list**  are always ```const``` values, we cannot change the elements in **initializer_list** </span>
- When we pass a sequence of values to an initializer_list parameter, we must <span style="background-color:#FFFF00">enclose the sequence in curly braces```{}```</span>

| Syntax      | Description |
| :---        | :---    |  
| ```initializer_list<T>lst``` | Default initialization, an empty list of elements of type T |
| ```initializer_list<T>lst{a,b,c}``` | elements are copied of correspoding initializers. <span style="color:red"> elements in the list are const </span> | 
| ```lst2(lst)``` | copy or assigning an initailizer_list 但不会一一拷贝列表中元素. After the copy, the original and the copy share he elements. <span style="color:red">  sallow copy</span>| 
| ```lst.size()``` | number of elements in list | 
| ```lst.begin() / lst.end())``` | returns a pointer to the first / one past the last element in lst|

```c++
initializer_list<string> ls; // initializer_list of strings 

initializer_list<int> li; // initializer_list of ints

void error_msg(ErrCode e, initializer_list<string> il)
{
    cout << e.msg() << ": ";
    for (auto beg = il.begin(); beg != il.end(); ++beg) 
        cout << *beg << " " ;
}

error_msg(ErrCode(42), {"functionX", expected, actual});

```


**Ellipsis Parameters(省略符形参)**: Ellipsis parameters are in C++ to allow programs to interface to C code that uses a C library facility named ```varargs```. 不能被用于其他目的. <span style="color:red">Ellipsis只能用于types ftht are common to both C and C++</span>(object of most class types are not copied properly when passd to an ellipsis parameter)

An ellipsis parameter 只能出现在parameter最后一个, and may take either of two forms
```c++
void foo(parm_list, ...);
void foo(...);
```

#### (c). Return Types 

Failing to provide a return after a loop that contains a return is an error(for loop 中有if 然后return, 但是程序fail 进入那个if，所以程序最后到达end of function without return). <span style="color:red">However, many compilers will not detect such errors</span>.

**(1). How Values Are Returned**: The return value is used to initialize a temporary at the call site(调用点), and that temporary is the result of the function call.
- 如果return是value (<span style="background-color:#FFFF00">returns are **rvalue**</span>), return value is copied to the call site. The function returns a copy of he return value. 
- 如果return是reference(<span style="background-color:#FFFF00">returns are **lvalue**</span>), reference is just another name for the object to which it refers

当function return 是 list initializing the return value, <span style="color:red">element inside brace list cannot have larger type which require narrowning conversion</span> 
```c++
vector<int>get(){
    return {3.14,5};//3.14->int illegal, 

}
```


**(2). Never Return a Reference or Pointer to a Local Object**: <span style="color:red">after a terminate, reference to local objects refer to memory that is no longer valid.</span>

```c++
const string &manip()
{
    string ret;
    if (!ret.empty()) return ret; 
    // WRONG: returning a reference to a local object! 

    else return "Empty";
    //WRONG: "Empty" is a local temporary string

}
```

<span style="background-color:#FFFF00">因为function reference 返回时lvalue, we can assign to the result of a function that returns a reference to nonconst </span>
```c++
char &get_val(string &str, string::size_type ix)
{ 
    return str[ix];
}
string s("a value");
get_val(s, 0) = 'A'; // changes s[0] to A 

cout << s << endl; // prints A value return 0;

```

**(3).Functions That Return Class Types and the Call Operator**: <span style="background-color:#FFFF00">call operator(call function() )的优先级和 dot and arrow operator 一样</span>, call operator is <span style="background-color:#FFFF00">left associative(assignment 是right associative)</span>. 所以if function returns a pointer, reference or object of class type, we can use the result to call a member of the resulting object

```c++
auto sz = shorterString(s1, s2).size();
```

**(4). Return from main**: The main function is allowed to terminate without a return. 如果control reaches the end of main and there is no return, compiler implicitly inserts a return of 0. main的返回值看做状态指示器, 返回0表示执行成功, 返回其他值表示执行失败. 非0值得含义由机器而定. 为了使返回值与机器无关, ```cstdlib``` header中定义了连个预处理(preprocessor)变量 that we can use to indicate success or failure, <span style="background-color:#FFFF00">因为是预处理变量, 不能加上```std::```, 也不能```using``` 声明中出现.</span> <span style="color:red">注: main function may not call itself</span>

```c++
int main()
{
    if(some_failure)
        return EXIT_FAILURE; // defined in cstdlib

    else  
        return EXIT_SUCCESS; // defined in cstdlib
         
}
```

**(5). Return a Pointer to an Array**: <span style="background-color:#FFFF00">因为不能copy an array, a function cannot return an array. However, a function can return a pointer or reference to a array</span>


**方法一**: 为了straightforward, 可以用type alias

```c++
typedef int arrT[10]; //arrT is a synonym for the type array of 10 ints

using arrtT = int[10]; //跟上面一样的

arrT* func(int i); //returns a pointer to an array of 10 ints

```

without type alias,想定义一个函数 that returns a pointer to an array, <span style="background-color:#FFFF00"> dimension(维度)必须跟在函数名字之后, However, function parameter list which also follows the name. Parameter list 在dimension 前面. function 两端的括号必须在, 如果没有括号表示returns an array of pointers 但是array不能被copy</span>

```c++
Type (*function(parameter_list))[dimension]
//Dimension 表示数组的大小

//function 两端的括号必须在

int (*func(int i)) [10]; 
//function take a integer 

//返回a pointer to array of 10 ints

```

**方法二: Using a Trailing Return Type**: 在C++11中, 另一种简化function returns a pointer to array 是 using a **trailing return type**. <span style="background-color:#FFFF00">A trailing return types可以用于任何function, but are most useful for functions with complicated return types(such as pointers to array)</span>. Parameter list 在->左侧, 为了表示函数真的返回类型跟在parameter list 之后, we use ```auto``` for return type

```c++
// fcn takes an int argument and returns a pointer to an array of ten ints

auto func(int i) -> int(*)[10];

auto func(int i) -> string{
    return "val";
}
```

**方法三: Using decltype**: 

```c++
int odd[] = {1,3,5,7,9};
int even[] = {0,2,4,6,8};
decltype(odd) *arrPtr(int i)
{
    return (i % 2) ? &odd : &even; // returns a pointer to the array 
    
}
```

注: ```decltype``` 并不负责把array 转化成pointer type. The type returned by ```decltype``` is an array type, 我们必须加上```*``` to indicate that ```arrPtr``` returns a pointer

#### (d). Overloaded Functions

- Functions有一样的名字但是parameter lists different and appear in the same scope are overloaded. <span style="color:red">When call these functions, compiler can deduce which function</span> we want based on argument type we pass
- <span style="color:red">main function 不能被overloaded</span>
- <span style="color:red">It is an error for two functions only return types different</span>(如果只有返回类型不同,error)
- <span style="color:red">It is an error for two functions only parameter top level const different</span>(如果一个function 有顶层const, 另一个没有顶层const, 两个function 是一样的)

```c++
Record lookup(const Account&);
bool lookup(const Account&);//error: only return type is different

```

Determine whether two parameter types differ
```c++
// each pair declares the same function 每一组function 都是一样的

Record lookup(const Account &acct);
Record lookup(const Account&); // parameter names are ignored


typedef Phone Telno;
Record lookup(const Phone&);
Record lookup(const Telno&); // Telno and Phone are the same type

```

顶层const 不影响传入函数的对象, 一个拥有顶层const和一个没有top level const的function 无法区分, 下面每组的function 第一个和第二个声明是一样的
```c++
Record lookup(Phone);
Record lookup(const Phone); // redeclares Record lookup(Phone)


Record lookup(Phone*);
Record lookup(Phone* const); // redeclares Record lookup(Phone*)

```

但如果const时候底层的, we can overload 如果指针or 引用 指向const or non const object. 下面的例子, <span style="background-color:#FFFF00">compiler can use the constness of the argument to distinguish which function to call</span> 因为const 不能转化类型, 所以只pass 给含有const 的function. <span style="background-color:#FFFF00">但是nonconst 可以转化成const,所以下面四个function 都可以被nonconst function call. 但是compiler **prefer the nonconst version** when we pass a **nonconst object** or pointer to nonconst</span>

```c++
// functions taking const and nonconst references or pointers have different parameters

// declarations for four independent, overloaded functions

Record lookup(Account&); // function that takes a reference to Account

Record lookup(const Account&); // new function that takes a const reference

//当Account是const call 第二个,当Account 不是const call


Record lookup(Account*); // new function, takes a pointer to Account

Record lookup(const Account*); // new function, takes a pointer to const

```

**const_cast**

```c++
//需要返回一个引用, 如果直接定义 string& shorterString(const string &s1, const string &s2)

//会报错，不可以把 const reference assign 给 reference, 需要const_cast 

const string &shorterString(const string &s1, const string &s2) {
    return s1.size() <= s2.size() ? s1 : s2;
}

string &shorterString(string &s1, string &s2)
{
    auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));
    return const_cast<string&>(r);
}
```   
首先cast argument to references to const. function returns a reference to const string, 再cast ```const string &``` back to plain string&

**calling an overloaded function**

当call overload function, 有三种可能的结果: 
- The compiler finds exactly one function that is a <span style="background-color:#FFFF00">best match</span> for the actual arguments and generate code to call that function 
- 找不到任何一个函数match the arguments in the call, 此时compiler <span style="color:red">发出error message no match</span>
- 如果有大于一个function matches and none of the matches is clearly best, 也发发生错误 <span style="color:red">ambiguous call</span>.

**Overloading and Scope**: <span style="background-color:#FFFF00">In C++ name lookup happens before type checking </span>. 当declare a name in an inner scope, that name hides use of that name declared in outer scope. 

下面例子, when call print, the compiler 首先 look for declaration of print, once the name is found. Compiler 会忽略掉外层scope 一样的命名的function, Instead, the copiler assumes that 在当前作用域中找到的就是the one for the name we are using 

```c++
string read();
void print(const string &);
void print(double); // overloads the print function 

void fooBar(int ival)
{
bool read = false; // new scope: hides the outer declaration of read 

string s = read(); // error: read is a bool variable, not a function 

// bad practice: usually it's a bad idea to declare functions at local scope

void print(int); // new scope: hides previous instances of print 

print("Value: "); // error: print(const string &) is hidden 

print(ival); // ok: print(int) is visible

print(3.14); // ok: calls print(int); print(double) is hidden

}

```


#### (e). Features for Specialized Uses

**(1). default Arguments**: are used for the right-most(trailing) argument of a call. <span style="background-color:#FFFF00"> 设计时让不怎么可能用default放前面, likely to use a default value appear first</span>
```c++
string screen(int ht = 24, int wid = 80, char backgrnd = ' ');
window = screen(, , '?'); // error: can omit only trailing arguments

```

另一种用default parameter的形式, names used as default arguments are resolved in the scope of function delcaration(<span style="color:red">名字在函数声明所在作用域内解析</span>), The value that those names represent is evaluated at the time of the call.(<span style="color:red">求值过程发生在函数调用时</span>)

```c++
int wd = 80;
char def = ' ';
size_t ht();
string screen(int = ht(), int = wd, char = def);

void f(){
    def = '*';  //change value of default argument

    int wd = 100; //hides the outer definition of wd but does not change the default

    string window = screen(); // calls screen(ht(), 80, '*')
    
}
```

**(2). Inline and constexpr Functions**

比如我们有个比较string 大小的function, 好处是如果我们修改比较方法,直接修改function, 而不用找比较表达式所有出现的地方修改conditon. 潜在缺点是: slower than evaluating the equivalent expression.  因为call function does a lot of work: 调用前先保存寄存器(registers) , 返回时恢复. 可能需要copy argument and program branches to a new location(程序转向一个新的位置继续执行)

**inline vs constexpr**
- inline functions, expression are always evaluated at the <span style="color:red">run time</span> and are request to compiler to expand(展开function) at compile time . 但是constexpr functions are evaluated at <span style="color:red">compiled time(not always)</span> 

```c++
constexpr long int fib(int n) 
{ 
    return (n <= 1)? n : fib(n-1) + fib(n-2); 
} 
  
int main () 
{ 
    // value of res is computed at compile time.  
    
    const long int res = fib(30); 
    cout << res; 
    return 0; 
} 

const long int res = fib(30);  // run time is 0.0003s;
long int res = fib(30); //run time is 0.017s;
```



**inline function** 在每个调用点上"内联"的展开 (expanded "in line" at each call) 比如下面函数, would expand during compilation into something in line, <span style="color:red">消除了函数运行时的开销(The run-time overhead of making shortString a function is removed)</span>
```c++
cout << shortString(s1,s2)<<endl;
//在编译过程中展开成类似于下面的形式

cout << (s1.size() < s2.size() ? s1 : s2 )<<endl;
```

- <span style="background-color:#FFFF00">The inline specification is only a request to the compiler. The compiler may choose to ignore this request.(inline 是向compiler 发送请求, compiler可以选择忽略这个请求)</span>
- <span style="background-color:#FFFF00">inline meachanism 用于规模小的, 流程直接, 频繁调用的函数, 不支持recursion</span>(optimize small, straight-line functions that are called frequently. Many compilers will not inline a recursive function.)<span style="background-color:#FFFF00"> 也不支持很多行的函数</span>(比如一个75行的函数很难被inline expanded)
- inline function defintion 最好放进header, 因为inline function 和 class compilation 需要在一个translation unit. Function 放进header must marked ```inline``` 否则every translation unit which includes the header will contain a definition of the function. linker will complain about multiple definition (违反了one defintion rule)

**constexpr function**: 
- <span style="background-color:#FFFF00">return type must be literal type</span> (int(reference, pointer), double, enum, char, char pointer, 但string 不是)
- <span style="background-color:#FFFF00">函数主体有且只有一个return statement</span>(function body must contain exactly one return statement, 不能有通过if 判断的多个statement),C++ 14 allows more than one statements.
- constexpr function can only call other constexpr function not simple function
- constexpr function should not be viod type and some operator like prefix increment (++v) are not allowed in constexpr function. 
- compiler will replace a call to constexpr funcion with its resulting value.(compiler 把constexpr 函数的调用换成其结果值)
- <span style="color:red">constexpr functions are implicitly inline </span>
- <span style="color:red">A constexpr function body 可以含有other statements 只要这个statement generate no actions at run time</span> (e.g. null statment, type aliases, and using declaractions)
- <span style="color:red">A constexpr function is not required to return a constant expression.</span>
- 如果需要constexpr function 返回constant expression, 需要function argument也是constant expression

```c++
constexpr int new_sz() { return 42; }
constexpr int foo = new_sz(); // ok: foo is a constant expression

//compiler can verify new_sz return a constant expression at compile time

```

只要argument(cnt) 是constant expression, ```scale(arg)``` is a constant expression, 2 是constant expression, 所以compiler 会把所有的```scale(2)``` 用constexpr function resulting value 代替. 如果返回不是constant expression, compiler 会有error message
```c++
constexpr size_t scale(size_t cnt) { return new_sz() * cnt; }

int arr[scale(2)]; // ok: scale(2) is a constant expression

int i = 2; // i is not a constant expression

int a2[scale(i)]; // error: scale(i) is not a constant expression

```

**(3). Aids for Debugging**

**assert** is a **preprocessor macro(预处理器)**. 
- **assert** 是 **preprocessor macro**.
  - <span style="color:red">A preprocessor macro is a preprocessor variable that acts like inline function. </span>
  - 预处理器名字 由预处理器(preprocessor) 管理而不是compiler, 所以当使用preprocessor name directly, do not provide a using declaration or ```std::``` for them.
  - 和preprocessor variable 一样, **macro** names must be unique within the program. <span style="color:red">Program that include ```cassert``` header 不能有variable, function, or other entity named assert.</span>. 很多header 都包含了```cassert``` header, 所以即使没有include 它,也很有可能直接用
- ```assert(expr);``` in ```cassert``` header 中: evaluates ```expr``` and if expression is false, 输出信息并终止程序的执行, 如果表达式正确 什么也不做, 
  - assert 常用来检查不能发生的情况， ```assert(word.size() > threshold);```
- <span style="color:red">```assert``` 用来当做调试程序的辅助手段(aid) 而不能用作真正的run-time logic checks or error checking</span>

the preprocessor defines four other names that can be useful in debugging:

|  Preprocessor variables      | Description |
| :---        | :---    |  
| _ _FILE_ _ |  string literal containing the name of the file | 
| _ _LINE_ _ |  integer literal containing the current line number | 
| _ _TIME_ _ |  string literal containing the time the file was compiled | 
| _ _DATE_ _ |  string literal containing the date the file was compiled | 

```c++
if (word.size() < threshold)
    cerr << "Error: " << _ _FILE_ _
    << " : in function " << _ _func_ _
    << " at line " << _ _LINE_ _ << endl << " Compiled on " 
    << _ _DATE_ _ << " at " << _ _TIME_ _ << endl

// print 

// Error: wdebug.cc : in function main at line 27 

//    Compiled on Jul 11 2012 at 20:50:03

```


**NDEBUG Preprocessor Variable**
- assert的行为depends on the status of a **preprocessor variable** 名为 **NDEBUG**, <span style="color:red">如果**NDEBUG** is defined, ```assert``` does nothing.</span> By default, **NDEBUG** is not defined. <span style="color:red">So by default, ```assert``` performs a run-time check</span>
- We can turn off debugging by providing a ```#define``` to define ```NDEBUG```. 
  - 也有个compiler provide a command-line option that lets us define preprocessor variable ```CC -D NDEBUG main.cpp``` or ```/D``` with microsoft compiler has the same effect as writing ```define NDEBUG``` at the beginning of main.cpp
- 定义了```NDEBUG``` <span style="color:red">能避免各种条件所需的runtime 开销</span> (avoid run-time overhead involved in checking various conditions). <span style="color:red">no run-time check</span>
- 如果```NDEBUG``` is not defined, the code between the ```ifndef NDBUG``` and ```endif``` is executed. 如果```NDEBUG``` is defined, code is ignored. 

```c++
void print(const int ia[], size_t size)
{
#ifndef NDEBUG

// _ _func_ _ is a local static defined by the compiler that holds the function's name

// _ _func_ _  是局部静态变量,显示函数名字

cerr << _ _func_ _ << ": array size is " << size << endl; 

#endif

```

#### (f). Function Matching

- step 1: 选定a set of overloaded functions considered for the call. The function in this set are the **candidate functions**
  - candidate functions 是 function has the same named as the called function and declaraction is visibe at the point of the call 下面例子中有4个候选的function 
- step 2: 根据arguments,从candidate function 中选出可以被arguments调用的函数, 这些新选出的函数称为**viable function**. 下面例子有两个viable functions. To be viable function,: 
  - must have the same number of parameters as there are arguments int the call (parameter 数量必须跟调用的函数提供argument 数量一样)
  - 每个argument must match or be convertible to corresponding parameter 
  - If there are no viable functions, the compiler will complain that there is no matching function.如果没有找到可行函数, compiler 会报错
- step 3: find the best match: 这一过程是逐一检查argument in the call and 选择function parameter 与argument best match的viable function, 下面例子中当 call ```f(int)``` 需要```double -> int```, 而call ```f(double, double)```不用convert


```c++
void f();
void f(int);
void f(int, int);
void f(double, double = 3.14); 
f(5.6); // calls void f(double, double)

```

**当有多个函数比配**: compiler以此检查argument by argument， 如果有一个function 满足下列条件，则比配成功: 
- 每个argument的匹配不劣与其他可行函数需要的匹配 (The match for each argument is no worse than the match required by any ohter viable function)
- 至少有一个arugment的match 优于其他的viable functions的匹配(There is at least one argument for which the match is better than the match provided by any other viable function)
- <span style="color:red">如果没有任何一个函数脱颖而出, 则call is error, the compiler will complain that the call is ambiguous</span>
    - 比如```f(42,2.56)```, ```f(int, int);``` 和 ```f(double, double);```是一样的, ambigous call. 
- 如果需要cast 才能找到最匹配的call, 是poorly design. Casts should not be needed to call an overloaded function. The need for a cast suggests that the parameter sets are designed poorly.


**compiler ranks the conversions thatconver each argument to the type of parameters**:

1. 精准匹配(exact match). An exact match happens when:
    - argument and parameter types sre identical
    - The argument is converted from an array or function type to the corresponding pointer type.
    - top-level const is added or discarded from the argument (<span style="background-color:#FFFF00">添加或去掉top-level const</span>)
2. Match through a const conversion (通过const 转化实现)
3. Match through a promotion (通过类型提升实现, e.g. ```short->int```)
4. Match through an arithmetic or pointer conversion (通过算数或者指针转换 (e.g. pointer -> bool ```if(*cp)``` ))
5. Match through a class-type conversion. 

注:好的desgin 一般不会有functions with parameters 类似下面例子的

<span style="background-color:#FFFF00">small integral types always promote to int or to a larger integral type</span> e.g1: 一个function take parameter ```int```, 另一个take ```short```. Short 只有argument 是short的时候会被call, 即使有时是很小的整数值, 也会被promote to ```int```. whereas calling the ```short``` version would require a conversion. 

<span style="background-color:#FFFF00">所有arithmetic conversion 都是一个级别的, 从int 到unsigned int 转换不比从int 到double 转换级别高

```c++
void ff(int); 
void ff(short);
ff('a'); // char promotes to int; calls f(int)


void manip(long);
void manip(float); 
manip(3.14); // error: ambiguous cal

```

**Function Matching and const Arguments**: 

the compiler uses the <span style="background-color:#FFFF00">constness of the argument</span> to decide which function to call: 下面第二个例子, b to initialize a reference to either const or nonconst type.但是initializing a reference to ```const``` from a nonconst object <span style="color:red">require a conversion</span>. 但是<span style="background-color:#FFFF00">convert to const的级别低于exact match</span>, 因此non-const version is prefer

pointer works in similar ways, 如果argument is a pointer to const, the call will match function that takes ```const *```, otherwise, 如果argument is a pointer to nonconst, the function 有 a plain pointer is called


```c++
Record lookup(Account&); // function that takes a reference to Account

Record lookup(const Account&); // new function that takes a const reference


const Account a;
Account b;
lookup(a); // calls lookup(const Account&)

lookup(b); // calls lookup(Account&)

```

#### (g). Pointers to Functions

- a pointer that <span style="color:red">denotes a function rather than an object</span>. Like any other pointer, a function pointer points to a particular type.
- <span style="background-color:#FFFF00">函数类型(type) is determined by its return type and the types of it  parameters. 与函数名无关(function name is not part of its type)</span>
- we can directly use function pointer without dereference operator
- There is no conversion between pointers to one function type and pointers to another function type.(<span style="background-color:#FFFF00">不同的函数指针之间没有转换规则</span>)
- 可以assign ```nullptr``` or ```zero``` valued integer constant expression to a function pointer 表示function pointer 没有指向任何的function
- when we use an overloaded function, the context must make it clear which version is being used. 当使用overloaded function上下文必须指出选用哪个函数
- <span style="background-color:#FFFF00">function parameter can convert function to function pointer, 但是function return cannot convert function to function pointer</span>

function pointer 括号```(*pf)``` 必不可少, 否则的话是 function returns bool pointer

```c++
bool lengthCompare(const string &, const string &);
// pf points to a function returning bool that takes two const string references 

bool (*pf)(const string &, const string &); // uninitialized


pf = lengthCompare; // pf now points to the function named lengthCompare 

pf = &lengthCompare; // equivalent assignment: address-of operator is optional

pf = 0; // ok: pf points to no function


//三个等价调用

bool b1 = pf("hello", "goodbye"); // calls lengthCompare 

bool b2 = (*pf)("hello", "goodbye"); // equivalent call

bool b3 = lengthCompare("hello", "goodbye"); // equivalent call


string::size_type sumLength(const string&, const string&); 
bool cstringCompare(const char*, const char*);
pf = cstringCompare; // error: parameter types differ 返回类型不匹配

```

对于overloaded function,上下文必须指出选用哪个函数
```c++
void ff(int*);
void ff(unsigned int);
void (*pf1)(unsigned int) = ff; // pf1 points to ff(unsigned)

double (*pf3)(int*) = ff; // error: return type of ff and pf3 don't match

```

**Function Pointer Parameters**: we can write parameter that looks like a function, 但实际上是被treated as pointer.当pass a function as an argument, 它将自动convert to a pointer
```c++
// third parameter is a function type and is automatically treated as a pointer to function

void useBigger(const string &s1, const string &s2,
    bool pf(const string &, const string &));//it is a pointer

    
// equivalent declaration: explicitly define the parameter as a pointer to function

void useBigger(const string &s1, const string &s2,
    bool (*pf)(const string &, const string &));
```

可以用```typedef``` 来避免冗长(tedious), ```Func``` 和```Func2```是函数类型,  ```FuncP``` 和```FuncP2```是pointer类型,注 <span style="background-color:#FFFF00">```decltype``` returns the function type; 不会自动转换成指针类型</span>,如果我们想要pointer, 必须加上```*```
```c++
// Func and Func2 have function type, 是函数类型

typedef bool Func(const string&, const string&); 

typedef decltype(lengthCompare) Func2; // equivalent type


typedef bool(*FuncP)(const string&, const string&);

typedef decltype(lengthCompare) *FuncP2; // equivalent type


// equivalent declarations of useBigger using type aliases

void useBigger(const string&, const string&, Func); 
void useBigger(const string&, const string&, FuncP2);
```

**Returning a Pointer to Function**: 和数组类似，虽然不能返回函数, 但可以返回函数的指针, <span style="background-color:#FFFF00">we must write the return type as a pointer type, compiler will not 自动treat a function return type as pointer type(和function parameter 不一样) </span>

```int (*f1(int))(int*, int);``` <span style="background-color:#FFFF00">f1 is a function 返回的是pointer,返回的有parameter list, so pointer points to a function and that function returns an int</span>

```auto f1 (int) -> int(*)(int*, int);``` 可以用trailing return to make it clear

```c++
using F = int(int*, int); // F is a function type, not a pointer 

using PF = int(*)(int*, int); // PF is a pointer type

PF f1(int); // ok: PF is a pointer to function; f1 returns a pointer to function 

F f1(int); // error: F is a function type; f1 can't return a function

F *f1(int); // ok: explicitly specify that the return type is a pointer to function

```

**Using auto or decltype for Function Pointer Types**

如果我们知道函数返回是哪个一个, 可以用```decltype```简化书写. 需要注意的是,  when we apply decltype to a function, it returns a function type, not a pointer to function type. 需要add ```*``` to indicate that we are returning a pointer not a function

```c++
string::size_type sumLength(const string&, const string&); 
string::size_type largerLength(const string&, const string&);

//根据parameter, getFcn返回是pointer to largerLength or sumLength

decltype(sumLength) *getFcn(const string &);
```

<br/> <br/>  <br/>


## 7. Classes

The fundamental ideas behind classes are **data abstraction** and **encapsulation***(数据抽象和封装). Data abstraction is a programming (and design) technique that relies on the separation of interface and implementation. **Encapsulation** enforces the separation of a class’ interface and implementation, A class that is encapsulated hides its implementation. 一个user只能看见interface, 不能看见implementation

Benefit of Encapsulation: 
1. User code cannot inadvertently corrupt the state of an encapsulated object.用户不会无意间破坏封装对象
2.  The implementation of an encapsulated class can change over time without requiring changes in user-level code. 可以随时改变implementation without 影响用户

#### (a). Abstract Data Types


Functions defined in the classes are <span style="background-color:#FFFF00">implicitly inline</span>. 定义在class 内部的函数都是inline的. function声明必须在函数内部声明, we can define a member function’s body either inside or outside of the class body.

Ordinarily, nonmember functions that are part of the interface of a class should be declared in the same header as the class itself. (<span style="color:red">比如下面的print, read 不是class member 也应该与class 放入一个header</span>)

```c++
struct Sales_data {
    std::string isbn() const { return bookNo; }//定义声明在内部 

    //下面两个function, 声明在struct内部, 但是定义在外部
    
    Sales_data& combine(const Sales_data&); 
    double avg_price() const;

    std::string bookNo;
    unsigned units_sold = 0; 
    double revenue = 0.0;
  };

// nonmember Sales_data interface functions, 定义声明都在外部

Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&); 
std::istream &read(std::istream&, Sales_data&);
```

**this**: 
- ```this``` is a <span style="background-color:#FFFF00">const pointer</span>, we cannot change the address that ```this``` holds. <span style="color:red">```this``` is a constant pointer that holds the memory address of current object. this is not available in static member function </span> 
-  By default, the type of ```this``` is ```const``` pointer<span style="color:red"> to the non const version of the class type</span>(top level const, lower level nonconst).
    - ```*this``` 指reference to object, 而不是const reference to object, 因为```this```没有lower constness
- Member functions access the object through extra, <span style="color:red">implicit</span> parameter named **this**. **this** is initialized with<span style="color:red"> the address of the object</span> which the function (只限于nonstatic) was invoked.
    -  比如 ```total.isbn()``` compiler passes the address of ```total``` to the implicit ```this``` parameter. compiler 会等价的rewrite 为 ```Sales_data::isbn(&total)```(调用Sales_data的isbn的成员时传入total 的地址)
- 在class 函数内部的直接access member of the object, 因为any direct use of a member of the class is assumed to be an implicit reference through ```this```(任何对类成员直接访问都被看作this的隐式引用)
    - ```bookNo``` It is as if we write ```this->bookNo```
- It's illegal to define a parameter or variable named ```this```.

**const Member Functions**
- ```const``` is to modify the type of the implicit ```this``` pointer, 表示 ```this``` is a pointer to ```const```. Member function that use ```const```被称为<span style="color:red">const member functions</span>
- <span style="background-color:#FFFF00">Cannot bind ```this```（this 没有low level const） to a ```const``` object, 同时 const object (```this```有lower const) cannot call an ordinary member function (```this```没有lower const) </span>(lower const -> no lower const的 不可以, const function call ```this``` is a const pointer to const object, 而non-const function的```this``` 是const pointer to nonconst obejct). ; 
    - 比如```const A a; a.get();//error when get is not const function``` 
    - 所以把不改变object 的<span style="background-color:#FFFF00">function 设置成const, 可以提高函数灵活性</span>
- const function 表示```this``` is a pointer to ```const```, <span style="background-color:#FFFF00">const member functions cannot change the object on which they are called</span>. 因此const function 不能write to data members of the objects 只能read
- <span style="background-color:#FFFF00">Objects that are const, and references or pointers to const objects, may call only const member functions.</span> 

**Defining a Function to Return “This” Object**: 下面例子```total``` 被绑定到```this```, ```rhs``` 被绑定到```trans```上, 


```c++
Sales_data& Sales_data::combine(const Sales_data &rhs)
{
units_sold += rhs.units_sold; 
revenue += rhs.revenue; 
 return *this; // return the object on which the function was called

//use this to access the object as a whole

}

total.combine(trans); 
```


#### (b), Access Control and Encapsulation

A class may contain zero or more access specifiers(private, public), and there are no restrictions on how often an access specifier may appear.

The only difference between using class and using struct to define a class is the default access level and 继承是public and private. 

定义private encapsulation 的优点:
- 通过定义data private, 作用可以自由修改数据,只要interface 不变，用户代码不变，但是如果the data are public, then any code that used the old data members 也许brokern. 需要rewrite any code that relied on old representation 后才能使用
- 另一个定义private 优点.data are protected from mistakes that users might introduce, 防止因为用户原因数据被破坏, 如果发现bug corrupt object state, 发现bug位置是本地, 就去implementation差错, 而不用看用户的code, 降低了维护的难度


**friend**: 
- A class can allow another class or function to <span style="background-color:#FFFF00">access its nonpublic members</span> by making that class or function a **friend**. 
- Friend declarations may appear only inside a class definition. 友元声明只能在class 内部 (好的编程习惯是: 集中在程序开始或者结尾集中定义友元)
- <span style="color:red">如果Friend function定义在class 内部是**inline function**</span>
- <span style="background-color:#FFFF00">friend declaraction 仅仅specifies access, 而不是general declaration of the function</span>, <span style="color:red">如果我们想要users able to call friend function, 需要declare the function separately from the friend declaration</span>. 让friend visible to users, we usually **declare each friend (outside the class)** in the same header as the class itself. 

#### (c). Additional Class Features

- inline member functions should be defined in the same header as the corresponding class definition
- **mutable Data Members**: <span style="background-color:#FFFF00">a mutable data member is never const even when it is a member of a const object(即使是const 对象成员,也不是const), a const member function of class may change a mutable member </span>
- <span style="color:red">When we provide an in-class initializer, we must do so following an = sign or inside braces.</span>
- <span style="background-color:#FFFF00">A const member function that returns *this as a reference should have a return type that is a reference to const```const class & ```.</span>
- <span style="background-color:#FFFF00">可以overload function 基于是不是const </span> (match rule 跟function overloading match rule 类似)
  - <span style="color:red">const object 只能call const function, 不能call nonconst function</span>
  - <span style="color:red">nonconst obeject 可以call non-const 也可以call const version， 但是nonconst version 是better match(因为exact match 优于const version)</span>

下面初始化Screen, class 内部初始化要么使用```=``` 在class内部初始化, or the direct form of initialization using ```{}```
```c++
class Screen{
public: 
    typedef std::string::size_type pos;
    Screen() = default; // needed because Screen has another constructor 
    
    // cursor initialized to 0 by its in-class initializer

    Screen(pos ht, pos wd, char c): height(ht), width(wd), contents(ht * wd, c) { }
    //定义在class内部函数, inline, we don't need to specify inline, 但也可以specify


    char get() const // implicitly inline 定义在class 内部都是inline (implictly)

        { return contents[cursor]; } 

    inline char get(pos ht, pos wd) const; // explicitly inline

    Screen &move(pos r, pos c); // can be made inline later

private:
    pos cursor = 0;
    pos height = 0, width = 0; std::string contents;
    mutable size_t access_ctr; // may change even in a const object / const member function

}

std::vector<Screen> screens{Screen(24, 80, ' ') };

```

如果```move``` 和 ```set``` 返回都是class的reference(```*this```),
```c++
inline Screen &Screen::set(char c)
{
    contents[cursor] = c; 
    return *this;
} 

//则可以用

myScreen.move(4,0).set('#');
```
如果```move``` 和 ```set``` 返回都是class, 而不是reference
```c++
Screen temp = myScreen.move(4,0)
temp =  temp.set('#');
```
```const function```不能返回 nonconst的reference. 因为const function 的```*this``` is ```const Screen&```,```const Screen&``` 不能转换成```Screen&```(initialization rule). 所以```const```  function, 只能返回```const``` reference. 而```const``` reference 指的const object 不能call ordinary function (cannot conver from (const pointer to const) to (const pointer to nonconst) )

```c++
//error

Screen& display(cout) const {
   return (*this);
}

//correct

const Screen& display(cout) const {
   return (*this);
}


Screen myScreen;
// if display returns a const reference, the call to set is an error 

myScreen.display(cout).set('*');
```

Const function overload, <span style="background-color:#FFFF00">object 是不是const, 决定call 哪个display function.</span>. when ```display```calls ```do_display```, ```*this``` pointer is implicitly passed to ```do_display```. 对于nonconst version of ```display```calling, <span style="background-color:#FFFF00">```*this``` pointer implicitly converted from a const pointer to nonconst to a const pointer to const </span>, 当```do_display```完成后，nonconst version, ```*this``` is a ordinary(普通的, non-const) reference, the const member ```*this``` a const reference.

```c++
class Screen { 
public:
// display overloaded on whether the object is const or not 

Screen &display(std::ostream &os)
    { do_display(os); return *this; } 
const Screen &display(std::ostream &os) const
    { do_display(os); return *this; }

private:
// function to do the work of displaying a Screen

void do_display(std::ostream &os) const {os << contents;} //inline implicitly 

//call这个function, 不会带来额外的开销(no run-time overhead)

};
```

**Class Types**: 
- Every class defines a unique type, <span style="color:red">即使两个different types define the same members 他们也是不同类型的</span>. The members of each class are distinct from the members of any other class (or any other scope).
- 声明class/struct <span style="color:red">object</span> 也可以用 ```class Screen a```
- 可以只声明class 而不定义class, like ```class Screen;```, 这种声明叫做**forward declaration**, 但在它声明之后 定义之前是一个**incomplete type**, 因为<span style="color:red">不清楚它包含哪些成员</span>
  - **imcomplete type** can be used in limited ways: define <span style="color:red">pointers</span> or <span style="color:red">references</span> to such types, 也可以定义functions that use an incomplete type as a <span style="color:red">parameter</span> or <span style="color:red">return type </span>
- <span style="background-color:#FFFF00">A class 必须被defined 而不仅仅是声明before we creats objects of that type</span>. 因为compiler 需要know storage such objects need. 同理, a class 必须被定义before access a member of the type by using reference or pointer. 如果不定义, compiler cannot know 它有什么member
- <span style="background-color:#FFFF00">A class member 可以有pointers or references of its own type. 因为class is considered declared (not yet defined) as soon as its class name has been seen</span>. 但是 <span style="color:red">a class cannot have members ot is own type</span> 因为compiler 需要知道storage data memebers require, class is not defined until its class body is complete,

```c++
struct First { int memi;
int getMem();
};
struct Second {
int memi;
int getMem();
};

First obj1;
Second obj2 = obj1; // error: obj1 and obj2 have different types

```

```c++
Sales_data item1; // default-initialized object of type Sales_data class 

class Sales_data item1; // equivalent declaration

```



**Friend Class**: 
- <span style="background-color:#FFFF00">friendship is not transitive</span>, 比如下面例子中 ```Window_mgr```有自己的friends, those friends 没有access to ```Screen```
- 还用只声明一个class 的function 有friend 权限, Making a member function a friend 需要仔细设计程序, 下面例子中
  - 首先定义class ```Window_mgr```. 其中声明但不定义```clear``` functinon，
  - 再定义class ```Screen```, including a friend declaration for ```clear```
  - 最后define ```clear``` 此时才可以使用```Screen```的成员
- friend / nonmember function 不需要在 用到他们的friend declaraction 声明之前, 当一个<span style="background-color:#FFFF00">名字appear in a friend declaration</span>, 这个名字是<span style="background-color:#FFFF00">implicitly assumed to be part of the surrounding scope</span>(在友元中出现的名字,是被假设可见的); 但反过来不行, friend 即使define in the class,<span style="background-color:#FFFF00"> 我们也必须提供一个declaration outside the class</span> itself to make that function visible. <span style="color:red">一个友元的outside declaration 必须在call 友元function 前的member function前面</span>, 所以用到友元的function 最好放在class 外面定义 (some compilers do not enforce the lookup rules for friends）

```c++
class Screen{
    friend class Window_mrg; 
    //Window_mrg可以access Screen Class的所有数据


    friend void Window_mgr::clear(ScreenIndex); 
    //只声明class 一个clear function 有friend 权限, 但是clear需要declare before Class Screen 

}
```

下面函数
```c++
extern std::ostream& storeOn(std::ostream &, Screen &);//声明成友元

extern BitMap& storeOn(BitMap &, Screen &); 
//接受BitMap & 的storeOn, 对Screen 没有访问权限对private / public

class Screen {
// ostream version of storeOn may access the private parts of Screen objects

friend std::ostream& storeOn(std::ostream &, Screen &);
};
```

friend function scope
```c++
struct X {
    friend void f() { /* friend function can be defined in the class */ }
    
    X() { f(); } // error: no declaration for f void g();

    void h();
};
void X::g() { return f(); } // error: f hasn't been declared

void f(); // declares the function defined inside X 

void X::h() { return f(); } // ok: declaration for f is now in scope

```

#### (d). Class Scope
- class 外部访问public data/function，只能通过object, reference, pointer; <span style="color:red">type members(typedef) from the class 可以访问 using the scope operator.</span>
- 在class 外部定义function, 
   - 需要provide class name :: function name. function定义就可以随便用class member without using class name (因为everyname is seen in class scope)
   - function return type 声明在 class name 前, so any return type is outside scope, 因此<span style="color:red">return type需要specify class name, 如果return type is defined inside class</span>

```c++
class Window_mgr { 
public:
    // add a Screen to the window and returns its index 

    ScreenIndex addScreen(const Screen&); 
};
// return type is seen before we're in the scope of Window_mgr

Window_mgr::ScreenIndex Window_mgr::addScreen(const Screen &s)
```

**(1).name lookup**: the process of finding which declarations match the use of a name
1. Look for declaration of the name in the block (before use of name) which the name was used. 只在名字出现在块中(使用之前的)查找
2. 如果名字没有发现, look in the enclosing scope（继续查找外层作用域)
3. if no declaration found, program is error

class defintion are processed in order of : 
1. memeber declarations are compiled (先编译成员声明)
2. function bodies/definitions are processed and compiled only after the entire class has been seen (<span style="background-color:#FFFF00">直到class全部可见后,编译函数体</span>)

- 因为函数体直到class 可见后 才compiled. 所以function 可以用任何name defined inside the class. 假如function definition 和member declaration 同时进行, function只能用已经被看见的名字
- <span style="color:red">上面的two-step process 只适用于member function bodies</span>, Names used in declarations, 包括了<span style="background-color:#FFFF00">return type and types in parameter list 必须被看见before they are used</span>. 否则会报错
- <span style="color:red">tips:</span>: 定义type names (typedef, using) 通常在class beginning, 这样any member that uses that type will be seen after the type name has been already been defined

看到```balance``` function, 寻找```Money```的声明,先看在Account class中是否声明, 没有. 再寻找declaration in enclosing scope(外层作用域). 找到typedef 的```Money```; 另一方面, <span style="color:red">因为在class is seen之后```balance```才processed, 所以返回的bal 是class(double)的</span>, 而不是外层作用域的string
```c++
typedef double Money; 
string bal;
class Account { 
    public:
        Money balance() { return bal; }
    private:
        Money bal; 
};
```

**(2).Type Names Are Special**: 一般来说, inner scope can redefine a name from an outer scope (out scope names is hidden). 但是对于type 不行, <span style="color:red">class inner scope cannot redefine a typename </span> class 不能重新定义type, 如果这个type 被member function parameter/return 使用(typedef redefine 可以在VS中, 但不适用于linux) 

```c++
typedef double Money;
class Account {
public:
    Money balance() { return bal; } 
    // uses Money from the outer

private:
    typedef double Money; // error: cannot redefine Money

    Money bal;
};
```

比如下面的例子, in class and outside 都有typedef, 但是function 对同一个typedef用到不同的type, extremely confusing, 所以standard bans it 
```
using Foo = int;

struct X {
    Foo a;    // ::Foo, i.e., int
    
    void meow() { 
        Foo b = a; // X::Foo; error: no conversion from int to char*
	
    }
    using Foo = char*;
};
```

**(3). Normal Block-Scope Name Lookup inside Member Definitions**

A name used in the body of a member function is resolved as follows:(一般不建议use the name of another member as the name for function parameter, 不建议使用成员的名字用作函数参数)
1. 首先在member function内部寻找(在name 被使用之前部分)
2. 如果没有找到, 再到class 内部继续寻找declaration. All the members of the class are considered (class所有成员都被考虑)
3. 如果没有找打, look for a declaration that is in scope before the member function defintiion. (在函数定义前的作用域, 因为函数可能定义在class外部(in file) ) 

当compiler 处理dummy_fcn 的乘法时， 首先寻找 ```height```  in the scope of that function. 从parameter中找到
```c++
// note: this code is for illustration purposes only and reflects bad practice

// it is generally a bad idea to use the same name for a parameter and a member

int height; // defines a name subsequently used inside Screen

class Screen {
public:
    typedef std::string::size_type pos; 
    void dummy_fcn(pos height) {
        cursor = width * height; // which height? the parameter 
        
    }
private:
    pos cursor = 0;
    pos height = 0, width = 0;
};

```

上面例子中```height``` 隐藏了member named ```height```. 如果我们想override the normal lookup rules, 可以如下, 如果想使用outer class 外层作用域的, 可以用scope operator ```::```

```c++
//Case 1: class member height

// bad practice: names local to member functions shouldn't hide member names 

void Screen::dummy_fcn(pos height) 
{
cursor = width * this->height; // member height 

// alternative way to indicate the member

cursor = width * Screen::height; // member height

}

//Case 2: use class member 

// good practice: don't use a member name for a parameter or other local variable 

void Screen::dummy_fcn(pos ht) {
cursor = width * height; // member height 

}

//Case 3:  Use global

// bad practice: don't hide names that are needed from surrounding scopes 

void Screen::dummy_fcn(pos height) {
cursor = width * ::height;// which height? the global one 

}
```

注意 ```verify``` is not visible before the definition of the class screen. 但是第三步lookup includes the scope where member definition befores. 因为```verify```在```setHeight```前定义,因此找到
```c++
int height; // defines a name subsequently used inside Screen 

class Screen {
public:
    typedef std::string::size_type pos;
    void setHeight(pos);
    pos height = 0; // hides the declaration of height in the outer scope

};
Screen::pos verify(Screen::pos); 

void Screen::setHeight(pos var) {
// var: refers to the parameter

// height: refers to the class member

// verify: refers to the global function 

    height = verify(var);
}

```




#### (e). Constructors Revisited


**Constructors** 
- constructor  run whenever an object of a class type is created.只要class的对象被创建, 就会执行constructor
- Unlike other member functions, <span style="background-color:#FFFF00">constructor 不能被declared as const</span>. <span style="color:red">When we create a **const** object of a class type, the object 直到constructure completes the object's initialization 才获得constness 属性 </span>. constructors initialize const objects during their construction.
- Classes control default initialization by defining a special constructor, known as the **default constructor**: is one that takes no arguments.
  - <span style="background-color:#FFFF00">**default constructor** 是constructor work without any argument(either no parameters, or all parameters have default values)</span>; 错误的概念是constructor with no parameters; 比如```dog(string name = “Bob”); ```属于can work without any argument, 但有default parameter
  - 如果没有explicitly define any constructors, <span style="color:red">compiler will implicitly define and generate the default constructor</span> known as the <span style="background-color:#FFFF00">**synthesized default constructor**</span>, 对于大多数class, this synthesized constructor initializes each data member as follows: 
    - 如果there is an in-class initializer, 用default constructor without parameters initialize member(如果存在class的初始值,用初始值初始化成员) 比如class 中```string a = "dog";```
    - Otherwise, default-initialize the member(否则, 默认初始化成员),比如class 中```string a;``` 默认初始化为空
    -  如果不支持默认初始化, your default constructor should use the **constructor initailizer list** to initialize every member of the class (e.g. ```sale(): a(0) {}```)
  - ```Sales_data() = default;``` 让compiler generate default constructor: <span style="color:red">The = default can appear with the declaration inside the class body or on the definition outside the class body(既可以和声明出现在class 内部, 也可以作为定义出现在class 外部)</span>. <span style="background-color:#FFFF00">如果用```=default``` inside class, the default constructor will be **inlined**. 如果出现在definition outside the class, the member will not be inlined by default </span>
- constructor 不应该override in-class initializers except to use a different initial value.

**Some Classes Cannot Rely on the Synthesized Default Constructor**
- <span style="color:red">只有我们没有声明任何的constructor，compiler 才会generates **synthesized default constructor**, 如果有自己定义constructor， 除非自己定义default constructor, 否则不会生成
- 第二原因是: synthesized default constructor does the wrong thing, 比如数组或者指针对象被默认初始化, 他们值是未定义的. 所以当class has compound type (pointer or array) or built-in 应该有自己定义的constructor, 否则有 undefined value 
  - <span style="color:red">Classes that have members of built-in or compound type usually should rely on the synthesized default constructor only if all such members have in-class initializers.</span>
- 第三个原因是: some classes must define their own default constructor <span style="color:red">是因为有时候compiler is unable to systhesize one</span>. 比如一个class has member which is class type, and that class doesn't have a default constructor, then compiler can't initialize that memeber, 对于这个种情况, 必须定义自己的constructor

如果我们不定义Copy, Assignment, and Destruction, compiler也许会synthesize them for us. <span style="color:red">对于class的vector or string, compiler generated 的 copy, assignment, destructor works correctly</span>, 因为we copy or assign an object that has a vector member, the vector class takes care of copying or assigning the element. 当object is destroyed, the vector member is destroyed which 反过来destroys the elements in vector.


**(1). Constructor Initializer List**


Assignment 和 initialization 是不同的: <span style="background-color:#FFFF00">在class 中, Assignment是先初始化 再赋值， initialization是直接初始化</span>, 比如下面例子, How significant the distinction between initialization and assignment 由data member 类型决定

```c++
//is Initialization

class data{
    double revenue = 0.0; 
    string bookNo; 
};

//Is Assignment

class data{
    double revenue; 
    string bookNo;
    data(const string & a, double price){
        bookNo = a;
        revenue = price;
    } 
};
```

- <span style="color:red">必须用**constructor initializer list**  to privide values for members that are const, reference, or a class type that does have a default constructor</span>,const, reference 是必须initialized的
  - <span style="background-color:#FFFF00"> 如果member 有 const or reference, 不会有default constructor, 必须要Initialized using constructor initialization list</span>
  -  **constructor initializer list** specifies only the values used to initialize the members, not the order. **constructor initializer list**没有说明初始化的order
-  <span style="background-color:#FFFF00">class members are initialized 与他们在class 出现的顺序一致, **constructor initializer list** order 不会影响他们实际初始化的顺序</span>
   -  一般顺序不matter, 但是如果一个成员用另一个成员初始化后的值, order 就matter了 (有些compiler 会有warning)
   -  最好write **constructor initializer** in the same order as members are declared in class. 其次避免using members to initialize other members
 
```c++
class ConstRef { 
public:
    ConstRef(int ii); 
private:
    int i, &ri;
    const int ci;
};

// ok: explicitly initialize reference and const members 

ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) { }
```

Order of Initialization, 下边例子中, **constructor initializer list** 让 ```j``` is initialized then ```i```. <span style="color:red">但实际上是i先initialized, 但是当initialized 时 with the undefined value of j</span>
```c++
class X{
    int i;
    int j;
public: 
    // undefined: i is initialized before j

    X(int val): j(val), i(j){}
};
```

**(2) Delegating Constructor(委托构造函数)**: 

- <span style="background-color:#FFFF00">A **delegating constructor** uses another constructor from its own class to perform its initialization</span>
- In a delegating constructor, the member initializer list has single entry to call the same class another constructor. 
- When a constructor delegates to another constructor, 先run delegated-to constructor 之后才把control returned to the function body of delegating constructor

```c++
class Sales_data {
public:
    // nondelegating constructor initializes members from corresponding arguments 
    
    Sales_data(std::string s, unsigned cnt, double price):
            bookNo(s), units_sold(cnt), revenue(cnt*price) {}

// remaining constructors all delegate to another constructor

Sales_data(): Sales_data("", 0, 0) {} 
Sales_data(std::string s): Sales_data(s, 0,0) {} 
Sales_data(std::istream &is): Sales_data() {read(is, *this); }
};
```

**(2) Role of Default Constructor**: 

<span style="background-color:#FFFF00">The default constructor is used automatically whenever an object is default or value initialized</span>. Default initialization happens: 
1. when we define nonstatic varaibles or array without initializers
2. When a class that itself has members of class type uses the **synthesized default constructor**
3. When members of class type are not explicitly initialized in a constructor initializer list 

Value initialization happens: 
- Array Initilization, 当提供的初始值  fewer than its size
- <span style="background-color:#FFFF00">when we define a local static object without an initializer</span>
- 当我们书写```T()```的表达式explicitly request value initialization where ```T``` is the name of a type (比如vector constructor takes a single argument to specify vector's size) 

```c++
class NoDefault { 
public:
    NoDefault(const std::string&);
    // additional members follow, but no other constructors 

};

struct A { 
    NoDefault my_mem;
};
A a; // error: cannot synthesize a constructor for A 


struct B {
    B() {} // error: no initializer for b_member 
    
    NoDefault b_member;
};
```

错误declare object

```c++
Sales_data obj(); // error:  declare a function, not an object

//表示a function taking no parameters and return type is Sales_data

Sales_data obj;
```


**(3). Implicit Class-Type Conversions**

-  constructor that can be called with **single argument** defined an **implicit conversion** (有时候叫 **converting constructors**)
    - 定义了conversion from constructor's parameter type to class type.
- <span style="background-color:#FFFF00">只允许一步conversion</span>, 比如constructor take a string parameter, 我们不可以用```const char*``` 到string 再到class type
- **explicit**: prevents implicit conversion. <span style="background-color:#FFFF00">explicit meaningful only on constructor that can be called with a single constructor.</span>.
    - <span style="color:red">**explicit** is used only on constructor declaration inside the class.</span> It is not repeated on a definition outside class body.  
    -  对于constructor that require more arguments 不会perform implicit conversion,所以没有用explicit的必要性
    - **explicit** 只能用于direct initialization, 不能用于copy initialization 
    - compiler will not do implicit conversion for **explicit**, but we can use 有**explicit** constructor to force a conversion (比如```static_cast```)

e.g. ```string -> Sales_data```, compiler automatically creates a temporary ```Sales_data``` object from ```string``` then pass to ```combine```. 因为```combine``` take const reference, we can pass tempoary object
```c++
struct Sales_data {
    Sales_data(std::string s): Sales_data(s, 0,0) {} 
    Sales_data(std::istream &is): Sales_data() {read(is, *this); }
    Sales_data& Sales_data::combine(const Sales_data &rhs)
    {
        units_sold += rhs.units_sold; 
        revenue += rhs.revenue; 
        return *this; // return the object on which the function was called 
		
    }
  };

string null_book = "9-999-99999-9";
item.combine(null_book);

// error: requires two user-defined conversions: 

// (1) convert "9-999-99999-9" to string

// (2) convert that (temporary) string to Sales_data 

item.combine("9-999-99999-9");

//one step implicit type conversion 

// ok: explicit conversion to string, implicit conversion to Sales_data

 item.combine(string("9-999-99999-9"));
 // ok: implicit conversion to string, explicit conversion to Sales_data 
 
 item.combine(Sales_data("9-999-99999-9"));
```

**explicit**
```c++
class Sales_data { 
public:
    Sales_data() = default;
    Sales_data(const std::string &s, unsigned n, double p):
        bookNo(s), units_sold(n), revenue(p*n) { } 
    explicit Sales_data(const std::string &s): bookNo(s) { } 
    explicit Sales_data(std::istream&);
};

item.combine(null_book); // error: string constructor is explicit 

item.combine(cin); // error: istream constructor is explicit

```

explicit 只用于declaration inside class, not for definition outside class 
```c++
// error: explicit allowed only on a constructor declaration in a class header 

explicit Sales_data::Sales_data(istream& is)
{ read(is, *this);}
```

<span style="color:red">explicit 只能用于direct initialization, not for copy initialization</span> 
```c++
Sales_data item1 (null_book); // ok: direct initialization

// error: cannot use the copy form of initialization with an explicit constructor 

Sales_data item2 = null_book;
```

可以用 有explicit constructor to <span style="color:red">force conversion</span>, ```static_cast``` to perform an explicit, rather than an implicit conversion. 用```static_cast``` uses the ```istream```constructor to construct temporary ```Sales_data``` object 
```c++
// ok: the argument is an explicitly constructed Sales_data object 

item.combine(Sales_data(null_book));
// ok: static_cast can use an explicit constructor

item.combine(static_cast<Sales_data>(cin));
```

**(4). Aggregate Classes**

An **aggregate class** gives users direct access to its members and has special initialization syntax. A class is an aggregate if 
- All of its data members are public (所有public)
- It does not define any constructors (没有定义任何constructor)
- It has no in-class initializers (没有class 内部数据初始值)
- It has no base classes or virtual functions. (没有base class 和 virtual)

An aggregate class 可以:
- An aggregate class can define member functions
- An aggregate class can overload operators.

Initialization: 
- we can initialize the data members of an aggregate class <span style="background-color:#FFFF00">by providing a braced list of member initializers</span>
- <span style="color:red">Initializer的**order** 必须与declaration of data members 一样</span>
- 如果提供的elements are fewer than class members, <span style="color:red">the trailing members are value initialized</span>

Aggregate class 的Initialization **Drawbacks**: 
1. Requires that all data members of class be <span style="color:red">**public**</span>
2. 将正确初始化的重任(burden)给了user. <span style="color:red">**error-prone**</span>, 因为用户容易忘记值, 或者提供一个不正确的初始值 
3. If a member is added or removed, all initialization have to be updated.


Example of aggregate class
```c++
struct Data{
    int ival;
    string s;
}

// val1.ival = 0; val1.s = string("Anna") 

Data val1 = { 0, "Anna" };
```

**(5). Literal Classes**

- A **literal type** is a type that can <span style="color:red">qualify as constexpr</span>. This is true for scalar types, references, certain classes, and arrays of any such types.
   - **scalar type** 包括了 
      - arithmetic (integral, float)
      - pointers: T * for any type T (比如pointer to a class is scaler type 但是这个class 本身不是scalar type)
      - enum
      - pointer-to-member (object pointer, function pointer, nullptr_t)


**literal clasess** 标准 if it is :
- a scalar type or  
- a reference type or 
- a array of iteral type or 
- a class types of following properites
    - all of its non-static data members and base classes are of literal types.
    - it is an aggregate type or has at least one ```constexpr``` constructor (至少有一个class type) or constructor template that is not a copy or move constructor, and
    - every constructor call and full-expression in the brace-or-equal-initializers for non-static data members (if any) is a constant expression 
    - it has a trivial destructor (default destructor 自己不定义destructor or use keyword ```default```)
    

<br/>
- 如果是**aggregate class**, 则class data members are of literal type is a literal class. 
- 如果 是nonaggregate class, 则需要满足下列要求: 
  - data members all must literal type
  - The class must have <span style="background-color:#FFFF00">at least one ```constexpr``` constructor</span> 
  - If a data member has an in-class initializer, the initializer for a member of built-in type must be a [constant expression](#Constexpr). 如果不是built-in type, the initializer must use the member's own ```constexpr``` constructor.  
  - The class must use default definition for its destructor (default destructor), which is the member that destroys objects of the class type.

```constexpr``` parameter 和 return type 必须是 **literal type**. class that are **literal type** 也许有funcition members that are **constexpr**(需要meet all requirements of ```constexpr``` function, 这些function 也是<span style="color:red">**implicitly const**</span>)

**constexpr Constructor**
- **constexpr constructor** can be declared as ```= default``` (or ```= delete```)的形式. 
- 如果没有用```=default```, <span style="background-color:#FFFF00">需要meet requirements of constructor(no return statment) and ```constexpr function```</span>(the only executable statement it can have is return statment(only one return)), <span style="color:red">所以通常上body of **constexpr constructor** (body)  is empty</span>
- <span style="color:red">**constexpr constructor** must initialize every data member.</span> The initializers 必须either **constexpr constructor** or a constant expression 
- A **constexpr constructor** is used to generate objects that are ```constexpr``` and for parameters or return types in constexpr functions(用于生成```constexpr```对象以及```constexpr``` 函数的参数或返回类型)

```c++
class Debug { 
public:
    constexpr Debug(bool b = true): hw(b), io(b), other(b) {}
    constexpr Debug(bool h, bool i, bool o):
        hw(h), io(i), other(o) {}
    constexpr bool any() { return hw || io || other; } 
    void set_io(bool b) { io = b; }
    void set_hw(bool b) { hw = b; }
    void set_other(bool b) { hw = b; }
private:
    bool hw; // hardware errors other than IO errors 
    
    bool io; // IO errors

    bool other; // other errors
};
```

```c++
constexpr Debug io_sub(false, true, false); // debugging IO

if (io_sub.any()) // equivalent to if(true)

    cerr << "print appropriate error messages" << endl;

constexpr Debug prod(false); // no debugging during production 

if (prod.any()) // equivalent to if(false)

    cerr << "print an error message" << e
```


Definitions of constexpr constructors must satisfy the following requirements(from IBM):

- The containing class must not have any virtual base classes(used in virtual inheitance).
- Each of the parameter types is a literal type.
- Its function body is = delete or = default; otherwise, it must satisfy the following constraints:
   - It is not a function try block.
   -  The compound statement in it must contain only the following statements(除了return的语句可以是):
         - null statements
         - static_assert declarations
         - typedef declarations that do not define classes or enumerations
         - using directives
         - using declarations
- Each nonstatic data member and base class subobject is initialized.
- Each constructor that is used for initializing nonstatic data members and base class subobjects is a constexpr constructor.
Initializers for all nonstatic data members that are not named by a member initializer identifier are constant expressions.
- When initializing data members, all implicit conversions that are involved in the following context must be valid in a constant expression:
   - Calling any constructors
   - Converting any expressions to data member types

#### (f). Static Members

- static member can be public or private. The type of ```static``` data member can be ```const```, reference, array, class type. 
- private static member 只能被member function call,不能被outside class用
- static members of a class exist outside any object.Object do not contain data associated with static data members
- static member functions 不与对象绑定(bound)在一起.  因此<span style="background-color:#FFFF00">static member function 不能declared as const function</span>. static member functions <span style="color:red">don't have ```*this``` pointer.不能用```*this```在static member 中</span>, This restriction适用于explicit use of ```this``` and implicit use of ```this``` by calling a nonstatic member.
- can use scope operator to access static member ```Account::initRate```, 也可以通过object, reference, pointer of class type to access 
- <span style="color:red">member function can use static member directly</span> without scope operator

```c++
class Account{
public:
   void calculate() { amount += amount * interestRate; }
   static double rate() { return interestRate; }
   static void rate(double);
private:
   std::string owner;
   double amount;
   static double interestRate;
   static double initRate();
   //银行利率 需要apply给所有user, 用static
   
};
```

```c++
double r;
Account ac1;
Account *ac2 = &ac1;
// equivalent ways to call the static member rate function

r = ac1.rate(); // through an Account object or reference

r = ac2->rate(); // through a pointer to an Account object

```

**Define Static Members**
- 因为static data members 不是 part of objects of class type, 他们并不是在create object是被定义的. They are <span style="color:red">not initialized by class constructor</span>, 
- 不能initialize static member inside class, 必须<span style="background-color:#FFFF00">define and initialize static data member outside class body</span>
- 和其他object一样,static data member只能被定义一次 (好习惯是 把所有static member的definitions 和所有noninlin member functions的定义放在一起)
- 可以define static member function 在class内部或者外部.如果在外部define, 不用加上 ```static``` keyword


下面例子initialize static ```interestRate```例子, Once the class name ```Account``` is seen, we can use ```initRate``` without qualification as the initializer for ```rate```. Note 尽管```initRate``` is private, 可以用它initialize ```interestRate```. 
```c++
//不需要static keyword to define static member

void Account::rate(double newRate)
{
interestRate = newRate;
}

//initialize static data member

double Account::interestRate = initRate();
```

**In-Class Initialization of static Data Members**
- 通常static members不能intialized in class body. 但可以为static members 提供  <span style="color:red">**const integral type**</span>的in-class initialzers,  不过必须要求static mmembers必须是 <span style="color:red">**constexpr of literal type**</span>.
   - initializer 必须是**constant expression**
- 如果某个static member 仅限于compiler可以替换它的值, then 一个初始化的const or constexpr static 不需要分别定义. 如果将它用于值不能替换的场景中, then 该成员必须有一个定义语句 
   - 例如下面例子中, 用到```period```的地方仅仅是```daily_tbl```, there is no need to define ```period``` outside class ```Account```, 但是程序细微的改变不能造成无法编译, 因为找不到该成员定义. e.g. pass ```period``` to a function that takes a ```const int&``` then peiord must be defined 
- 如果an initializer provided inside class, <span style="background-color:#FFFF00"> member definition outside class 不能specify an initial value</span>
- 好的编程习惯是: Even if a const static data member is initialized in the class body, that
member ordinarily should be defined outside the class.

```c++
class Account {
public:
   static double rate() { return interestRate; }
   static void rate(double);
private:
   static constexpr int period = 30;// period is a constant expression

   double daily_tbl[period];
};

// definition of a static member with no initializer

constexpr int Account::period; // initializer provided in the class

```

**static Members Can Be Used in Ways Ordinary Members Can’t**

- 因为static member 是不跟object 绑定, 所以static data member 可以是incomplete type. static data member 可以是the same type as the class type, A non-static member 不可以这样declared, 只可以declare reference or pointer to an object of its class
- we can use static member as <span style="color:red">**default argument**</span>. (非static data member不能被使用为default argument 因为its value is part of the object, 看见parameter时, class declaration 还没有完成, so is an error) 

```c++
class Bar {
private:
   static Bar mem1; // ok: static member can have incomplete type
   
   Bar *mem2; // ok: pointer member can have incomplete type
   
   Bar mem3; // error: data members must have complete type
   
};
```
拿static member as default argument 
```c++
class Screen {
public:
// bkground refers to the static member

// declared later in the class definition

   Screen& clear(char = bkground);
private:
   static const char bkground;
};
```

<br/><br/><br/>

## 8. IO Library

#### (a). IO Classes

|  Header     | Type |
|   ---      | :---    |  
| iostream |  istream, wistream reads from a stream <br/> ostream, wostream writes to a stream <br/> iostream, wiostream reads and writes a stream  | 
| fstream |  iftream, wifstream reads from a file <br/> ofstream, wofstream writes to a file <br/> fstream, wfstream reads and writes a file  | 
| sstream |  istringstream, wistringstream reads from a string <br/> ostringstream, wostringstream writes to a string <br/> stringstream, wstringstream reads and writes a string  | 

为了支持wide characters,library defines types and objects 用来操作 ```wchar_t``` data. e,g, ```wcin```,```wcout```, ```wcerr```. wider character types and objects 定义在same header, 所以比如 ```fstream``` 有```ifstream```, 也有```wifstream```.

- <span style="background-color:#FFFF00">ifstream and istringstream inherit from istream, 因次可以像使用istream对象一样使用```ifstream``` 和 ```istringstream```</span>, 同样, <span style="background-color:#FFFF00">ofstream and ostringstream inherit from ostream</span> , 所以他们用```cin```, ```cout```的方法都是一样的,


**(1). No Copy or Assign for IO objects**

- 因为IO 不能符号或者赋值, 所以 不能有parameter or return type 是 IOStream types. 对IO操作的function <span style="background-color:#FFFF00">通常通过reference的方式pass and return</span>
- <span style="color:red">因为Reading or writting IO object change its state</span>, 因此<span style="background-color:#FFFF00">reference must not be ```const```</span>

```c++
ofstream out1, out2;
out1 = out2; // error: cannot assign stream objects

ofstream print(ofstream); // error: can't initialize the ofstream parameter

out2 = print(out2); // error: cannot copy stream objects

```

**(2). Condition States**

- 因为IO操作会可能发生错误, 一些错误是可以恢复的, 而另一些错误已经到了系统深处(deep within the system),已经超过程序可以修改的范围. IO classes 定义了一些functions and flags 让我们access and manipulate the condition state of a stream
- 一旦stream 发生错误, 后续的IO 操作都失败, 比如```int a; cin>>a``` 却输入了string. 简单方法是check the stream is okay before attempint to use, 下面的while <span style="color:red">check the state of stream returned from ```>>``` expression</span> . 如果成功再继续
  - while 只告诉valid or not, not telling why invalid 
- ```iostate``` used to convey information about the state of a stream. <span style="background-color:#FFFF00">This type used the collection of bits.</span> IO 定义了四个```constexpr```values of type ```iostate```
  - 一旦```badbit``` set, 不能再使用stream了,
  - ```failbit``` set after recoverable error, 比如读了个char when nuemric expexted. Possible to correct problems and continue using the stream
  - ```goodbit``` guaranteed to have value 0, 表示no failures on stream.
  - 如果任何```badbit```, ```failbit```, or ```eofbit``` set, then condition that evaluates that stream fails.
  -  ```s.good()``` or ```s.fail()```(fail or bad) 是确定stream 总体状态的正确方法. 实际上, 把流当条件使用的代码等于```!fail()```, ```s.eof``` 和 ```s.bad``` 检查specific error


|  Syntax     |  Description |
|   ---      | :---    |  
| ```strm::iostate``` |  ```strm``` is IO的一种类型,像上面的表中一样，可以是```ios::```, ```fs::```, ```ss::```, ```iostate``` is a machine-dependent integral type that represents the condition state of a stream | 
| ```strm::badbit``` | indicate stream is corrupted(崩溃). It is not possible to use once ```badbit``` set |
| ```strm::failbit``` |  indicate IO operation failed(IO 操作失败了). ```failbit``` set after a recovrabel error. 有可能fix error and continue using the stream. |
| ```strm::eofbit``` |  indicate a stream hit end-of-file (流已经到达了文件结束) |
| ```strm::goodbit``` |  indicate a stream is nt in error state. This value is guaranteed to be zero (流没有错误)  |
| ```s.eof()``` | return true if eofbit in the stream s is set (若流到达了eofbit位置) |
| ```s.fail()``` | return true if failbit or badbit in the sream s is set |
| ```s.bad()``` |  return true if badbit is in stream s in set | 
| ```s.good()``` |  return true if the stream s is in a valid state | 
| ```s.clear()``` | reset all condition values in the stream s to valid state. Return void |
| ```s.setstate(flag)``` | reset the condition of s to flags(根据条件状态对流s置位). type of flag 需要是上面几个state 的一种. Return void | 
| ```s.rdstate()``` | return current condition of s as a ```strm::iostate``` value | 

check the stream before use
```c++
while (cin >> word)
// ok: read operation successful . . .

```

Managing the Condition State
```c++
// remember the current state of cin

auto old_state = cin.rdstate(); // remember the current state of cin 

cin.clear();// make cin valid

process_input(cin); // use cin

cin.setstate(old_state);// now reset cin to its old state


// turns off failbit and badbit but all other bits unchanged 

cin.clear(cin.rdstate() & ~cin.failbit & ~cin.badbit);
```


**(3). Managing the Output Buffer**

- 每一个流都管理一个缓冲区(buffer), 用来hold data that program reads and writes. 比如```os << "please enter a value: ";```, literal string 也许会printed immediately, or operating system 也许store the data in a buffer to print later 
- Using a buffer 可以<span style="background-color:#FFFF00">combine serval output operations into a single system-level write</span>. 因为writing to device 可能time-consuimg, 如果let operating system combine several output operations into a single write 可以provide an important <span style="color:red">**performance boost**</span>.
- <span style="background-color:#FFFF00">Buffers Are not flushed if program crashes</span>. 如果程序异常终止, 缓冲区不会刷新, 当一个程序崩溃(crash)后, 它输出的数据可能停留在输出缓冲区中等待打印
  - when debug a program that crashed, 需要make sure any output you think should have been written was actually flushed. 否则可能花大量时间track through code 为什么没有执行. 而实际上已经执行了, 只是程序crash后缓冲区没有刷新(flush), 输出的数据没有打印而已(output pending)

有几种条件导致换种刷新(buffer flushed - write to actual output device or file  ) 
  - The program completes normally. All output buffers are flushed as part of return from main. 
  - At some indeterminate time, the buffer can become full, it will flushed before writing next value (缓冲区满了)
  - flush the buffer explicitly using a manipulator(操作符) such as ```endl```
  -  after each output operation, 可以用 manipulator ```unitbuf``` 设置流内部状态(set the stream's internal state) to 清空缓存. 默认情况下, 对```cerr```是设置```unitbuf```的, 所以写到```cerr```的内容都是立即刷新的
  -  Output stream might be tie to another stream. 这种情况下, when tied stream is read or written, 关联的流的缓冲区会被刷新(flush). By default,```cin``` and ```cerr``` are both tied to ```cout```. 因此reading to ```cin``` or writing to ```cerr``` flushes the buffer in ```cout```.

Manipulators
- ```endl```: end current line and flush the buffer
- ```flush``` flush the stream and adds no character to the output
- ```ends``` inserts a null character into buffer and flush

```c++
cout << "hi!" << endl; // writes hi and a newline, then flushes the buffer

cout << "hi!" << flush; // writes hi, then flushes the buffer; adds no data 

cout << "hi!" << ends; // writes hi and a null, then flushes the buffer

```

**unitbuf Manipulator**: If we want to flush after every output, we can use the ```unitbuf``` manipulator. ```unitbuf``` tell the stream to do ```flush``` after every subsequent write. ```nounitbuf``` manipulator restores the stream to use normal, system-managed buffer flushing: 

```c++
cout << unitbuf; // 所有输出操作后都会立即刷新缓冲区

 // 任何输出都立即刷新, 无缓冲

cout << nounitbuf; // returns to normal buffering

```

- 当一个输入流关联到输出流, 任何试图从输入流(intput stream)读取数据的操作 都会先刷新关联的输出流(output stream). 
  - The library ties ```cout``` to ```cin```. 因此 ```cin >> ival``` 会导致```cout```的缓冲区刷新(flush)
- interactive systems 通常应该关联输入流和输出流, 意味着, 用户提示的信息，都会在读操作前被打印出来

**tie**: has two overloaded versions. 
- one version takes no argument, 返回指向输出流指针. 如果this object is currently tie to output streams. 返回就是a pointer to the output stream。 
- 另一个version: take a pointer to an ```ostream```, 将自己关联到```ostream```上, ```x.tie(&o)```: tie the stream ```x``` to the output stream ```o```. 
- can tie either an ```istream``` or an ```ostream``` object to another ```ostream```

下面代码中, 将一个给定的流关联到一个新的输出流, 我们将新流的指针传递给```tie```。而彻底解开关联的流, we pass an null pointer. <span style="background-color:#FFFF00">每个流最多可以关联到一个流, 但是多个流可以关联到同一个```ostream```</span>
```c++
cin.tie(&cout); // illustration only: the library ties cin and cout for us 

// old_tie points to the stream (if any) currently tied to cin

ostream *old_tie = cin.tie(nullptr); // cin 不再与其他流灌流

// ties cin and cerr; not a good idea because cin should be tied to cout 

cin.tie(&cerr); // 读取cin 会刷新cerr 而不是cout 

cin.tie(old_tie); // reestablish normal tie between cin and cout

```

#### (b). File Input and Output

- ```getline```是从一个```ifstream```中读取数据.
- ```fstream``` 除了继承```iostream```的类型外, ```fstream```中定义的类型还增加了一些新的成员管理与流关联的文件. 如表中, 可以对```fstream```, ```ifstream```, ```ofstream``` 对象调用这些操作, 但不能对其他的```IO```类型调用这些操作
- when we creat a file stream, 可以选择性提供一个file name, associate that object with file. 如果提供file name, ```open``` is called automatically.
- 因为 ```fstream``` 除了继承```iostream```的类型, 可以用```fstream``` type 代替```iostream&``` tyes
- 如果关联一个流从一个file到另一个file, 需要先关闭```ifstream in(a); in.close()``` 再open ```in.open(name)```
- When an fstream object is <span style="background-color:#FFFF00">destroyed</span>, <span style="background-color:#FFFF00">close is called automatically</span>. 局部变量```fstream```离开作用域时, 关联文件会自动关闭

| Syntax | Description |
|  --- | :--- |
| ```fstream fstrm``` | 创建一个未绑定的流. ```fstream```是定义在```fstream``` header中的一种类型 |
|  ```fstream fstrm(s)``` | Creates an ```fstream``` and opens the file named s. ```s``` 可以是string or pointer to C-style character string. 这个constructor 是```explicit```的, 文件默认模式depends on the type of ```fstream``` |
|  ```fstream fstrm(s,mode)``` | 按照指定mode 打开文件 | 
| ```fstrm.open(s)``` | 打开名为s的文件, 并将文件与```fstrm``` 绑定.  ```s``` 可以是string or pointer to C-style character string. 这个<span style="color:red">constructor 是```explicit```的</span>, 文件默认模式depends on the type of ```fstream``` | 
| ```fstrm.close()``` | 关闭与```fstrm``` 绑定的文件，并返回void | 
| ```fstrm.is_open()``` | 返回一个bool 值,指出与```fstrm``` 关联文件是否成功打开且尚未关闭 | 

to verify if ```open``` succeeded is 好习惯
```c++
ifstream in(ifile); 

ofstream out; 

out.open(ifile + ".copy"); // open the specified file

if(out) // check that open succeeded 

    // the open succeeded, we can use the file

```

**(2).File Modes**

| syntax | Description |
| --- | :--- |
| ```in``` | Open for input | 
| ```out``` | open for output|
| ```app``` | seek to the end before every write 每次写操作前均定位到文件末尾 | 
| ```ate``` | Seek to the end immediately after the open 打开文件后立即到文件末尾 |
| ```trunc``` | Truncate the file | 
| ```binary``` | 以二进制方式进行IO operations |

The mode that we can specify have following restrictions: 
- ```out``` 只能对```ofstream``` or ```fstream``` object, ```out``` is default for ```ofstream```
- ```in``` 只能对 ```ifstream``` or ```fstream``` object, ```in``` is default for ```ifstream```
-  只有当```out``` is specified, 才能设定```trunc``` 模式
-  只要当 ```trunc``` 没被设定, 就可以设定```app``` 模式. 如果指定```app```, 即使没有explicitly specify ```out```, 文件也是以输出方式打开
-  By default, ```trunc```is default mode for ```out```(如果不设定, 默认是```trunc```).如果要保留文件内容, 需要specify ```app```, or specify ```in``` mode which file is open for both input and output 
- The ```ate``` and ```binary``` modes may be specified on any file stream , 且可以与任何其他文件模式组合使用

```c++
// 下面三行是一样的

ofstream out("file1"); // out and trunc are implicit

ofstream out2("file1", ofstream::out); // trunc is implicit 

ofstream out3("file1", ofstream::out | ofstream::trunc);

// to preserve the file's contents, we must explicitly specify app mode

//下面两行是一样的

ofstream app("file2", ofstream::app); // out is implicit 

ofstream app2("file2", ofstream::out | ofstream::app);
```

#### (c). String Streams

- ```sstream``` inherit frorm ```iostream``` header. 除了继承, ```sstream```中定义的类型还增加了一些成员管理```string```, 下面表中可以对```stringstream``` 对象调用这些操作, 但不能对其他的IO类型进行操作
- 即使```sstream``` and ```fstream``` share the the interface as ```iostream```. They have no other interrelationship. We cannot use ```open``` and ```close``` on a ```stringstream```. 也不能use ```str``` on an ```fstream```

| Syntax | Description | 
| --- | :--- | 
| ```sstream strm``` | ```sstream``` 是定义的在```sstream``` header 中一个类型, |
| ```sstream strm(s)``` | ```strm``` is an sstream tat holds a copy of string s. This constructor is explicit (不能pass c-character strings)|
| ```strm.str()``` | Returns a copy of string that ```strm``` holds | 
| ```strm.str(s)``` | copy the string s into strm. Returns void | 

**(1). istringstream**

当我们某些工作是对整行文本进行处理, 而其他一些工作是处理行内单个单词 可以用```istringstream```

e.g. 我们数据是如下类型，可以定义struct
```
morgan 2015552368 8625550123
drew 9735550130
lee 6095550132 2015550175 8005550000
```

下面code 中 ```while(record >> name)``` 与 ```while(getline(cin, line))``` 不同的是, loop reads data from ```string``` rather than the standard input. 当string completely read, "end-of-file" is signaled aand the next input operation on record will fail. 

```c++
struct PersonInfo {
    string name; 
    vector<string> phones;
};

string line, word;
vector<PersonInfo> people;
while(getline(cin, line))// or while (cin >> line)

{
    PeopleInfo info;
    istringstream record(line);
    record >> info.name;
    while(record >> name){
        info.phones.push_back(word);
    }
    people.push_back(info);
}
```

**(2). ostringstream**: is useful when一点点build up a output, 但是希望最后一起output

例如继续用上面```PersonInfo``` struct
```c++
for (const auto &entry : people) { 
    ostringstream formatted, badNums; 
    for (const auto &nums : entry.phones) {
        if (!valid(nums))
            badNums << " " << nums; 
        else
            formatted << " " << format(nums);
    }
    if (badNums.str().empty()) 
        os << entry.name << " " << formatted.str() << endl; 
    else 
        cerr << "input error: " << entry.name
            << " invalid number(s) " << badNums.str() << endl; 
}
```

<br/> <br/> <br/>
































## (9). Sequential Containers


sequential containers 为user 提供 control the order in which the elements are stored and accessed. Order 取决于元素加入容器(container)时的位置. By contrast, the ordered and unordered associative containers store theire elements based on the value of a key

#### (1). Overview

| Type | Description | 
| --- | :--- | 
| vector | Flexible-size array. Fast random access. Insert/delete elements other than at the back may be slow |
| deque | Double-ended queue. <span style="color:red"> Fast random access </span> Fast insert/delete at front or back|
| list | Double Linked list. Only bidirectional sequential access. Fast insert/delete at any pont in the list | 
| forward_list | Single Linked list. Only sequential access in one direction. Fast insert/delete at any point in the list <span style="color:red">(不支持reverse_iterator)</span> |
| array |  <span style="color:red"> **Fixed-size** array. Supports fast random access. **Cannot add or remove elements** |
| string | A specialized container, similar to vector that contains characters. Fast random ccess. Fast insert/delete at the back |

- the new library containers are <span style="color:red">dramatically faster</span> than previous release. <span style="background-color:#FFFF00">Modern C++ programs should use library containers</span> 而不是原始的数据结构, 例如build-in 数据
- 除了```array``` which is fixed-size, 剩下的container provide efficient, flexible memory management, growing and shrinking the size.
- **string** and **vector** hold their elements in <span style="background-color:#FFFF00">contiguous memory</span>.由下标计算其地址很快, 但是一次插入或者删除后,<span style="background-color:#FFFF00">需要移动插入/删除位置之后的所有元素, 来保持连续存储(maintain contiguity)</span>; 而且添加一个元素可能需要分配额外的存储空间. At the case, every element must be moved into the new storage. 
- **list** and **forward list** designed to fast to add / remove element anywhere in container. 作为代价，不支持random access. 而且与**string**,  **deque**
,**array** 相比, memory 开销(overhead) 也很大
- **forward_list** and **array** types were added by new standard. 与build-in array相比, An **array** 是更安全容易使用的. 与build-in array一样,是fixed size的,不支持add/remove element.
- **forward_list**  不支持```size``` operation 因为storing or computing its size 多出额外的开销compaed to handwritten list.


**Deciding Which Sequential Container to Use**
- 通常```vector```是最好的容器
    - 如果需要add elements in middle. common to add all elements in **vector** and call ```sort```
- If your program has lots of small elements and space overhead matters, don’t use list or forward_list.
- If the program requires random access to elements, use a **vector** or a **deque**.
- If the program needs to insert or delete elements：
   - Insert/Delete in the  <span style="color:red"> middle</span> of the container, use a **list** or **forward_list**.
   - Insert/Delete elements at the  <span style="color:red"> front and the back</span>, but not in the middle, use a **deque**.
   - Insert into the  <span style="color:red"> middle</span>, consider using a **list** for the input phase. Once the input is complete, copy the list into a **vector**.
- 如果程序需要random access , insertion and deletion. 决定取决于 <span style="color:red"> Random Access VS Insertion/Deletion </span> the relative cost of accessing the elements in a **list** or **forward_list** VS the code of inserting or deleting elements in a **vector** or **deque**
- 如果不确定使用哪个, 可以在程序中只使用 operations common to both **vector** and **list**. <span style="background-color:#FFFF00">**Use iterators, not subscripts and avoid random access to elements**</span>

#### (b). Container Library Overview

- Constructor:
   - Can use constructor that takes a size argument if the element type is built-in type or a class type that has a  <span style="color:red"> **default constructor**</span> 例如: ```vector<int> a(10)``` 默认初始化了10个0
   - <span style="color:red">如果没有default constructor type, we cannot construct such containers using only an element count</span>
   - The constructors that <span style="background-color:#FFFF00">take a size are valid only for sequential containers</span>; they are not supported for the associative containers.
- <span style="color:red">**Array**: size is part of its type</span>. 当define array, 需要specify element type and size ```array<int, 42>```. **Array** 不支持normal container constructor 因为这些constructor need the size of the container. 
    - 不像其他container, <span style="color:red">A default-constructed array is not empty: It has as many elements as its size(elements are default initialized)</span>
    - 如果提供initializer,必须提供equal or less than size. 如果fewer initializers than size, remaining value是value initialized. <span style="background-color:#FFFF00">如果array element type is class type, class 必须有default constructor.</span>
    - array 支持copy assignment constructor, 只要type (size, element type) matches, ```array<int, 10>a3(a2);```
    - array 不支持 braced list assignment(新版C++17支持), 但支持braced list initialization ```array<int,10>a1; a1 = {0}; ```
    - array 不支持 iterator constructor (no ```begin```, ```end```), ```Assign``` function 
- Assignment related operations invalidate iterators, references, and pointer into the left-hand container。除了string 和array 外, 而```swap``` 操作不会导致iterator, 引用，指针失效
- Excepting array, swap does not copy, delete, or insert any elements and is <span style="background-color:#FFFF00">guaranteed to run in constant time</span>.
    - elements themselves are not swapped; internal data structures are swapped.
    - <span style="background-color:#FFFF00">但是swap arrays 会真正交换他们的element</span>, 因为swap two arrays require 的时间与array 中数目成正比. 因此After swap, pointers, references, and iterators remain <span style="color:red">bound to the same element</span> they denoted before the swap, . 但是<span style="color:red">值已经与另一个array中交换了</span>(e,g,iterator 指向一样的```ivec[1]```,只是```ivec[1]```的值已经换成另一个了)
- 在library 有both mmber and nonmember version of ```swap```，好习惯是使用nonmember version of ```swap```
- **Relational Operators**:(>, >=, <=, <=, ==, !=), 必须保证right- and left-hand operands 必须是same kind of container and hold elements of same type (e.g. 不能拿```vector<int>``` compare to ```list<int>```), 比较two container 实际上是perform pariwise comparision of the elements, 与string比较方式类似
    - 两个container size 一样, element也一样，则相等, 否则不等
    - 两个container size 不一样, 但是较小的每个元素 和size 较大都一样, 则较大size 的大
    - size 不同, size小的容器 每个元素大于较大容器对应元素, 较小容器大
    - If neither container is an initial subsequence of the other, 取决于第一个不一样的element 
- 只有当type 定义了relational operator 才可以进行比较. 比如```vector<Sales_data> storeA, storeB; if (storeA < storeB);``` 有可能是error,如果```Sales```没有定义 ```<``` operator


```c++
// assume noDefault is a type without a default constructor

vector<noDefault> v1(10, init); // ok: element initializer supplied 

vector<noDefault> v2(10); // error: must supply an element initializer

```

Array initialization
```c++
array<int, 10> ia3 = {42}; // ia3[0] is 42, remaining elements are 0

int digs[10] = {0,1,2,3,4,5,6,7,8,9};
int cpy[10] = digs; // error: no copy or assignment for built-in arrays 

array<int, 10> digits = {0,1,2,3,4,5,6,7,8,9};

array<int, 10> copy = digits; // ok: so long as array types match


array<int, 10> a1 = {0,1,2,3,4,5,6,7,8,9}; p
array<int, 10> a2 = {0}; // elements all have value 0

a1 = a2; // replaces elements in a1

a2 = {0}; // error: cannot assign to an array from a braced list

```

Containner Assignment Operatior, <span style="background-color:#FFFF00">Assign operations not valid for associative containers or array。 Assignment related operations invalidate iterators, references, and pointer into the left-hand container。除了string 和array 外,而```swap``` 操作不会导致iterator, 引用，指针失效 </span>

| Syntax | Description | 
| --- | :--- | 
| ```c1 = c2``` | Replace element in ```c1``` with copies of elements in ```c2```, ```c1``` 与```c2```类型必须一样 |
| ```c = {a,b,c}``` | Replace elements in ```c1``` with copies of elements in initializer list (<span style="color:red">not valid for array</span>) |
| ```swap(c1,c2)```<br/> ``` c1.swap(c2)``` | <span style="background-color:#FFFF00">Swap 会比copy elements 快的多</span> | 
| ```seq.assgin(b,e)``` | Replaces elements in seq with those range denoted by iterators ```b``` and ```e``` |
| ```seq.assign(il)``` | Replaces elements in seq with those in **initializer list** ```il``` |
| ```seq.assign(n,t)``` | Replaces elements in seq with n elements with value t |



Syntax common to all sequential container

| Syntax | Description | 
| --- | :--- | 
| ```difference_type``` | signed integral type big enough to thold the distance between two iterators |
| ```C c(b ,e)``` | copy elements from range denoted by iterators b and e (<span style="color:red">not valid for array</span>) |
| ```c.max_size()``` | C 可保存最大的数目 | 



**Iterators**
- 对于一个```reverse_iterator``` 进行 ```++``` operation, 得到上一个element
- <span style="color:red">对一个const object 调用iterator时, 普通的iterator 会convert to ```const_iterator```</span>
- <span style="background-color:#FFFF00">除了```array```以外, every container type defines a default constructor.</span>, 且都可以接受argument that specify size and initial values
- create a container as copy another container, 两个container类型必须匹配 ```C c(a)```. 如果pass iterators```C c(begin, end)```,两个containers 类型不用相同 (只要可以convert elements to the initialized type)

对一个const object, 普通iterator 会转换成 ```const_iterator```
```c++
list<string>::iterator it5 = a.begin();
auto it7 = a.begin(); // const_iterator only if a is const

```

<span style="background-color:#FFFF00">**Assign 可以用于different but compatible type**</span>

```c++
list<string> names;
vector<const char*> oldstyle;
names = oldstyle; // error: container types don't match

// ok: can convert from const char*to string 

names.assign(oldstyle.cbegin(), oldstyle.cend());


// equivalent to slist1.clear();

// followed by slist1.insert(slist1.begin(), 10, "Hiya!");

list<string> slist1(1); // one element, which is the empty string 

slist1.assign(10, "Hiya!"); // ten elements; each one is Hiya !

```

**swap** : with the exception of string, iterators, references, and pointers into the containers are not invalidated(仍然有效). 比如had ```iter``` denoted the string at ```sevc1[3]``` before swap, swap之后, ```iter```指的是```svec2[3]```
```c++
vector<string> svec1(10); // vector with ten elements 

vector<string> svec2(24); // vector with 24 elements 

swap(svec1, svec2);
```

**比较container**
```c++
vector<int> v1 = { 1, 3, 5, 7, 9, 12 };
vector<int> v2 = { 1, 3, 9 };
vector<int> v3 = { 1, 3, 5, 7 };
vector<int> v4 = { 1, 3, 5, 7, 9, 12 };
v1 < v2 // true; v1 and v2 differ at element [2]: v1[2] is less than v2[2]

v1 < v3 // false; all elements are equal, but v3 has fewer of them;

v1 == v4 // true; each element is equal and v1 and v4 have the same size() 

v1 == v2 // false; v2 has fewer elements than v1

```

#### (c). Sequential Container Operations

**(1).Add, Access, Delete**
- 像一个```vector``` or ```string``` 添加元素可能会引起entire object to be reallocated. <span style="background-color:#FFFF00">Reallocating an object requires allocating new memory and moving elements from the old space to the new.</span>
- ```array```
   - 除了```array```, 所有library containers 都提供了flexible memory management, we can add or remove elements dynamically the size of container at run time. 
    - 不支持任何 add operation 因为会改变size
       - 不支持```push_back/emplace_back, push_front/emplace_front``` (a copy of object)
       - 不支持```insert```,剩下container都支持```insert```(vector, deque, list, string, forward_list)
    - 不支持任何 deletion operation 因为会改变size 
-  ``forward_list```
    - 没有```back```,因为不支持```reverse_iterator```, 
    -  也不能```--```递减```forward_list```的iterator, 但可以call ```forward_list```的```end()```
    - 不支持```push_back``` 
    - 有自己的```insert``` and ```emplace```
- ```emplace(front, back)```construct elements in the container ( construct an element directly in space managed by the container在内存空间中直接构造元素). The arguments must match a constructor for the element type. 
- The Access Members Return References (```back()```, ```front()```, ```c[n]```, ```c.at(n)```), e.g. ```auto & v = c.back(); v = 1024;```, 
    -  ```at```与下标的区别是如果越界, ```at```throw out_of_range error 如果invalid, （subscript operator 不会check index）





| Syntax | Description | 
| --- | :--- | 
|  |```forward_list``` 有自己的```insert``` and ```emplace```  |
|  |```forward_list``` 不支持```push_back``` and ```emplace_back```  |
|  |```vector```, ```string``` 不支持```push_front``` and ```emplace_front```  |
| ```c.push_back(t)``` <br/>  ```c.emplace_back(arg)``` | 在尾部创建一个值为t或者由args 创建的元素 |
| ```c.push_front(t)``` <br/>  ```c.emplace_front(arg)``` | |
| ```c.insert(p,t)``` <br/>  ```c.emplace(p,args)``` | p is iterator, 在p之前插入，返回iterator 指向新添加元素 |
| ```c.insert(p,n,t)```  | 在p之前, 插入n个t, 返回指向新添加的第一个元素的iterator, 若n为0, 返回p |
| ```c.insert(p,b,e)```  | 在p之前, 插入由iteartor b 和e返回内的元素, 返回指向新添加的第一个元素的iterator, 若range 为空, 返回p |
| ```c.insert(p,il)```  | il是一个braced list of element values. 在p之前插入, 返回指向新添加的第一个元素的iterator, 若列表为空, 返回p |

Delete Element

| Syntax | Description | 
| --- | :--- | 
|  | <span style="color:red">这些操作改变容器大小, 不适合```Array```</span> |
|  |```forward_list```有特殊的 ```erase```, 不支持```pop_back()```  |
|  |```vector```, ```string``` 不支持```pop_front```  |
| ```c.pop_back()``` <br/> ```c.pop_front()```  | return void |
| ```c.erase(p)``` | p is iterator, 删除p,返回删除元素之后的元素的 iterator，如果p is end, undefined |
| ```c.erase(b,e)``` | b,e is iterator of range, 删除p,返回删除元素之后的元素的 iterator，如果e is end, return end iterator; if ```b= e```,是安全的,删除一个空范围没有不良后果  |
| ```c.clear``` | return all element, returns void |




理解下面insert的返回值,每次返回都是begin, 指向新的元素
```c++
list<string> 1st;
auto iter = 1st.begin(); 
while (cin >> word)
    iter = 1st.insert(iter, word); // same as calling push_front

```

删除元素
```c++
list<int> lst = {0,1,2,3,4,5,6,7,8,9}; 
auto it = lst.begin();
while (it != lst.end())
    if (*it % 2) // if the element is odd 

        it = lst.erase(it); // erase this element

    else
        ++it;
```


**(2).Specialized forward_list Operations**

![](/img/post/C++/forward_list.png)

因为```forward_list``` 是single linked list, 如果add/remove element 需要访问前一个元素(prepocessor),但是forward_list是单向,不能访问前一个元素, 所以定义insert emplace, erase 都是after, e.g. 我们想删除```elem3``` 需要call ```erase_after``` on iterator ```elem2```. To support 这种操作, ```forward_list``` 也定义了一个```before_begin``` returns off-the-begining (首前) iterator

| Syntax | Description | 
| --- | :--- | 
| ```c.before_begin()``` <br/> ```c.cbefore_begin()```  | 不存在的元素在列表首前, <span style="color:red">不能用dereferenced</span> |
| ```c.insert_after(p,t)``` <br/> ```c.insert_after(p,n,t)```  <br/> ```c.insert_after(p,b,e)```  <br/> ```c.insert_after(p,il)```  | p is iterator, t is object, n is count, b 和 e是iterator, il is braced list. <span style="color:red">返回last insert element</span> 如果range is empty returns p, <span style="color:red">Undefined if p 是off-the-end iterator (end)</span>  |
| ```c.emplace_after(p.args)``` | 返回the iterator to new element, Undefined if p 是off-the-end iterator (end) |
| ```c.erase_after(p)``` <br/>  ```c.erase_after(b,e)``` | 删除p后面的一个elements or 删除(b,e)之间的元素 (不包括b,e). 返回an iterator to the eement after the one deleted, or 返回off-the-end iterator(如果不存在这样的element), Undefined if p 是off-the-end iterator (end) |

当删除elements in ```forward_list``` 必须关注两个iterator, the one we checking and the one to that element's predecessor.

```c++
forward_list<int> flst = {0,1,2,3,4,5,6,7,8,9};
auto prev = flst.before_begin(); // denotes element "off the start" of flst

auto curr = flst.begin();
while (curr != flst.end()) { // while there are still elements to process

    if (*curr % 2)
        curr = flst.erase_after(prev); // erase it and move curr

    else {
        prev = curr;
        ++curr;
    }
}
```

**(3).Resize**

- 如果```resize``` 缩小容器, then iterators, references, and pointers to the deleted elements are invalidated; ```resize``` on a vector, string, deque potentially invalidates all iterators, pointers, and references.

| Syntax | Description | 
| --- | :--- | 
| ```c.resize(n)```  | if n < c.size(), 多的元素被丢弃, 如果必须添加新的元素, value initialized |
| ```c.resize(n,t)```  | Resize c to have n elements of t  |

**(4).Operations May Invalidate Iterators**

- Invalidate iterator, pointer, or reference is serious <span style="color:red">run-time error</span>
- After Options that add elements: (Iterators, pointers, and references aka IPR)
  - IPR to vector or strings are <span style="color:red">invalid 如果 container **reallocated** </span>. 如果没有reallocate, 插入元素之前的IPR有效, 插入元素之后的IPR 无效
  - 对于 **deque**, add elements in the middle, IPR都invalid; <span style="background-color:#FFFF00">在 front or back, Iterators are invalidated, but references and pointers to existing elements not affected</span>
  - Adding (insert) elements to ```vector```, ```string```, ```deque``` 会invalidates all existing IPR
  - 对于 **list**, **forward_list** IPR都 都有效
- After we remove element
  -  **list**, **forward_list** IPR 都 remain valid 
  -  对于 **deque**, remove elements  in the middle IPR都invalid; <span style="background-color:#FFFF00">如果删除是back or front, begin/off-the-end itertor(end) is invaldiated, front/back的reference, pointer有效, 其他middle的IPR 都有效 （unaffected) </span>
  -  IPR to **vector** or **string** remain valid对于删除元素之前的, 注意: 当我们删除元素时, off-the-end iterator is always invalidated when we remove elements
- Avoid Storing the Iterator Returned from end 因为add / remove elements 总会把```vector``` or ```string``` 的```end``` iterator invalid



```c++
// silly loop to remove even-valued elements and insert a duplicate of odd-valued elements

vector<int> vi = {0,1,2,3,4,5,6,7,8,9};
auto iter = vi.begin(); // call begin, not cbegin because we're changing vi

while (iter != vi.end()) { 
    if(*itera%2)
        iter = vi.insert(iter, *iter); // duplicate the current element

        iter += 2; // advance past this element and the one inserted before it

    } else
        iter = vi.erase(iter); // remove even elements

        // don't advance the iterator; iter denotes the element after the one we erased

}
```

**Avoid Storing the Iterator Returned from end**: 不要特地的保存```end```, 下面的代码行为是未定义的, 会导致代码无限循环
```c++
// disaster: the behavior of this loop is undefined 

auto begin = v.begin(),
    end = v.end(); // bad idea, saving the value of the end iterator 

while (begin != end) {
    // insert the new value and reassign begin, which otherwise would be invalid 

    ++begin; // 想在此元素后插入元素

    begin = v.insert(begin, 42); // insert the new value 
    
    ++begin; // advance begin past the element we just added

}


//正确做法
while (begin != v.end()) {
    ++begin; // advance begin because we want to insert after this element 
    
    begin = v.insert(begin, 42); // insert the new value
    
     ++begin; // advance begin past the element we just added

}

```

#### (d). How a vector Grows

- **vector** 和 **string** 通常会分配比新的空间需求更大的内存空间，holds this storage in reserve and use it to allocate new elements as they are added. 因此而不会每次添加元素的是都reallocate 
- vector implementation strategy 是 doubling the current capacity each time it has to allocate new storage.(1->2->4->8->16...)
- ```capacity``` 告诉我们how many elements the container can hold before it must allocate more space. ```size``` is the number of a elements the container already holds 
- ```reserve``` 允许我们通知container how many elements it should prepare to hold.  ```reserve``` 不改变容器中元素的数量，仅影响预先分配多大的内存空间 (how much memory the ```vector``` preallocates )
  - 如果request space > current capacity, ```reserve``` allocates at least as much as requested amount
  - 如果request size 小于 或者 等于 existing capacity, ```reserve``` does nothing. 
  - <span style="background-color:#FFFF00">```reserve``` never reduce the amount of space that container uses.</span>. 如果想减少memory, 可以call ```shrink_to_fit``` 对于 deque, vector, or srtring; <span style="color:red">```resize``` 只改变容器中元素数目, 而不改变its capacity</span>
- Calling ```shrink_to_fit``` is only a request; there is no guarantee that the library will return the memory.比如当size == capacity


| Syntax | Description | 
| --- | :--- | 
| | ```shrink_to_fit``` valid only for vector, string, deque |
| | ```capcity()``` and ```reserve``` valid only for vector, string |
| ```c.shrink_to_fit(n)```  | Request to reduce ```capacity()``` to equal to ```size()```|
| ```c.capacity(n,t)```  | 不重新分配的话，c可以保存多少元素  |
| ```c.reserve(n)``` | Allocate space for at least n elements | 

用光预留空间
```c++
vector<int> ivec;
while (ivec.size() != ivec.capacity())
    ivec.push_back(0);
```

#### (e). Additional string Operations

**(1). 其他构造string 的方法**

| Syntax | Description | 
| --- | :--- | 
|  | n, len2, pos2 are all unsigned values |
| ```string s(cp, n)```  | s is a copy of the first n character in array which cp points. Array 必须有至少n个char|
| ```string s(s2, pos2)```  | s is a copy of characters in the string s2 starting from the index ```pos2```. Undefined if ```pos2>s2.size()``` |
| ```string s(s2, pos2, len2)``` | s is a copy of characters in string s2 \[pos2, pos2+len2 \), 不管len2多大， 最多copy ```s2.size() - pos2```个chars| 


- 当create a string from a ```const char*```, <span style="color:red">array 必须是 null terminated.</span>, copy 遇到null 停止. or pass a count , array 可以不用以null 结尾
    - <span style="color:red">但是如果不pass count and no null terminated, 或者given count 大于size of array, operation is undefined</span>
- 当pass的起始值pos2 大于size, 会throw ```out_of_range``` exception. 
- library copies up to the size of string or null 结尾的char array

```c++
const char *cp = "Hello World!!!"; // null-terminated array

char noNull[] = {'H', 'i'}; // not null terminated

string s1(cp); // copy up to the null in cp; s1 == "Hello World!!!"

string s2(noNull,2); // copy two characters from no_null; s2 == "Hi" 

string s3(noNull); // undefined: noNull not null terminated

string s4(cp + 6, 5);// copy 5 characters starting at cp[6]; s4 == "World" 

string s5(s1, 6, 5); // copy 5 characters starting at s1[6]; s5 == "World" 

string s6(s1, 6); // copy from s1 [6] to end of s1; s6 == "World!!!" 

string s7(s1,6,20); // ok, copies only to end of s1; s7 == "World!!!" 

string s8(s1, 16); // throws an out_of_range exception

```

string operation 

| Syntax | Description | 
| --- | :--- | 
| ```s.substr(pos, n)``` | pos起始点, n 是从起始点copy 多少个, \[pos, pos+n\), 会throws an out_of_range exception 如果pos超过size |
|  |定义了member function  ```assign```, ```erase```, ```insert``` | 
| ```s.append(args)``` | | 
| ```s.assign(args)``` |  replace chararcters in s = args | 
| ```s.erase(pos,len)``` | 删除\[pos, pos+len\), 如果没有提供len, 表示 删除\[pos, end\), return a reference to s |
| ```s.insert(pos,args)``` | pos 可以是下标 or iterator, 在p之前插入args, 接受index的版本 返回reference to s; 接受iterator的返回an iterator 表示第一插入的character |
| ```s.replace(range,args)``` | 删除range 内的字符, 替换成args指定的字符, range 可以是一个下标或者一个长度, or a pair of iterators into s. returns a reference to s |

上表的arg 可以是如下的形式



**(2). String Search Operations**

- 有6中search的functions, 每个function 提供4个overloaded functins. 每一个search 返回 ```string::size_type``` value that is the index of where match occurred 如果没有match, function 返回一个 ```static``` member named ```string::npos```.  Library defines ```npos``` as a ```const string::size_type``` 初始值 -1. 因为```npos```是unsinged type.  意味着```npos```等于任何```string```最大可能的值得大小

![](/img/post/C++/string_search.png)

```c++
string river("Mississippi");
auto first_pos = river.find("is"); // returns 1 

auto last_pos = river.rfind("is"); // returns 4

```

**(3). Compare Functions**

```compare``` function 类似于 C library的 ```strcmp``` function. Like ```strcmp, s.compare``` 返回0(等于), positive(大于) or negative(小于) value 

| Syntax | Description | 
| --- | :--- | 
| ```s2``` | Compare s to s2 |
| ```pos1, n1, s2``` | 将s中 \[pos1, pos1 + n1) compare to s2 | 
| ```pos1, n1, s2, pos2, n2``` | 将s中 \[pos1, pos1 + n1 ) compare to s2 的\[pos2, pos2 + n2 )   | 
| ```cp``` | compares s to null-terminated array pointed to by cp | 
| ```pos1, n1, cp``` | 将s中 \[pos1, pos1 + n1) compare to cp | 
| ```pos1, n1, cp, n2``` | 将s中 \[pos1, pos1 + n1) compare to n2 characters starting from pointer cp | 

**(4).Numeric Conversions**

- 如果string 不能转换为一个数值, 转换 functions 会 throw an ```invalid_argument``` exception. 如果转换得到数值无法用任何类型来表示, throw ```out_of_range```

| Syntax | Description | 
| --- | :--- | 
| ```stoi(s, p, b)``` <br/>  ```stol(s, p, b)``` <br/>  ```stoul(s, p, b)``` <br/>  ```stoll(s, p, b)``` <br/>  ```stoull(s, p, b)```  | b表示numeric base for the conversion(几进制), p is a pointer to a ```size_t``` in which to put index of first non-numeric character(非数值的) in s` |
| ```stof(s,p)``` <br/> ```stod(s,p)``` <br/> ```stold(s,p)``` | p跟上面的作用一样 | 


#### (f). Container Adaptors
- 除了 sequential containers, 还定义了sequential container adaptors: ```stack```, ```queue```, and ```priority_queue```. An adaptor 是 general concept. 
- container adaptor takes an existing container type and makes it act like a different type.
- Each adaptor defines two constructors: the default constructor that creates an empty object, and a constructor that takes a container and initializes the adaptor by copying the given container. 
- 默认情况下, ```stack```and ```queue``` are implemented in terms of ```deque```, 而```priority_queue```是在```vector```上实现的
    - e.g. 假定```deq```是一个```deque<int>```, ```stack<int>stk(deq);``` 从deq拷贝元素到stk,
    - e.g. override default container type by naming a sequential container as a second type argument. ```stack<string, vector<string>>str(svec)```
- <span style="background-color:#FFFF00">All adpator 需要the ability to add / remove elements. 因为they cannot be built on ```array```. 同样的, 我们也不能用```forward_list```, 因为adaptor需要具有add, remove, access the last element (back) ability. </span>
- ```stack```仅需要有```back```, ```push_back```, ```pop_back```,所以用于除了```array``` 和 ```forward_list```以外所有容器
- ```queue```需要有```back```,```push_back```, ```front```, ```push_front```的能力,所以只能建立在```list``` or ```deque```上而不能在```vector```上. 
- ```priority_queue``` 需要有random access in addition to ```front```, ```pusk_back```, ```pop_back```, 所以只能用于```vector``` or ```deque```, 不能用于```list```
- 每一个container adpator defines 自己的操作类型 in terms of 底层容器的操作类型. 只能使用adaptor自己的操作类型,不能用underlying container type的操作类型. 
    - ```intStack.push(ix);``` calls ```push_back``` on the ```deque``` on which ```intStack``` is based,尽管```stack```是基于```deque```实现的, 但我们不能使用```deque```操作, 不能call ```push_back```, 只能call ```push```



## (10). Generic Algorithms


#### (a). Overview

Kep Concept: <span style="background-color:#FFFF00">Algorithms Never Execute Container Operations</span>. They operate solely in terms of iterators and iterator operations. 有个重要的implication: Algorithm nevver change the size of the underlying container, Algorithm 可能改变container中的值, 可能会moeve elements within the container。 但是never add or remove elements directly. A special class of iterator is **iterator** 会插入elements, 但是算法自身itseflf never does so

#### (b), First Look at the Algorithm

- **Read-Only Algorithms**： 
    - never write to element
    - it is best to use ```cbegin()``` and ```cend()``` with algorithms that read, but do not write
    - ALgorithm that take a <span style="background-color:#FFFF00">single iterator</span> denoting a <span style="background-color:#FFFF00">second squence</span>, <span style="background-color:#FFFF00">都假定 second sequence is at least as large at the first(至少一样长)</span> 
        - 比如```equal```中的第二个sequence 没有第一个长, 程序会报错
    - 一些算法从两个序列(containers)中读取元素, <span style="background-color:#FFFF00">不一定要求两个container 是一样类型, 也不要求element types are indentical</span>. e.g. 见表中的```equal```
- **Algorithms That Write Container Elements**
    - Some algorithms assign new values to the elements in sequence, 必须确保序列原大小 必须大于 我们要求写入的 元素数目。<span style="background-color:#FFFF00">算法不执行container operations, no way to change the size of a container</span> 
    - Algorithms Do Not Check Write Operations: Algorithms that write to a destination iterator <span style="color:red">assume the destination is large enough to hold the number of elements</span> being written. 会假定container 有足够的size (容量)来操作 比如```fill_n```, 如果空间不够, undefined behavior
    - 还有一些算法 so called "copying" ersion, 这些算法compute new element values, but instead of putting them back into input sequnce, 算法创建一个新序列保存这些结果, 例如```replace_copy```
- 一种确保algorithm has enough elements to hold is to use **insert iterator** (right-hand value is added to container)
    - **back_inserter**: takes a <span style="background-color:#FFFF00">reference to a container</span> and <span style="background-color:#FFFF00">returns an insert iterator bound to that container</span>. 当assign through that iterator, assignment calls ```push_back``` to add an element with the given value to the container

Read-only Algorithm

| Syntax | Description | 
| --- | :--- | 
| ```accumulate``` | accumulate第三个类型决定了使用哪个加法运算符和返回类型(注意：不可以传入empty string as string literal) <br/> ```string sum = accumulate(v.cbegin(), v.cend(), string(""));```  |
| ```equal``` | 判断两个sequences hold the same value, compare each elements, return true 如果一样, 否则false; equal 不一定需要两个cointainer 一样 类型也一样, 可以是<span style="color:red">不同的container</span>, 不同的类型, 只需可以用```==```来比较来自两个序列的元素 |

```c++
//accumulate

int sum = accumulate(vec.cbegin(), vec.cend(), 0);
string sum = accumulate(v.cbegin(), v.cend(), string(""))
// error: no + on const char*

string sum = accumulate(v.cbegin(), v.cend(), "");

//equal

// roster2 should have at least as many elements as roster1 

equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());

list<int> a = { 1,2,3,4,5 };
array<int,5> b = { 1,2,3,4,5 }; 
cout << equal(a.begin(), a.end(), b.begin());//print 1

``` 

Algorithm that write element

| Syntax | Description | 
| --- | :--- | 
| ```fill``` | 将给定的值赋予序列中每个元素, 有点像```resize```, ```assign```,但不会像它们一样改变size |
| ```fill_n``` | ```fill_n(dest, n, val)``` takes a iterator, a count and a value. 从iterator声明的位置开始, fill n 个 元素 value.  <span style="color:red">assumes that dest refers to an element and that there are at least n elements in the sequence starting from dest.</span> |
| ```copy``` | 接受三个iterator, 前两个表示input range, 第三个表示beginning of the destination sequence: copy from input range to destinaion. 很重要的是: destination passed to ```copy``` 至少跟input range 一样长, The value returned by copy is the (incremented) value of its destination iterator.(就是完成copy后的下一点) |
| ```replace``` |  接受4个参数， 前两个是iterator, 表示输入序列, 后两个一个是要搜索的值, 一个是replace的值  |
| ```replace_copy``` | 跟```replace```想法一样,只不过不更改input sequence, 接受5个参数， 前两个是iterator, 表示输入序列, 第三个表示write的destination, 后两个一个是要搜索的值, 一个是replace的值  |


```c++
//fill

fill(vec.begin(), vec.begin() + vec.size()/2, 10);

//fill_n: Do Not Check Write Operations

vector<int> vec; // empty vector

// disaster: attempts to write to ten (nonexistent) elements in vec 

fill_n(vec.begin(), 10, 0);//The result is undefined.


//copy

int a1[] = {0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1)/sizeof(*a1)]; // a2 has the same size as a1

// ret points just past the last element copied into a2

auto ret = copy(begin(a1), end(a1), a2); // copy a1 into a2

// ret will point just past the last element copied into a2.


//replace 

replace(ilst.begin(), ilst.end(), 0, 42);//把所有的0 替换成42

// use back_inserter to grow destination as needed 

replace_copy(ilst.cbegin(), ilst.cend(), back_inserter(ivec), 0, 42);

//把范围内所有的0替换成42, 并push_back到ivec

``` 

**back_inserter**; apply to ```fill_n```: 因为we passed an iterator returned by ```back_inserter```(back_iterator返回的迭代器), each assignment will call ```push_back``` on ```vec```

```c++
vector<int> vec; // empty vector

auto it = back_inserter(vec); // assigning through it adds elements to vec

it = 342; // vec now has one element with value 42, size = 1

*it = 42; // vec now has one element with value 42, size = 2

//因为*it = 会call push_back, 向后推, it iterator 不会前进，


//用到fill_n 

vector<int> vec; // empty vector

// ok: back_inserter creates an insert iterator that adds elements to vec 

fill_n(back_inserter(vec), 10, 0); // appends ten elements to vec

```

**Algorithms That Reorder Container Elements**


| Syntax | Description | 
| --- | :--- | 
| ```sort``` |  |
| ```stable_sort``` | 与```sort``` 不同的是, ```stable_sort```会维持相等元素原有的序列 | 
| ```unique``` | 消除相邻的重复(如果不相邻一样的，不会删除), <span style="background-color:#FFFF00">因为算法不对容器进行操作, 不能直接添加/删除元素</span>, 返回an iterator that denotes the end of the range of the unique value |

```c++
vector<int>  = {10,20,20,20,30,30,20,20,10};   // 10 20 20 20 30 30 20 20 10

  // using default comparison:

std::vector<int>::iterator end_unique = std::unique (myvector.begin(), myvector.end());   

// 10 20 30 20 10 ?  ?  ?  ?

                  ^
                  |
                end_unique                              
```

#### (c), Customizing Operations

- A **predicate** is an expression that can be called and that returns a value that can be used <span style="color:red">as a condition</span>. Has two version:
    - **unary predicate**: they have a single parameter
    - **binary predicates**: they have two parameters, 比如```sort```
- 算法call the given predicate on the elements in the input range. 因此, must be <span style="color:red">possible to convert</span> the element type to the parameter type of the predicate



**(1). Lambdas**: 
- 可以pass any kind of **callable object** to an algorithm. A object or expression is callable if we can apply the call operator to it. ```e(args)```. 
- **lambda expression** 可以想成是inline function, ```[capture list] (parameter list) -> return type { function body }```
    - ```capture list``` is 局部变量(所在函数内部,lambda外部)列表 defined in the enclosing function(通常为空). <span style="color:red">A lambda may use a variable local to its surrounding function only if the lambda captures that variable in its capture list.</span>
        - The capture list is used for <span style="color:red">**local nonstatic variables**</span> only; lambdas can use local statics and variables declared outside the function directly(比如```cout```)
    - return type:
        - 如果specify return type的话, unlike ordinary functions, a lambda must use a trailing return (尾置返回) to specify its return type.
        - <span style="background-color:#FFFF00">如果忽略返回类型, lambda 根据函数体的代码推断出返回类型</span>. 
    -  can <span style="color:red">omit either or both of the parameter list and return type</span> but must always include the capture list and function body ```auto f = [] { return 42; };``` 定义了```f``` callable object that takes no arguments and returns 42.```cout << f() << endl; // prints 42```
    - parameter:
        - lambda中忽略parameter list 等于指定一个empty parameter list.
        - lambda 不能有<span style="color:red">默认参数</span>. 因此call lambda 的参数永远与lambda 的参数一样多
    - When we define a lambda, the compiler generates a new (unnamed) class type that corresponds to that lambda, <span style="color:red">当函数传递一个lambda时, we define both a new type and an object of that type</span>: 传递的参数就是**an unnamed object** of this compiler-generated class type. 但我们跟使用```auto``` 定义一个lambda 变量的初始值时, define an **object** of the type generated from that lambda.
        - By default, the class (generated from a lambda) contains a data member corresponding to the variables captured by the lambda
        - 类似普通data members of any class, <span style="color:red">the data members of a lambda are initialized when a lambda object is created</span>.
    - can also return a lambda from a function.  The function might directly return a **callable object** or the function might return **an object of a class that has a callable object as a data member**. 如果Function returns a lambda, 不能return a reference to a local varaibles (<span style="background-color:#FFFF00">不能有reference captures</span>)

Capture: 
- **Capture by value** ```auto f = [v1] { return v1; };```. 前提是变量必须是可以copy的，Unlike parameters, 被捕获的值是在lambda 创建时copy 而不是在被调用(call)时copy,因此随后的对其修改不会影响到lambda 内对应的值
    -  If we want change the value of a captured variable, we must follow the parameter list with the keyword ```mutable```. 
        - lambda that are mutable不能省略parameter list ```auto f = [v1] () mutable { return ++v1; };```
        
- **Capture by Reference**: ```auto f2 = [&v1] { return v1; };```when use the variable inside the lambda body, 使用的是引用所绑定的对象, 比如返回```v1```, 返回的是```v1``` 指向对象的值
    - 必须确保 the referenced object exists at the time the lambda is executed(<span style="background-color:#FFFF00">被引用对象在lambda 执行时候是存在的)</span>.<span style="color:red">因为捕获的都是局部变量</span>. 这些变量在函数结束后就不存在了,如果lambda 可能在函数结束后执行, 捕获引用指向的局部变量已经消失
    - 捕获引用是有必要的, 比如函数接受一个```ostream```的引用,
    - 一个variable captured by reference can be changed depends only on whether that reference refers to a ```const``` or nonconst type (如果variable 指向const object不能修改, 如果不是const 可以修改)
- **Implicit Captures**: 可以让compiler根据lambda中代码nfer which variables we use from the code. To direct the compiler to infer the capture list, we use an ```&```(capture by reference) or ```=```(capture by value) in the capture list.
- **Mix implicit and explicit Capture**: 
    - 必须确保the first item in capture list is ```&```or ```=```
    - <span style="background-color:#FFFF00">Explicit capture variables must use the alternate form(显示捕获和隐式捕获必须是不同的方式)</span>: 如果隐式捕获是引用(```&```), 则显示捕获必须是值, 因为不能在显示名字前加上```&```; 如果隐式捕获是值方式, 则显示捕获必须用引用方式 (加上```&```)

![](/img/post/C++/lambda_capture.png)

Implicit Capture
```c++
// sz implicitly captured by value

wc = find_if(words.begin(), words.end(),    
    [=](const string &s) { return s.size() >= sz; });
```

we can mix implicit and explicit captures:

```
void biggies(vector<string> &words, vector<string>::size_type sz,
        ostream &os = cout, char c = ' ')
{
// os implicitly captured by reference; c explicitly captured by value

for_each(words.begin(), words.end(),
        [&, c](const string &s) { os << s << c; });

// os explicitly captured by reference; c implicitly captured by value 

for_each(words.begin(), words.end(),
        [=, &os](const string &s) { os << s << c; });
}
```

**Mutable Lambdas**
```c++
void fcn3()
{
    size_t v1 = 42; // local variable

    // f can change the value of the variables it captures

    auto f = [v1] () mutable { return ++v1; }; 
    v1 = 0;
    auto j =f();// j is 43

}

void fnc4()
{
    size_t v1 = 42; // local variable

    // v1 is a reference to a non const variable

    // we can change that variable through the reference inside f2

    auto f2 = [&v1] { return ++v1; }; 
    v1 = 0;
    autoj=f2();// j is 1

}
```



Capture Advise: 需要keep your lambda captures simple
- A lambda capture stores information between the time the lambda is created (i.e., when the code that defines the lambda is executed) and the time (or times) the lambda itself is executed (捕获保存信息从定义到执行).
- Capture ordinary variable 比如```int```, ```string```, or nonpointer type - by value is usually straightforward. 这种情况下, 只需关注在捕获时有我们需要的值就可以了
- 如果捕获pointer, iterator, or capture by reference, 必须ensure pointer, iterator, or reference still exists whenever the lambda executes. 可能是在指针或引用被捕获时候, 绑定对象的值是我们期望的, 但在lambda执行时, 该对象的值可能完全不同了
- if possible, avoid capturing pointers or references.


```c++
void biggies(vector<string> &words, vector<string>::size_type sz,
ostream &os = cout, char c = ' ')
{
// statement to print count revised to print to os 

for_each(words.begin(), words.end(),
    [&os, c](const string &s) { os << s << c; });
}
```


**Specifying the Lambda Return Type**

- 默认情况下, 一个lambda body contains any statement 除了return, that lambda is assumed to return void. lambdas inferred to return void may not return a value.
- When we need to define a return type for a lambda, we must use a **trailing return type**

```c++
//error: cannot deduce the return type from the lambda(新版C++ 是可以的)

transform(vi.begin(), vi.end(), vi.begin(),
    [](int i) { if (i < 0) return -i; else return i; 
});

transform(vi.begin(), vi.end(), vi.begin(), [](int i) -> int
    { if (i < 0) return -i; else return i; });
```



**(2).Binding Arguments**:

- Lambda expression are most useful for 只在一两个地方使用的简单操作, 如果在很多地方使用相同操作, 通常定义一个函数
- 比如```find_if```函数，如果不用捕获, 无法让只接受一个argument的predicate 接受另一个```size_type```的variable, 可以用```bind```来解决这个问题, 定义在```functional``` header中,It takes a **callable object** and generates a new **callable** that “adapts” the parameter list of the original object.
- ```auto newCallable = bind(callable, arg_list);``` : the general form of a call to ```bind```
    -  ```newCallable``` is itself a callable object
    - ```arg_list``` is 逗号分隔的参数列表,对应给```callable```的parameter
        - 也许include names of the form ```_n```, n是整数, 这些参数是"placehorders"(in ```functional``` header),表示```newCallable``` parameters. They stand "in place of" the arguments that will be passed to ```newCallable```: ```_1``` 为```newCallable```第一个参数,```_2``` 为```newCallable```第二个参数
        - The _n names are defined in a namespace named ```placeholders```, ```placeholders```定义在```std```中, 为了使用名字, 必须provide both namespaces. 下面例子中 calls to ```bind``` assume  the existence of appropriate using declarations, the ```using``` declaration for _1 is ```using std::placeholders::_1;```, 表示我们要使用命名```_1```
        - Must provide a separate using declaration for each placeholder name that we use. 这么写容易出错<span style="color:red">**error-prone**</span>, 我们可以用```using namespace std::placeholders;```表示all the names from namespace accessible to our program
    - 当调用```newCallable```, ```newCallable```会调用```callable```, 并传递给它```arg_list```中的参数
- can use bind to bind or rearrange the parameters in the given callable
- **Binding Reference Parameters** 有时we have arguments that we want ot bind by reference or we want to bind an argument that has a type that we cannot copy, 用```ref```:
    - ```ref``` returns an object that contains the given reference and that is itself copyable.标准库中还有另一个```cref```: generates a class that holds a reference to const, 生成一个保存```const```的引用类
        - Modern C++ programs should use bind. 旧版C++提供了```bind1st``` 和 ```bind2nd```有更多限制,已经被deprecated 在新版中 

下面的function bind has only one **placeholder**, which means that check6 takes a single argument。The placeholder appears first in arg_list 对应 ```check_size```的第一个参数 (```const string&```),表示调用```check6```必须一个string 参数
```c++
bool check_size(const string &s, string::size_type sz)
{ return s.size() >= sz; }

// check6 is a callable object(可调用对象) that takes one argument of type string

 // and calls check_size on its given string and the value 6
auto check6 = bind(check_size, _1, 6);

string s = "hello";
bool b1 = check6(s); // check6(s) calls check_size(s, 6)


//使用bind可以改变原来的lambda的find_if

auto wc = find_if(words.begin(), words.end(), [sz](const string &a) 

auto wc = find_if(words.begin(), words.end(), bind(check_size, _1, sz));
```

can use bind to bind or rearrange the parameters in the given callable. 比如assume ```f``` is a callable object that has 5个参数, ```g```is the callable that takes 2 arguments, 传递给```g```的参数按安慰绑定到placeholder, 第一个参数绑定到```_1```, 第二个参数绑定到```_2```, 第一个参数将被传递给```f```的最后一个参数, 第二个参数将被传递给```f```的第三个参数
```c++
// g is a callable object that takes two arguments 

auto g = bind(f, a, b, _2, c, _1);

//calling g(X, Y) calls

f(a, b, Y, c, X)
```

**Using to bind to Reorder Parameters**: use bind to invert the meaning of isShorter by writing
```c++
// sort on word length, shortest to longest

sort(words.begin(), words.end(), isShorter);
// sort on word length, longest to shortest

sort(words.begin(), words.end(), bind(isShorter, _2, _1));
```

**Binding Reference Parameters**: 比如```ostream``` , 因为IO 对象不能拷贝, 

```c++
// os is a local variable referring to an output stream 

// c is a local variable of type char 

for_each(words.begin(), words.end(),
    [&os, c](const string &s) { os << s << c; });

ostream &print(ostream &os, const string &s, char c)
{
    return os << s << c;
}

// error: cannot copy os

for_each(words.begin(), words.end(), bind(print, os, _1, ' '));

for_each(words.begin(), words.end(), bind(print, ref(os), _1, ' '));
```




<br/> <br/> <br/>

## Include Guard

InC and C++, an **#include guard**, sometimes called a **macro guard**, **header guard** or **file guard**, is a particular construct used to avoid the problem of double inclusion when dealing with the include directive.避免double include 

<span style="background-color:#FFFF00">C preprocessor 把include 的file 复制its contents  into a copy of the source file known as translation unit.</span> The files included in this regard are generally header files() 包括了 functions, classes, structs的declarations. If certain C or C++ language constructs are defined twice, the resulting translation unit is invalid (<span style="background-color:#FFFF00">如果被defined两次, translation unit invalid</span>). #include guards prevent this erroneous construct from arising by the double inclusion mechanism.



The addition of <span style="background-color:#FFFF00">**#include guards**</span> to a header file is one way to make that file idempotent. Another construct to combat double inclusion is <span style="background-color:#FFFF00">**#pragma once**</span>, which is non-standard but nearly universally supported among C and C++ compilers.


**Double Inclusion**


File "grandparent.h"
```c++
struct foo {
    int member;
};

```


File "parent.h"

```c++
#include "grandparent.h"

```


File "child.c"

```c++
#include "grandparent.h"

#include "parent.h"

```

Result

```c++

struct foo {
    int member;
};
struct foo {
    int member;
};

```

Here, the file "child.c" has indirectly included two copies of the text in the header file "grandparent.h". This causes a <span style="color:red""> compilation error</span>, since the structure type foo will thus be defined twice. In C++, this would be called a violation of the [one definition rule](https://en.wikipedia.org/wiki/One_Definition_Rule)

**Use of #include guards**

In this section, the addition of #include guards, the C preprocessor preprocesses the header files, including and further preprocessing them recursively. This will result in a correct source file, 

File "grandparent.h"

```c++
#ifndef GRANDPARENT_H
#define GRANDPARENT_H

struct foo {
    int member;
};

#endif /* GRANDPARENT_H */

```

File "parent.h"

```c++
#include "grandparent.h"

```

File "child.c"

```c++
#include "grandparent.h"

#include "parent.h"

```

Result

```c++
struct foo {
    int member;
};
```


Here, the first inclusion of "grandparent.h" causes the macro GRANDPARENT_H to be defined. 在parent 之后, when "child.c" includes "grandparent.h" the second time, the #ifndef test returns false, and the preprocessor skips down to the #endif(<span style="background-color:#FFFF00"> 当第二次include parent.h, ifndef返回false, preprocessor skips to endif </span>), thus avoiding the second definition of struct foo. The program compiles correctly.


## Pointer 

#### Function Pointer

1. Unlike normal pointers, <span style="background-color:#FFFF00">a function pointer points to code</span>, not data. <span style="background-color:#FFFF00"> Typically function pointer stores the start of executable code </span>
2. Unlike normal pointers, <span style="background-color:#FFFF00"> we do not allocate de-allocate memory</span> using function pointers. 不用allocate de-allocate memory 
3. A function's name can also be used to get functions' address. For example, we can use address operator ```&``` or without it. ```void (*fucPtr)() = fun```  or ```void (*fucPtr)() = &fun```, 用不用```&```一样的
4. We can have array of function pointers. <span style="background-color:#FFFF00">必须function parameter 和 return type 都是一样的</span> 
5. Function pointer can be passed an **argument** and can also be **returned** from a function

Pointers to functions
```c++
// fcnPtr is a pointer to a function that takes no arguments and returns an integer

int (*fcnPtr)();
```
上面例子中, ```fcnPtr``` is a pointer to a function that has no parameters and returns an integer, <span style="background-color:#FFFF00">it can point to any function that matches this type</span>. 其中```()``` is necessary. as ```int *fcnPtr()```是<span style="color:red">a declaration for a function named fcnPtr that takes no parameters and returns a point to an integer</span>

**Const function pointer**
```
int (*const fcnPtr)();
```
<span style="background-color#FFFF00">如果put const before int ```const int (* fcnPtr)();```, 表示function being pointed to would return a const int</span>


<span style="background-color#FFFF00">Function pointers can be initialized with a function (and non-const function pointers can be assigned a function) </span>

```c++
int foo()
{
    return 5;
}
 
int goo()
{
    return 6;
}
 
int main()
{
    int (*fcnPtr)() = foo; // fcnPtr points to function foo
    
    fcnPtr = goo; // fcnPtr now points to function goo
 
    return 0;
}
```

One common mistake is to do this: ```fcnPtr = goo();```. This would actually <span style="background-color:#FFFF00">assign the return value from a call to function ```goo()``` to ```fcnPtr```</span>.  是assign funcion 返回的值
    
<span style="color:red">Note the type of the function pointer must match the type of the function </span>   
    
```c++
// function prototypes

int foo();
double goo();
int hoo(int x);
 
// function pointer assignments

int (*fcnPtr1)() = foo; // okay

int (*fcnPtr2)() = goo; // wrong -- return types don't match!

double (*fcnPtr4)() = goo; // okay

fcnPtr1 = hoo; // wrong -- fcnPtr1 has no parameters, but hoo() does

int (*fcnPtr3)(int) = hoo; // okay

```
    
**Calling a function using a function pointer**

<span style="background-color:#FFFF00"> Explicit dereference </span>
```c++
int foo(int x)
{
    return x;
}
 
int main()
{
    int (*fcnPtr)(int) = foo; // assign fcnPtr to function foo

    /* The above line is equivalent of following two 
       int (*fcnPtr)(int); 
       fun_ptr = &fun;  
    */
    
    (*fcnPtr)(5); // call function foo(5) through fcnPtr.

    fcnPtr(5); // call function foo(5) through fcnPtr.
    
    int (*fcnPtr2)() = &foo;//assign pointer to function

    (*fcnPtr2)(5); // call function foo(5) through fcnPtr.

    fcnPtr2(5); // call function foo(5) through fcnPtr.

    return 0;
}
```

<span style="background-color:#FFFF00"> Implicit dereference </span>: 就像normal function call, since normal function names are pointers to functions anyway!
```c++
int foo(int x)
{
    return x;
}
 
int main()
{
    int (*fcnPtr)(int) = foo; // assign fcnPtr to function foo
    
    fcnPtr(5); // call function foo(5) through fcnPtr.
 
    return 0;
}
```

<span style="background-color:#FFFF00">需要注意 **Default parameters won't work for functions called through function pointers**: 因为default parameters are resolved at compiled time(意味着if you don't supply an argument for a defaulted parameter, the compiler substitues one when code is compiled), 但是function pointers are resolved at run-time</span>. Consequently, default parameters cannot be resolved when making a function call with a function pointer. 你不得不pass in vlaues for any defaulted parameteres.

Array of function pointers

```c++
void add(int a, int b){
    cout << "a + b  = "<<a+b<<endl;
}

void subtract(int a, int b){
    cout << "a - b = "<<a+b<<endl;
}

void multiply(int a, int b){
    cout << "a * b = "<<a*b<<endl;
}


int main()
{
    const int r = 3;
    void (* FucPtrArray[])(int, int) = {add, subtract, multiply};
    FucPtrArray[2](5,3);
    // It's the same as (*FucPtrArray[2])(5,3);

}
```

**Passing function as arguments to other functions**

Functions used as arguments to another function are called **callback functions** 比如让用户选择自己的sorting algorithm 在selection sort algorithm,
```c++
bool (*comparisonFcn)(int, int);//因为compare tow interters and return a boolean value

```

```c++
#include <algorithm> // for std::swap, use <utility> instead if C++11

#include <iostream>
 
// Note our user-defined comparison is the third parameter

void selectionSort(int *array, int size, bool (*comparisonFcn)(int, int))
{
    for (int startIndex = 0; startIndex < size; ++startIndex)
    {
        int bestIndex = startIndex;
        for (int currentIndex = startIndex + 1; currentIndex < size; ++currentIndex)
        {
            if (comparisonFcn(array[bestIndex], array[currentIndex])) // COMPARISON DONE HERE

                bestIndex = currentIndex;
        }
 
        // Swap our start element with our smallest/largest element
        
        std::swap(array[startIndex], array[bestIndex]);
    }
}
 
// Here is a comparison function that sorts in ascending order

bool ascending(int x, int y)
{
    return x > y; // swap if the first element is greater than the second
    
}

bool evensFirst(int x, int y)
{
	// if x is even and y is odd, x goes first (no swap needed)
    
	if ((x % 2 == 0) && !(y % 2 == 0))
		return false;
 
	// if x is odd and y is even, y goes first (swap needed)
    
	if (!(x % 2 == 0) && (y % 2 == 0))
		return true;
 
        // otherwise sort in ascending order
        
	return ascending(x, y);
}
 
// Here is a comparison function that sorts in descending order

bool descending(int x, int y)
{
    return x < y; // swap if the second element is greater than the first
    
}
 
 
int main()
{
    int array[9] = { 3, 7, 9, 5, 6, 1, 8, 2, 4 };
 
    // Sort the array in descending order using the descending() function
    
    selectionSort(array, 9, descending);
    printArray(array, 9);
    //9 8 7 6 5 4 3 2 1

 
    // Sort the array in ascending order using the ascending() function
    
    selectionSort(array, 9, ascending);
    printArray(array, 9); 
    //1 2 3 4 5 6 7 8 9
    
    selectionSort(array, 9, evensFirst);
    printArray(array, 9);
    //2 4 6 8 1 3 5 7 9
    
    return 0;
}
```

<span style="background-color:#FFFF00"> Note: If a function parameter is of a function type, it will be converted to a pointer to the function type</span>. It means 
```c++
void selectionSort(int *array, int size, bool (*comparisonFcn)(int, int))
```

is equivalently written as 
```c++
void selectionSort(int *array, int size, bool comparisonFcn(int, int))
```

<span style="background-color:#FFFF00"> This only works for function parameters, not stand-alone function pointers </span>


**Providing default functions**: 下面例子, as long as user calls selectionSort normally(不是通过function pointer), the comparisonFcn parameter will default to ascending. 

```c++
// Default the sort to ascending sort

void selectionSort(int *array, int size, bool (*comparisonFcn)(int, int) = ascending);
```

**Making function pointers prettier with typedef or type aliases**: the syntax for pointers to functions is ugly. However, typedefs can be used to make pointers to functions look more like regular variables:

```c++
typedef bool (*validateFcn)(int, int);
```
This defines a typedef called “validateFcn” that is a pointer to a function that takes two ints and returns a bool.

Now instead of doing this 

```c++
bool validate(int x, int y, bool (*fcnPtr)(int, int)); // ugly

```

You can do this 

```c++
bool validate(int x, int y, validateFcn pfcn) // clean

```

**Using std::function in C++11**: Introduced in C++11, an alternate method of defining and storing function pointers is to use ```std::function```, which is part of the standard library ```<functional>``` header. Both the return type and parameters go inside angled brackets, with the parameters inside parenthesis. If there are no parameters, the parentheses can be left empty. 


    
```c++
#include <functional>

bool validate(int x, int y, std::function<bool(int, int)> fcn); 
// std::function method that returns a bool and takes two int parameters

#include <functional>
#include <iostream>
 
int foo()
{
    return 5;
}
 
int goo()
{
    return 6;
}
 
int main()
{
    std::function<int()> fcnPtr = foo; // declare function pointer that returns an int and takes no parameters
    
    fcnPtr = goo; // fcnPtr now points to function goo
    
    std::cout << fcnPtr(); // call the function just like normal
 
 
    return 0;
}
```

**Type inference for function pointers(Auto)**: the auto keyword can also infer the type of a function pointer.<span style="color:red">The downside is, of course, that all of the details about the function’s parameters types and return type are hidden(**parameters types 和 return types 都是hidden**), so it’s easier to make a mistake when making a call with the function, or using its return value</span>. Unfortunately, type inference won’t work for function parameters (even if they have default values(Auto 不能传入用于function parameters)

```c++
#include <iostream>
 
int foo(int x)
{
	return x;
}
 
int main()
{
	auto fcnPtr = foo;
	std::cout << fcnPtr(5);
 
	return 0;
}
```

<span style="background-color:#FFFF00"> Because the native syntax to declare function pointers is ugly and error prone, we recommend you use typedefs (or in C++11, std::function).</span>

