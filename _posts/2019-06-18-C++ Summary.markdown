---
layout:     post
title:      "C++ Primer - 笔记"
subtitle:   "C++ Primer Summary "
date:       2019-06-18 20:00:00
author:     "Becks"
header-img: "img/post-bg2.jpg"
catalog:    true
tags:
    - Batch
    - 学习笔记
---


```c++

cout<<" File Name "<< __FILE__ << endl; //打印现在file name

cout<<" Line Number "<<__LINE__<<endl; //打印现在现在的行数

```

## Variable and Basic Types

**Object**: an object is a region of memory that has a type. In the book, we will freely use the term *object* regardless of whether the object has built-in or class type, named or unnamed (命名的还是未命名的), or can be read or written.

<span style="background-color: #FFFF00">**Initialization is not assignment**</span>. Initialization happens when a variable is given a value *when it is created*.(创建变量时 赋予它一个初始值). Assignment obliterates an object's current value and replaces that value with a new one (把对象当前值擦除，用一个新值代替)

#### Initialization, Definition, Declaration, Scope

**List Initialization**

下面四种初始化都正确

```c++
int units_sold = 0;
int units_sold = {0};
int units_sold {0};
int units_sold(0);
```

when used with variables of built-in type, List Initialization has one important property: The compiler will not let us initialize variables of built-in type if the initializer might lead to the loss of information. (编译器将会报错，如果使用列表初始化且初始值存在丢失信息的风险). 

```c++
long double id = 3.1415026536;
int a{ld}, b = {ld}; //error: 存在丢失信息风险

int c(ld), d = ld; // 转化执行，但是丢失了部分值 (truncated)
```

The compiler rejects the initializations of a and b because using a long double to initialize an int is likely to lose data. the fractional part of ld will be truncated. (long double 初始化int 变量时可能丢失数据，所以编译器拒绝了a 和 b的初始请求. 至少ld 的小数部分丢失，而且int 也可能存不下ld的整数部分因为是long)


**Default Initialization**

Most classess let us define objects without <span style="color: red">explict initializers</span>. Such classes supply an appropriate default value. e.g. std:string empty; //empty implicitly initialized to the empty string. 

Note: Uninitialized objects of built-in type defined inside a function body have undefined value. Objects of class type that we do not explicitly initialize have a value that is defined by the class.

**Variable Declarations and Definitions**

 <span style="background-color: #FFFF00">**A declaration makes a name known to the program. A definition creates the associated entity.**</span>

A variable **declaration**  <span style="background-color: #FFFF00"> specifies the type and name of a variable</span>. A variable definition is a declaration. In addition to specifying the name and type, a **definition** also <span style="background-color: #FFFF00"> allocates storage and may provide the variable with an initial value</span>. 变量声明规定了变量的类型和名字，在这一点上定义与之相同. 但除此之外, 定义还申请存储空间, 也可能会为变量赋一个初始值

如果想声明一个变量而非定义它，在变量前添加extern

```c++
extern int i; //声明i而非定义i

int j; //声明并定义j
```

任何包含了显示初始化的声明既是定义. 给extern 表含的变量一个初始值，抵消了extern的作用

```c++
extern int i = 5; //定义
```

<span style="background-color: #FFFF00"> Variable must be defined exactly once but can be declared many times</span> 变量只能被定义一次，但可以被声明多次

**Nested Scopes**

<span style="background-color: #FFFF00"> 用 :: 访问global variable (explicitly request global variable) </span>

```c++
int reused = 42;
int main(){
    cout << resused <<endl; // 42

    int reused = 0; //新建局部变量，覆盖全局变量

    cout << resused <<" global " << ::resused <<endl; // 0 , 42

}
```




#### Compound Types


1. reference, pointer:
    - <span style="background-color: #FFFF00">等号两边类型(type)必须相同 </span> type modifier 不一定相同
        - 比如 double dval = 3.14;,int &refVal5 = dval;//error
    - 对于同type modifier <span style="background-color: #FFFF00">拷贝对象时候底层const (low-level) 不能被忽略，顶层(top-level)可以忽略</span>, 详见Pointer and const) 比如 
        - int r = 3; int * const pi = &r(顶层const); int *ref = pi; 是okay的
        - int r = 3; const int * pi = &r(底层const); int *ref = pi; 不okay的
        - int r = 3; const int * pi = &r(底层const); const int *ref = pi; 底层const match
    - 对于没有type modifier的, <span style="background-color: #FFFF00">拷贝对象时候底层const (low-level) </span>可以被忽视
        - const int r = 3(底层const); int i = r;  okay的
    - 对于不同type, (NA -> Pointer, NA-> reference), 不能忽视底层
        - 
2. non-const initialize 等号左右两边类型必须相同（因为reference 不是object） 
3. 对于const(不是), 等号左右两边等号类型可以不同. 
4. **对于const reference 等号两边可以不同类型，compiler会做转换**  const double pi = 3.14; const int & i = pi; //okay
5. 对于non-const pointer, reference, 不能initialize pointe to a const value 比如const double pi = 3.14;  double \* ptr = &pi; wrong; double &ref = pi; //wrong
比如const double pi = 3.14; int p2 = pi;


A **compount type** is a type that is defined in terms of another type, which is references and pointers

**Reference** (At here, reference is only lvalue reference not rvalue reference)

<span style="background-color: #FFFF00"> reference must be assigned at initlization </span>. 程序把引用和初始值绑定(bind)到一起，而不是将初始值拷给引用, 引用无法绑定到另一个对象. <span style="color: red"> **A reference is not an object**. Instead, a reference is just another name for an already existing object </span>


```c++
int val = 1024;
int &refval = val, &r = i; // correct

refval = 2; //val = 2

int &refval2; //error

int &refval3 = 10 ;//error: initializer must be an object

double dval = 3.14;
int &refVal5 = dval; // error: initializer must be an int object
```

We can define multiple references in a single definition

```c++
int i2 = 2048; // i and i2 are both ints 

int i3= 1024, &ri = i3; // i3 is an int;ri is a reference bound to i3 

int &r3 = i3, &r4 = i2; // both r3 and r4 are references
```



**Pointer**

assign pointer 需要assign 的类型和被assign 类型compatible. **Pointer is a object whereas reference is not object**

```c++
double dval;
double *pd = &dval; //ok: initializer is the address of a doub;e

double *p2 = pd;//ok: initializer is a pointer to doub;e

int *pi = pd;//error: types of pi and pd differ, 一个int,一个double
pi = &dval; //error: assigning the address of a double to a pointer to int

//上面两个error 都会compile fail


int dval;
double *pi = &dval;//error: types of pi and pd differ, 一个int,一个double, 也是compile error


```

<span style="background-color: #FFFF00">It is error to copy or try to access the value of an invalid pointer</span>. As when we use an uninitialized variable, <span style="color: red">this error is one that the compiler is unlikely to detect(编译器不会检查access invalid pointer)</span>. The result of accessing an invalid pointer is undefined. 


& 赋值是改变等号左侧 pointer指代对象, \* 不改变指代对象，改变的是指代对象的值 
```c++
int r = 1;
int *p = &r;
int *p2 = p;
    
*p2 = 10; //change pointed value, aslo change value of the object pointer points to
cout << *p <<" , "<<*p2  <<" , "<< r <<endl; //print 10 ,10, 10

int c = 5;
p = &c; //change object that pointer points to
cout << *p  <<" , "<< r <<" , "<< c<<endl;//print 5, 10 , 5

```

Given two valid pointers of the same type, we can compare them use<span style="background-color: #FFFF00"> the equality(==) or inequality(!=) operator, Two pointers are equal if the yhold the same address (两个指针存放的地址相同) </span>


__ void \* __


The type void\* is a special pointer type that can hold the address of any object. (可以存放任意对象).  Like any other pointer, a void* pointer holds an address, but the type of the object at that address is unknown: <span style="background-color: #FFFF00"> 不了解地址中是个什么类型的对象</span>. Generally,we use a void* pointer to deal with memory as memory, rather than using the pointer to access the object stored in that memory. 


a variable definition consists of a base type and a list of declarators. Each declarator can relate its variable to the base type differently from the other declarators in the same definition. 

int\* p1, 修饰符 (type modifier \*)仅仅是修饰一个variable, 而非修饰整行所有变量, prefer using int \*p1;

```c++
int i = 1024, *p = &i, &r = i;// i is an int; p is a pointer to int; r is a reference to int

int* p1, p2;//p1 is a pointer to int; p2 is an int (not pointer), 

//上面的*， 仅仅修饰了p1, 而非让所有变量的类型一样都是int pointer

int *p1, *p2; // both p1 and p2 are pointers to int
```

**Pointers to Pointers**

```c++
int ival = 1024;
int *pi = &ival; // pi points to an int

int **ppi = &pi; // ppi points to a pointer to an int


cout << "The value of ival\n"
    << "direct value: " << ival << "\n" 
    << "indirect value: " << *pi << "\n"
     << "doubly indirect value: " << **ppi << endl;//print 1024, 1024, 1024

```

**References to Pointers**

A reference is not an object. Hence, we may not have a pointer to a reference. However, because a pointer is an object, we can define a reference to a pointer:


```c++

int i = 42; 
int *p; //p is a pointer to int

int *&r = p;  // r is a reference to the pointer p
//cannot write as  int &*r = p; because reference don't have pointer, but pointer has refernece

r = &i;// r refers to a pointer; assigning &i to r makes p point to i

*r = 0; // dereferencing r yields i, the object to which p points; changes i to 0

```

<span style="background-color: #FFFF00"> **离变量名最近的符号(symbol， 上面例子 &r 的符号& ) 对变量类型有最直接的影响, 因此r是一个引用;**</span>

#### Const Qualifier


we can’t change the value of a const object after we create it, it must be initialized. (const 对象必须初始化). 

```c++

const int i = get_size(); // ok: initialized at run time 

const int j = 42; // ok: initialized at compile time 

const int k; // error: k is uninitialized const

```

<span style="background-color: #FFFF00">when we use an object to initialize another object, it doesn’t matter whether either or both of the objects are consts(如果用一个对象初始化另一个对象，则他们是不是const 都不要紧)</span>. Below example, Although ci is a const int, the value in ci is an int. The constness of ci matters only for operations that might change ci.(ci的constness 只能当改变ci时才会发生作用) When we copy ci to initialize j, we don’t care that ci is a const. <span style="background-color: #FFFF00">const 的variable 可以用来initialzie non-const variable， 但是const reference 不能bind 到non-const reference，因为reference is not object </span>

```c++

int i = 42;
const int ci = i; // ok: the value in i is copied into ci 

const int &  c_r = i;
int j= ci; // ok:the value in ci is copied into j

int & j_r = c_r; //error cannot bind non-const reference initialize to const reference

```

const int bufSize = 512; <span style="color: red"> the compiler will usually replace uses of the variable with its corresponding value during compilation.</span> That is, the compiler will generate code using the value 512 in the places that our code uses bufSize. Compiler会找到代码中所有用到bufSize的地方，然后用512代替。

 <span style="color: red"> **不能用非const reference 指向const object </span>


```c++

const int ci = 1024;
int &r2 = ci;// error: non const reference to a const object

int i = 42;
```

**One exception for const references**: initailize const from any expression that can be converted to the type of the reference. <span style="background-color: #FFFF00">当initilize const reference, 我们可以用任意表达式. </span>

```c++

int i = 42;
const int &r1 = i; // we can bind a const int& to a plain int object 

const int &r2 = 42; // ok: r1 is a reference to const

const int &r3 = r1 * 2; // ok: r3 is a reference to const

int &r4 = r1 * 2; // error: r4 is a plain, non const reference


```
to understand this exception in initialization rules:

```c++

double dval = 3.14;

const int &ri = dval; //okay,

```

上面例子中.To sure object to which ri is bound is an int, compiler transforms the code into something like

```c++

const int temp = dval;//create a temporary const int from the double

const int &r1 =temp;//bind ri to that temporary

```

In this case, ri is bound to a **temporary object**. A temporary object is an unnamed object created by the compiler when it needs a place to store a result from evaluating an expression. 而加入ri 不是const, if ri weren't const, we 允许ri赋值, 这样做would change the object to which ri is bound.（会改变ri 引用对象的值), 而对于ri, <span style="color: red">如果我们改变ri,想的是改变dval,但是绑定的不是dval, 而是一个temporary object</span>. C++ will make it illegal


**A Reference to const May Refer to an Object That Is Not const**

It is important to realize that a reference to const restricts only what we can do through that reference. Binding a reference to const to an object says nothing about whether the underlying object itself is const. Because the underlying object might be nonconst, it might be changed by other means. span style="color: red">const reference 并没有说underlying object是const, underlying object可能不是const，也可以被修改</span>

```c++

int i = 42;
int&r1=i; //r1 boundto i

const int &r2 = i; //r2 also bound to i; but cannot be used to change i


r1=0; // r1 is not const; i is now 0
//r2 = 0;//error: r2 is a reference to const

cout<<i<< ", "<<r1<<", "<<r2<<endl; //print 0, 0 , 0

```


**Pointer and const**

**low-level const**(object is const): const 在pointer 左面表data is const, cannot change underlying data value. but can point to different underlying. <br/>
**top-level const**(pointer is const): const 在pointer 右面表示 pointer is const (**a const pointer**), 不能改变指向对象，但可以改变the value of underlying object

顶层const 可以表示任意对象是const, 这一点对任何数据类型都是用，比如built-in arithmetic types, a class type, or a pointer type. Low-level则与pointer, reference 有关, pointer既可以是low level const 也可以是top-level const 

```c++

int i = 0;
int *const p1 = &i; // we can't change the value of p1; const is top-level 

const int ci = 42; // we cannot change ci; const is top-level

const int *p2 = &ci; // we can change p2; const is low-level

const int *const p3 = p2; // right-most const is top-level, left-most is not

const int &r = ci; // const in reference types is always low-level

```

<span style="background-color: #FFFF00">The distinction between top-level and low-level matters when we copy an object</span>. When we copy an object, **top-level consts are ignored:**

```c++

i = ci; // ok: copying the value of ci; top-level const in ci is ignored 

p2 = p3; // ok: pointed-to type matches; top-level const in p3 is ignored

```

<span style="background-color: #FFFF00">On the other hand, low-level const is never ignored.(lower-level 从不会被忽略)</span>.  When we copy an object, both objects must have the same low-level const qualification or there must be a conversion between the types of the two objects(拷贝 输出对象必须具有相同的底层const 资格). In general, we can convert a nonconst to const but not the other way round:

```c++

int *p = p3; // error: p3 has a low-level const but p doesn't

p2 = p3; // ok: p2 has the same low-level const qualification as p3

p2 = &i; // ok: we can convert int* to const int*

int &r = ci; // error: can't bind an ordinary int& to a const int object 

const int &r2 = i; // ok: can bind const int& to plain int

```

The types of a pointer and the object to which it points must match(等号左右两边类型必须match). 

The first exception is that we can use a pointer to const to point to a nonconst object: 可以用const pointer指向non-const object

```c++

const double pi = 3.14; // pi is const; its value may not be changed

double *ptr = &pi; // error: ptr is a plain pointer

const double *cptr = &pi; // ok: cptr may point to a double that is 

const *cptr = 42; // error: cannot assign to *cptr

double dval = 3.14; // dval is a double; its value can be changed
 
cptr = &dval; // ok: but can't change dval through cptr


```

```c++

double pi = 3.14159;
const double *const pip = &pi; // pip is a const pointer (在pointer右边的const) to a const object

```



## Include Guard

InC and C++, an **#include guard**, sometimes called a **macro guard**, **header guard** or **file guard**, is a particular construct used to avoid the problem of double inclusion when dealing with the include directive.避免double include 

<span style="background-color:#FFFF00">C preprocessor 把include 的file 复制its contents  into a copy of the source file known as translation unit.</span> The files included in this regard are generally header files() 包括了 functions, classes, structs的declarations. If certain C or C++ language constructs are defined twice, the resulting translation unit is invalid (<span style="background-color:#FFFF00">如果被defined两次, translation unit invalid</span>). #include guards prevent this erroneous construct from arising by the double inclusion mechanism.



The addition of <span style="background-color:#FFFF00">**#include guards**</span> to a header file is one way to make that file idempotent. Another construct to combat double inclusion is <span style="background-color:#FFFF00">**#pragma once**</span>, which is non-standard but nearly universally supported among C and C++ compilers.


**Double Inclusion**


File "grandparent.h"
```c++
struct foo {
    int member;
};

```


File "parent.h"

```c++
#include "grandparent.h"

```


File "child.c"

```c++
#include "grandparent.h"

#include "parent.h"

```

Result

```c++

struct foo {
    int member;
};
struct foo {
    int member;
};

```

Here, the file "child.c" has indirectly included two copies of the text in the header file "grandparent.h". This causes a <span style="color:red""> compilation error</span>, since the structure type foo will thus be defined twice. In C++, this would be called a violation of the [one definition rule](https://en.wikipedia.org/wiki/One_Definition_Rule)

**Use of #include guards**

In this section, the addition of #include guards, the C preprocessor preprocesses the header files, including and further preprocessing them recursively. This will result in a correct source file, 

File "grandparent.h"

```c++
#ifndef GRANDPARENT_H
#define GRANDPARENT_H

struct foo {
    int member;
};

#endif /* GRANDPARENT_H */

```

File "parent.h"

```c++
#include "grandparent.h"

```

File "child.c"

```c++
#include "grandparent.h"

#include "parent.h"

```

Result

``````c++
struct foo {
    int member;
};
```


Here, the first inclusion of "grandparent.h" causes the macro GRANDPARENT_H to be defined. 在parent 之后, when "child.c" includes "grandparent.h" the second time, the #ifndef test returns false, and the preprocessor skips down to the #endif(<span style="background-color:#FFFF00"> 当第二次include parent.h, ifndef返回false, preprocessor skips to endif </span>), thus avoiding the second definition of struct foo. The program compiles correctly.

