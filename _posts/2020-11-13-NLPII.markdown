---
layout:     post
title:      "Natural Language Processing II"
subtitle:   "Trax, Encoder Decoder"
date:       2020-11-13 20:00:00
author:     "Becks"
header-img: "img/post-bg-os-metro.jpg"
catalog:    true
tags:
    - Deep Learning
    - Machine Learning
    - NLP
    - 学习笔记
---

<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script>


## 3.1 Trax: Neural Networks


Neural Network predict tweets sentiment, structure:

- Input is a vector of Integers, assign each word based on index from vocabulay and apply padding set length as maxlen of sentence of the tweet
- Embedding layer: transform the representation 
- Hidden layer with a ReLU activation function 
- output layer with softmax function that give probabilities for whether a tweet is positive or negative sentiment

This structure allow to predict complex tweets: 比如 "This movie was almost good". 不能 classify correctly using simpler method 比如 Naive Bayes


![](/img/post/Natural-Language-Processing/course3/week1pic1.png)

![](/img/post/Natural-Language-Processing/course3/week1pic2.png)

#### Trax

List the layer from left to right. Note Dense layer(fully-connected layer): A maps collections of R^m vectors to R^n, where n (= n_units) is fixed at layer creation time,. Fully computation is ```y = Wx + b```. Generally followed by a non-linear activation function. 

![](/img/post/Natural-Language-Processing/course3/week1pic3.png)



**Advantage: (Trax is based on Tensorflow, use Tensorflow as a backend, also use JAX library to speed up computation)**

- <span style="background-color:#FFFF00">Run fast on CPUs, GPUs and TPUs</span>(perform computations efficiently), don't need to change a single line of code for running on CPU, GPU, TPU
  - Run code fast (than tensorflow / PyTorch): Trax can run on-demand or preemptible Cloud without changing a single line of code 
- <span style="background-color:#FFFF00">allow parallel computing</span>: allow model running on multiple machines or cores simultaneously
- Record algebraic computations for gradient evaluation, so they <span style="background-color:#FFFF00">compute gradient automatically</span>.
- Makes programmers efficient: Easy to Debug and understand (code structure like original paper)

Trax Development History: TensorFlow (2014-2015) -> Translate(2016, long time to train, not practical for anyone else other than Google) -> Tensor2Tensor(2017, userd by many large companies in the word. Complicated but not nice to learn, hard for new researchers) -> Trax

Trax： Deep Learning library with Clear Code and Speed


Some Resource

- [Official Trax documentation maintained by the Google Brain team](https://trax-ml.readthedocs.io/en/latest/)
- [Trax source code on GitHub](https://github.com/google/trax)
- [JAX library](https://jax.readthedocs.io/en/latest/index.html)

Python Class & Subclass(subclass can override method in super class )

![](/img/post/Natural-Language-Processing/course3/week1pic4_1.png)
![](/img/post/Natural-Language-Processing/course3/week1pic4_2.png)


#### Trax Layers

**Dense Layer**: The single inner product between trainable wights and input vector is called **Dense layer** computed as  ```y = np.dot(x, w)``` 而不是 `np.dot(w, x)` 是为了方便计算

- <span style="background-color:#FFFF00">The number of columns(second dimension) in the weight matrix is the number of units chosen for that dense layer. (output 的unit)</span>

![](/img/post/Natural-Language-Processing/course3/week1pic5.png)

```python
X = Input(shape= (3,))
X_out  = Dense(units = 4)(X)
model = Model(inputs = X, outputs = X_out)
print(model.summary())
# Layer (type)                 Output Shape              Param #   

# =================================================================

# Input_17 (InputLayer)        [(None, 3)]         0         

# _________________________________________________________________

# dense_11 (Dense)             (None, 4)           16        

# =================================================================

# Total params: 16

# Trainable params: 16

# Non-trainable params: 0

e2 = model.layers[0].get_weights()
print(len(e2)) # 2, W and b 

print(e2[0].shape) # (3, 4)



X = Input(shape= (2, 3))
X_out  = Dense(units = 4)(X)
model = Model(inputs = X, outputs = X_out)
print(model.summary())
# Layer (type)                 Output Shape              Param #   

# =================================================================

# Input_17 (InputLayer)        [(None, 2, 3)]         0         

# _________________________________________________________________

# dense_11 (Dense)             (None, 2, 4)           16        

# =================================================================

# Total params: 16

# Trainable params: 16

# Non-trainable params: 0

e2 = model.layers[0].get_weights()
print(len(e2)) # 2, W and b 

print(e2[0].shape) # (3, 4)

```

**ReLU Layer**: activation layer that follows a dense fully connected layer, and transforms any negative values to zero.

![](/img/post/Natural-Language-Processing/course3/week1pic6.png)

**Serial Layer**: a composition of sublayers layers that operates sequentially to perform the forward computation of entire model. Can think of serial layer as whole neural network model in one layer

![](/img/post/Natural-Language-Processing/course3/week1pic7.png)

**Embedding Layer**: map words from vocabulary to representation of that word with determined dimension, 下面例子 embedding size = 2.

- In Trax, model learn representation of embedding that give the best performance. 
- Size of weight = `Vocabulary size x # Embedding`
- <span style="background-color:#FFFF00">size of embedding is **hyperparameter**</span> in the model

![](/img/post/Natural-Language-Processing/course3/week1pic8.png)

**Mean Layer**: Take means of each features from embedding. After mean layer,<span style="background-color:#FFFF00"> will have the same number of featurres as embedding size</span>. Note: <span style="color:red">No trainable parameters because it's only computing the mean of word embeddings</span>

- `trax.layers.tl.Mean`: Calculates means across an axis. Choose `axis = 1` (`axis = 0` is batch size)to get an average embedding vector (an embedding vector that is an average of all words in the vocabulary). 

```python
# Pretend the embedding matrix uses  2 elements for embedding the meaning of a word

# and has a vocabulary size of 3, So it has shape (2,3)

tmp_embed = np.array([[1,2,3,],
                    [4,5,6]
                   ])
print("The mean along axis 0 creates a vector whose length equals the vocabulary size")
display(np.mean(tmp_embed,axis=0)) # DeviceArray([2.5, 3.5, 4.5], dtype=float32)

print("The mean along axis 1 creates a vector whose length equals the number of elements in a word embedding")
display(np.mean(tmp_embed,axis=1)) # DeviceArray([2., 5.], dtype=float32)

```

![](/img/post/Natural-Language-Processing/course3/week1pic9.png)


- TrainTask: ```trax.supervised.training.TrainTask(labeled_data, loss_layer, optimizer, lr_schedule=None, n_steps_per_checkpoint=100)```:  A supervised task (labeled data + feedback mechanism) for training. ```init``` parameter 有
  - labeled_data: Iterator of batches of labeled data tuples. Each tuple has 1+ data (input value) tensors followed by 1 label (target value) tensor.  All tensors are NumPy ndarrays or their JAX counterparts.
  - n_steps_per_checkpoint: How many steps to run between checkpoints. <span style="color:red">每run n_steps_per_checkpoint 会print出loss_layer，如果有eval_task, 同样也会run eval_task，然后print eval task metrics</span>
   
- EvalTask, ```EvalTask(labeled_data, metrics, metric_names=None, n_eval_batches=1)``` Labeled data plus scalar functions for (periodically) measuring a model. 
  - labeled_data: Iterator of batches of labeled data tuples. Each tuple has 1+ data tensors (NumPy ndarrays) followed by 1 label (target value) tensor. ```[tl.CrossEntropyLoss]```

- Training.Loop: ``Loop(model, task, eval_model=None, eval_task=None, output_dir=None, checkpoint_at=None, eval_at=None)`` Loop that can run for a given number of steps to train a supervised model. The typical supervised training process randomly initializes a model and updates its weights via feedback (loss-derived gradients) from a training task, by looping through batches of labeled data. 
 
#### Gradient in Trax

- function ```grad``` return a function that computes the gradients of f
  - allows much easier training
- forward and backward in a single line 
  - Notice the double parentheses, 第一个是 pass grad function, 第二个pass是arguments returned by grad

![](/img/post/Natural-Language-Processing/course3/week1pic10.png)

![](/img/post/Natural-Language-Processing/course3/week1pic11.png)


## 3.2 RNN for Language Modeling

**Problem with N-grams**: for N grams, model <span style="background-color:#FFFF00">have to account for conditional probabilites for long sequences, difficult to estimate for long corpora</span>: Need a lot of space and RAM. e.g. if user download app, may not have enough space to store n-grams. 

![](/img/post/Natural-Language-Processing/course3/week2pic1_1.png)
![](/img/post/Natural-Language-Processing/course3/week2pic1_2.png)

#### RNN 

**RNN**: Looks at previous N words, propagate the information from the beginning to the end

e.g. 下面例子，tri-gram probabable choose "have": because "*did not have*" is high probable in text corpus. But if choose "*have*" => sentence not make sense. If want to predict using  n-gram, have to account 6-grams, **impractical**

![](/img/post/Natural-Language-Processing/course3/week2pic2_1.png)
![](/img/post/Natural-Language-Processing/course3/week2pic2_2.png)

- Each box represent the computation made at each steps and colors represent the information used for every computation. The computation at the last step have the information from all the words in the sentence 
- Every word in the sequence is multiplied by the same weight $$W_x$$, the information propagate from the beginning to the end is multiplied by $$W_h$$. 
- The block is repeated for every word in the sequence. The only learning parameters are $$W_x, W_h$$. They compute values that are fed over and over again until the prediction is made.

<span style="background-color:#FFFF00">Advantage of RNN</span>
- RNN model relationships among distant word
- Note:An RNN would have the same number of parameters for word sequences of different lengths. (<span style="color:red">**Computations share parameters**</span>)

![](/img/post/Natural-Language-Processing/course3/week2pic3.gif)


Many to Many architecture, at each time step, <span style="background-color:#FFFF00">two inputs, x, hidden state h</span>. Make a prediction $$\hat y$$. Additionally, it propagate a new hidden state to the next time-step. The hidden state at every time t is computed with an activation function g. After computing the hidden state at time t, possible to get the prediction $$\hat y$$ by using an activation function g 


$$ \begin{align}   h^{<{t}>}& = g\left(W_h \left[  h^{<{t-1}>},  x^{<{t}>} \right] + b_h \right) \\

& = g\left(W_{hh} h^{<{t-1}>} \oplus  W_{hx} x^{<{t}>} + b_h \right) \quad  \oplus \text{sum up element-wise} \\
\end{align} $$


$$ W_h = \left[W_{hh} \mid W_{hx} \right] \quad \color{red}{\text{Horiztonal Stack}}$$

$$\left[  h^{<{t-1}>},  x^{<{t}>} \right]= \left[ \frac{h^{<{t-1}>}}{x^{<{t}>}} \right] $$

$$ \hat y^{<{t}>} = g \left( W_{y_h} h^{<{t}>} + b_h \right)$$

Many-to-many architecture 

![](/img/post/Natural-Language-Processing/course3/week2pic5.png)

First step of the RNN

![](/img/post/Natural-Language-Processing/course3/week2pic6_1.png)
![](/img/post/Natural-Language-Processing/course3/week2pic6_2.png)

e.g. if $$ h^{<{t}>}$$ size is 4 x 1, $$ x^{<{t}>}$$ size is 10 x 1, what is the size of $$W_h$$, given  $$ h^{<{t}>} = g\left(W_h \left[  h^{<{t-1}>},  x^{<{t}>} \right] + b_h \right)$$

Q: `4 x 14`. In deep learning framework, it is `14 x 4`



#### Application

 **One to One**:  Give lists of score from favorite team to predict the position of your team on the leaderboard

![](/img/post/Natural-Language-Processing/course3/week2pic4_1.png)


**One to Many**: Given picture => predict caption

![](/img/post/Natural-Language-Processing/course3/week2pic4_2.png)

**Many to One**: Sentiment Analysis

![](/img/post/Natural-Language-Processing/course3/week2pic4_3.png)

**Many to Many**: machine translation: encode and decoder architecture is popular for machine translation. First half doesn't return output is called **Encoder**, because it encodes the sequences of words in a single representation that caputres the overall meaning of the sentence. **Decoder** generate a sequence of words in other language.


![](/img/post/Natural-Language-Processing/course3/week2pic4_4.png)

#### Cost Function


k: the number of category/class. $$y_j = $$ 0 or 1 for each class, 比如下图output 3 classes

![](/img/post/Natural-Language-Processing/course3/week2pic7.png)

For RNN: 

$$ J = -\frac{1}{T} \sum_{t=1}^T \sum_{j=1}^K y_j^{<{t}>} log \hat y_j^{<{t}>} $$, 与上面普通neural network cost function difference is summation over time T and division by the total number of steps T: is the <span style="background-color:#FFFF00">average of the cross entropy loss function over time</span>

![](/img/post/Natural-Language-Processing/course3/week2pic8.png)

#### Scan Function

- Scan function is to take a function `fn`( equivalent to 下图中的 $$f_w$$), and apply to all the elements from beginning to end in the list ```elems``` ($$x^{<{t_1}>}, x^{<{t_2}>} ... x^{<{T}>}$$))
- ```elems``` is all the input through the time
- Initializer (the hidden state $$h^{<{t_0}>}$$) is an optimal variable that could be used in the first computation of `fn` （下图的中fn 是 $$f_W$$)
- Function first initialize hidden states $$h^{<{t_0}>}$$, set ys as an empty list  
- For every x in the list of elements, `fn` is called with x and the last hidden state as arguments, 
- For loop computes every time step for RNN, stores prediction value and hidden states
- Finally, function <span style="color:red">returns a list of predictions, and last hidden state</span>
- <span style="color:red">Framework like Tensorflow need this type of **abstraction** in order to perform **parallel computing** and run on GPUs.</span>

<span style="background-color:#FFFF00">**Advangtage of Scan function**</span>:

- <span style="background-color:#FFFF00">Faster training</span>
- <span style="background-color:#FFFF00">Allow parallel computing</span>

![](/img/post/Natural-Language-Processing/course3/week2pic9.png)

#### Gated Recurrent Units

- control how much information forget from the past and how much information to extract from current input. 
- allow relevant information to be kept in the hidden states, even over long sequences. 比如下面例子，Ants learn Plural. GRU complete it by computing irrelevance and update gates. Can GRUS as Vanilla RNN with additional computations

$$\Gamma_r = \sigma \left(W_r \left[  h^{<{t-1}>},  x^{<{t}>} \right] + b_r \right)  $$

$$\Gamma_u = \sigma \left(W_u \left[  h^{<{t-1}>},  x^{<{t}>} \right] + b_u \right)  $$

$$h^{'<{t}>} = tanh\left(W_h \left[ \Gamma_r *  h^{<{t-1}>},  x^{<{t}>} \right] + b_h \right)  $$

$$h^{<{t}>} = \Gamma_u *  h^{<{t}>} + \left( 1- \Gamma_u\right) * h^{<{t-1}>} $$

$$y^{<{t}>} = g\left(W_y  h^{<{t}>} + b_y \right)$$


1. The first two computation in GRU are <span style="background-color:#FFFF00">**relevance gate**</span> $$\Gamma_r$$,  <span style="background-color:#FFFF00">**update gate**</span> $$\Gamma_u $$ computed from sigmoid function. The output vectors of value are between 0 and 1. <span style="color:red">The output help determine which information from the previous hidden state is relevant and which values should be updated with current informations</span>
2. <span style="background-color:#FFFF00">Update gate determines how much of information from the previous hidden state will be overwrited</span>. 
3. $$h^{'<{t}>} $$ is a hidden state candidate that could overwrite previus hidden state
4. a prediction $$\hat y$$ is computed using current hidden state

![](/img/post/Natural-Language-Processing/course3/week2pic10.png)

**Vanilla RNN vs GRUs**: 

- **Problem with Vanilla**: update the hidden state at every time step, for a long sequences, information tends to vanish. So called <span style="background-color:#FFFF00">**vanishing gradients problem**</span>
- GRUs compute significantly more operations, can cause longer processing times and memory usage. <span style="background-color:#FFFF00">GRUS help preserve important information for longer sequences</span> by deciding how to update the hidden state. 

![](/img/post/Natural-Language-Processing/course3/week2pic11_1.png)

![](/img/post/Natural-Language-Processing/course3/week2pic11_2.png)


```python
mode = 'train'
vocab_size = 256
model_dimension = 512
n_layers = 2

GRU = tl.Serial(
      tl.ShiftRight(mode=mode), # Do remember to pass the mode parameter if you are using it for interence/test as default is train 

      tl.Embedding(vocab_size=vocab_size, d_feature=model_dimension),

      [tl.GRU(n_units=model_dimension) for _ in range(n_layers)], # You can play around n_layers if you want to stack more GRU layers together

      tl.Dense(n_units=vocab_size),
      tl.LogSoftmax()
    )


def show_layers(model, layer_prefix="Serial.sublayers"):
    print(f"Total layers: {len(model.sublayers)}\n")
    for i in range(len(model.sublayers)):
        print('========')
        print(f'{layer_prefix}_{i}: {model.sublayers[i]}\n')
        
#show_layers(GRU)

#Total layers: 6

# ========

#  Serial.sublayers_0: ShiftRight(1)

# ========

# Serial.sublayers_1: Embedding_256_512

# ========

# Serial.sublayers_2: GRU_512

# ========

# Serial.sublayers_3: GRU_512

# ========

# Serial.sublayers_4: Dense_256

# ========

```

#### Deep Bidiretion RNN

e.g. 比如下面例子blank 来自于后下文

![](/img/post/Natural-Language-Processing/course3/week2pic12.png)

Could have another architecture where the information flow from end to beginning. 

- <span style="background-color:#FFFF00">Information flows from the past(from left to right) and from the future(from right to left) independently</span> (acyclical graph)
- Get prediction $$\hat y$$, <span style="color:red">have to start propagate information from both directions</span>
  - After compution all the hidden states for both directions, can get all of remaining predictions. 

$$y^{<{t}>} = g\left(W_y  \left[ \vec h^{<{t}>}, \overleftarrow h^{<{t}>} \right]  + b_y \right)$$

![](/img/post/Natural-Language-Processing/course3/week2pic13.gif)

**Deep RNNs** are similar to deep neural networks. Deep RNN have a layer which takes input sequence x and multiple additional hidden layers. Like RNN **stack** together. 

- Deep RNNs have more than one layer, which helps in complex tasks

$$h^{\left[l \right]<{t}>} = f^{\left[l \right]} \left(W_h^{\left[l \right]}  \left[ h^{\left[l \right]<{t-1}>} , a^{\left[l-1 \right]<{t}>}  \right]  + b_h^{\left[l \right]}  \right)$$

$$a^{\left[l \right]<{t}>} = f^{\left[l \right]} \left(W_a^{\left[l \right]} h^{\left[l \right]<{t}>}   + b_a^{\left[l \right]}  \right)$$

1. Get hidden states for current layer: At first progragate information through time. 
2. pass the activations to next layer. Go deeper in the network and repeat the process for each layer until get prediction
  

![](/img/post/Natural-Language-Processing/course3/week2pic14_1.png)
![](/img/post/Natural-Language-Processing/course3/week2pic14_2.png)

## 3.3 LSTMs and Named Entity Recognition

**Simple RNN Advantages**:

- <span style="color:red">**Capture dependencies within a short range**</span>
- Takes up **less RAM and space**(lightweight) than other n-gram models

**Simple RNN Disadvantages**:

- Struggles with longer sequence
- Prone to vanishing or exploding gradients: This can arise <span style="color:red">due to the fact that RNN progagates information from the beginning of the sequence to the end</span>. 
  - Starting with first words, the first values are computed(下图橙色框). Then it propagates some computed information takes the second word in the sequence, an gets new value(下图绿色框). Final steps, computations contain information from all the words in the sequence, then RNN predict next word. 
  - <span style="color:red">Notice: the information from first step doesn't have much influence on the output.</span>  Orange portion from the first step decrease with each new step, and <span style="background-color:#FFFF00">**the computation at the first steps don't have much influence on the cost function**</span>. 

![](/img/post/Natural-Language-Processing/course3/week3pic1.png)

#### Vanishing/Exploding Gradient 

Backprop:  The derivatives from each layer are multiplied from back to front in order to compute the derivative of initial layer.  The weights receive an update is proportional to the gradients with respect to the current weights of that time step. But in the network with<span style="color:red"> many time steps or layers, gradient arrived back at early layers as the **product** of all the terms from the later layer -> make unstable situation. Especially if the values become so small -> no longer updates properly</span>. For exploding gradients, work in opposite direction <span style="color:red">as updated weights become so large causing network to become unstable.</span>(numerical overflow)

![](/img/post/Natural-Language-Processing/course3/week3pic2.png)

Solution: 

- **Identity RNN with ReLU activation**: Initialize weights as indentity matrix: what it does, copy previous hidden state, add information from current inputs and replace any negative values with 0. Has effects of your network to stay close to the values in the **indentity matrix** which act like 1s during matrix multiplication
  - <span style="background-color:#FFFF00">**only works for vanishing gradients**</span>, as derivatives of ReLu = 1 for all values greater than 0
- **Gradient clippings**: simply choose a relevant value that clip the gradients e.g. 25. Using this technique, any value grater than 25 will be clipped to 25
  - <span style="background-color:#FFFF00">**works for exploding gradients**</span>. serves to limit the magnitute of gradients. 
- **Skip connections**: provide a direct connection to earlier layers, effectively skips over activation functions, add values from initial inputs x to outputs, e.g. F(x) + x. so <span style="background-color:#FFFF00">activations from eariler layers have more influence over the **cost function**</span>


![](/img/post/Natural-Language-Processing/course3/week3pic3.png)

<span style="background-color:#FFFF00">下图可能有vanishing gradient problem, because for a good model, performance should improve accuracy through time</span>

![](/img/post/Natural-Language-Processing/course3/week3pic4.png)



#### LSTM

**Application for LSTM**

- Next-character prediction for email
- chatbots capable of remembering longer conversations
- music composition: consider music is built using long sequences of notes, much like text uses long sequences of words
- image caption
- speech recognition

LSTM: special variety of RNN handle entire sequences of data by learning when to remember and when to forget, similar to GRU

-  cell state $$c^{<{t_0}>}$$: can think of cell as memory of your network, carrying all the relevant information down the sequence. 
  - As cell travels, each gate adds or removes information from cell state
- Three hidden states gates. Gates allows gradients to flow unchanged. -> so <span style="background-color:#FFFF00">vanishing/exploding gradient is mitigated</span>
  - Forget gate decides what to keep
  - Input gate decides what to add
  - Output gate decides what the next hidden state will be

Structure:


![](/img/post/Natural-Language-Processing/course3/week3pic5.png)


Note: The tanh layer’s output (between -1 and 1) is multiplied **element-wise** by the sigmoid layer’s output /update gate. ensuring an even flow through the LSTM unit.  This prevents any of the values from the current inputs from becoming so large that they make the other values insignificant. Ensures the values in your network stay numerically stable,
    - $$h^{'<{t}>}$$ and $$\Gamma_u$$; $$tanh\left(h^{<{t}>}\right)$$ and $$\Gamma_o$$ are all element-wise product


#### NER

NER: Named Entity Recognition: fast and efficient way to scan text for certain kinds of information.
-  NERs sytems locate and extract named entities from text.
-  Name entities can be a place, an organization or a person's name, can even be times and dates.  


![](/img/post/Natural-Language-Processing/course3/week3pic6.gif)


- B dashes denotes entity 
- All other words are classified O

![](/img/post/Natural-Language-Processing/course3/week3pic7.png)

Application:

- **Search engine efficiency**: NER models scan millions of websites once and stores the entities as indentified in the process. Then tag from your search query simply match against website tags. 
- **Recommendation engines**: tags extracted from your history and compared to similar user histories then recommend things you might want to check out
- **Customer service**: match customer to an appropriate customer service agents. works similarly to a phone tree where prompted to provide some information about your request. e.g. use an app to communicate with your car insurance company, 需要provide some spoken information. then match to appropriate agents
- **Automatic trading**: build a web scraper to get the articles of the names of certain CEOs, Stocks, or cryptocurrencies. Then feed those article into a sentiment classification system and make your trade accordingly

**Training NERS: Data Processing**

1. Assign each entity class to a unique number. e.g. person name = 1, geographical location = 2, time indicator = 3
2. **Assign each word a number** that corresponds to its assigned entity class. O 表示 a failure or unrecognized word. <span style="color:red">Numbers are random and assigned when you process your data</span>. Each sequence is transformed into an array of numbers where each number 表示 index of the labeled word
3. **papdding**: LSTM require all sequences <span style="background-color:#FFFF00">are the same length</span>. Can set length of sequnces to a certain number and add generic ```<PAD>``` token to fill all empty spaces.


![](/img/post/Natural-Language-Processing/course3/week3pic8.png)

**Traing the NER**:

1. Create a tensor for each input and corresponding number 
2. Create a data generator and put them in a batch, batch size normally power of 2, <span style="color:red">speed up processing time considerably</span> -> 64, 128, 256, 512...
3. Feed it into an LSTM unit
4. Run the output through a dense layer (Linear operation on the input vectors) or fully connected layer
5. Predict using a <span style="background-color:#FFFF00">**log softmax**</span> over K classes (K: the number of possible output), <span style="color:red">log softmax gets better numerical performance and gradients optimization than softmax</span>

![](/img/post/Natural-Language-Processing/course3/week3pic9.png)



```python
tl.Serial(
    tl.Embedding(),
    tl.LSTM(),
    tl.Dense(),
    tl.LogSoftmax()
)
```




**Evaluate the model**

1. Pass test set through the model
2. Get arg max across the prediction array, 下面```np.argmax``` takes an axis parameter. To implement it accurately, need to consider the dimension of array
3. make sure arrays are padded using ```<PAD>``` token, which makes arrays the same length
4. Compare outputs against test labels to see how accurate model is

Note:  <span style="background-color:#FFFF00">When you pad your tokens, you should mask them before computing accuracy.</span>

下面code, mask variable is any token IDs that need to be skipped over during evaluation. One token need to skip is ```<PAD>``` token

![](/img/post/Natural-Language-Processing/course3/week3pic10.png)

**Some Useful Link**



[**Intro to optimization in deep learning: Gradient Descent**](https://blog.paperspace.com/intro-to-optimization-in-deep-learning-gradient-descent/)

[**Understanding LSTMs**](https://colah.github.io/posts/2015-08-Understanding-LSTMs/)

## 3.4 Siamese Network

<span style="background-color:#FFFF00">It's made up two identical neural networks which are merged at the end.  Used as Indentify similarity between things</span>

e.g. Comparing meaning not the same as compare words

- How old are you = what is your age
- Where are you from $$ \neq $$ where are you going. Although first three words are the same

Application:

- **Question duplicates**: Stackoverflow, Quera check your questions if exist before post
- **Handwritten checks**: determine if two signatures are the same or not
- **Search engine queries:** to predict whether a new query is similar to the one that was already executed

#### Architecture

- <span style="background-color:#FFFF00">Both network have a identical sub network.</span>  <span style="color:red">并且sub networks **share identical parameters**</span>. Learned parameters of each sub-network are exactly the same. Networks are merged together through a Dense layer to produce a final output or similarity score
- Each network output a vector, one for each questions.
- Cosine similarity tells how similar they are, $$\hat y$$ a value between -1 and 1
  - <span style="background-color:#FFFF00">if $$\hat y \leq \tau $$ means input questions are different. if $$\hat y > \tau $$ means input questions are the same</span>. $$\tau$$ is a parameter that choose how often want to interpret cosine similarity to indicate two questions are similar. Higher threshold means only very similar sentences is considered similar


下面是一个example, not all Siamese network contain LSTM. 

![](/img/post/Natural-Language-Processing/course3/week4pic1.png)


```python
def normalize(x):
    print("x square", np.sqrt(np.sum(x * x, axis=-1, keepdims=True)))
    return x / np.sqrt(np.sum(x * x, axis=-1, keepdims=True))

vocab_size = 500
model_dimension = 128

# Define the LSTM model
LSTM = tl.Serial(
        tl.Embedding(vocab_size=vocab_size, d_feature=model_dimension),
        tl.LSTM(model_dimension),
        tl.Mean(axis=1),
        tl.Fn('Normalize', lambda x: normalize(x))
    )

# Use the Parallel combinator to create a Siamese model out of the LSTM 

Siamese = tl.Parallel(LSTM, LSTM)
def show_layers(model, layer_prefix):
    print(f"Total layers: {len(model.sublayers)}\n")
    for i in range(len(model.sublayers)):
        print('========')
        print(f'{layer_prefix}_{i}: {model.sublayers[i]}\n')

print('Siamese model:\n')
show_layers(Siamese, 'Parallel.sublayers')

#Siamese model:

# Total layers: 2

# ========
# Parallel.sublayers_0: Serial[

#  Embedding_500_128

#  LSTM_128

#  Mean

#  Normalize

# ]

# ========


# Parallel.sublayers_1: Serial[

#  Embedding_500_128

#  LSTM_128

#  Mean

#  Normalize

# ]
```

#### Cost Function

- Anchor: the first question e.g. "How old are you"
- positive questions: have the same meaning as anchor, cosine similarity close to 1
- negative questions: not have the same meaning as anchor, cosine similarity close to -1

![](/img/post/Natural-Language-Processing/course3/week4pic2.png)

$$ diff = s\left(A,N \right) - \left(A, P \right) = \frac{A \cdot N}{\Vert A \Vert \Vert N \Vert}- \frac{A \cdot P}{\Vert A \Vert \Vert P \Vert}$$

<span style="color:red">s(v1, v2) is similarity metric(cosine similarity), could be distance metrics d(v1, v2) such as ecludian distance </span>

loss function allow whether model do well. When difference betwen s(A,N) and s(A,P) bigger or smaller along x-axis, loss bigger or smaller along the y-axis. Minimizing loss in training-> minimize this difference. <span style="color:red">But below loss function when `loss < 0`, still update maybe update to a worse weight which is not good</span>

![](/img/post/Natural-Language-Processing/course3/week4pic3.png)


 To fix above problem, when model do a good job, no need to update the weight. Modify if loss < 0, then loss = 0. When the loss is zero, we are not asking model to update the weight. But if predict all s(A,N) and  s(A,P) pair as zero, loss function could not update

![](/img/post/Natural-Language-Processing/course3/week4pic3_1.png)


We want the loss to be negative for model performing well. 如果difference is just less than zero, want model to still learn and <span style="background-color:#FFFF00">ask to predict a wider difference, can shift the loss function a little to the left. margin refer as *Alpha*.</span> Loss function shift to left by $$ \alpha $$. So if difference less than 0 but small in magnitute, loss greater than 0 and still can learn to improve

- s could be **similarity function** or **Distance Metric**(e.g. Euclidean distance) measurement. A distance metric is the mirror of a simlarity metric. A simlarity metric can be drived from a distance metric

![](/img/post/Natural-Language-Processing/course3/week4pic4.png)


**Triplet Loss**

$$L = \begin{cases}0; \quad \text{if diff } + \alpha \leq 0 \\[2ex] diff; \, \text{if diff } + \alpha > 0 \\ \end{cases} $$

$$L\left(A, P, N \right) = max\left(diff + \alpha, 0 \right) $$




#### Triplet Selection

  
- Firstly, select pair of duplicate questions as anchor and positive 
- Secondly, select a question is difference meaning from the anchor, to form anchor and negative pair
- 错误的方式是: select triplet random: <span style="color:red">很可能select non-duplicative pair A and N, where loss equal to 0. Loss is zero whenever model correctly predict A and P more similar to A and N. When `loss = 0`, network little to learn from triplet.</span>
- **Hard Triplet**: <span style="background-color:#FFFF00">are more difficult to train. Hard triplets 是similarity between anchor and negative very close to, but still smaller than similarity between anchor and positive. $$S\left(A, N \right) \approx S\left(A, P \right)$$</span> When model encounter hard triplet, algorithm need to adjust its weight so that yield similairty line up with labels
  - By selecting hard triplets, trainning focus are doing better on difficult cases which 也许会predict incorrectly

![](/img/post/Natural-Language-Processing/course3/week4pic5.png)



#### Compute Cost Function

Use ```b``` as batch size, 如下图<span style="color:red">每一行，是duplicate, 每一个column 没有duplicate</span>

![](/img/post/Natural-Language-Processing/course3/week4pic6.png)

- vector $$v_{1}$$, #row = batch sizes
-  $$v_{1}$$ #columns is the number of embedding layer(```d_model```).
-   $$v_{1,1}$$ is a duplicate of $$v_{2_1}$$, but $$v_{1_1,}$$ is not a duplicates of any other row in $$v_{1}$$ e,g, $$ v_{1_2}, v_{1_3}$$
 
![](/img/post/Natural-Language-Processing/course3/week4pic7.png)

may get similarity as 下图左侧的matrix

- Diagonal is the key features, <span style="background-color:#FFFF00">These values are the similarities for positive examples, question duplicates. 通常diagonal 数比不是在diagonal的数要大, because expect duplicates have higher similarity than non-duplicates. </span>
- upper right, lower left -> similarity for all negative examples. most number are lower than similarities along the diagonal
- 注意 negative example question pairs still have similarity 大于0, 虽然similarity range 从-1 到1，但不意味着大于0 表示duplicates 或小于表示non-duplicated. <span style="background-color:#FFFF00">Really matter is to find duplicates have a higher similarity relative to non-duplicated.</span>
- <span style="color:red">Creating pairs like this removing the need for additional  non-duplicate example and input data</span>. Insteading of sets up specific bathchs with negative examples, model can learn from existing questions duplicates batches.

Overall Cost Function 

$$\begin{align}J &= \sum_{i=1}^{m} L\left(A^{\left(i\right)}, P^{\left(i\right)}, N^{\left(i\right)} \right) =\sum_{i=1}^{m}  max\left(diff + \alpha, 0 \right) \\ &= \sum_{i=1}^{m}  max\left(s\left(A^{\left(i\right)}, N^{\left(i\right)} \right) - s\left(A^{\left(i\right)}, P^{\left(i\right)}\right) + \alpha, 0 \right) \\&  \color{blue}{\text{i refer to a specific training example and there are m observations}}\end{align}$$

![](/img/post/Natural-Language-Processing/course3/week4pic8.png)

- **Mean negative**: mean of off-diagonal values in each row(<span style="color:red">mean of the similarity of negative examples, not mean of negative number in a row</span>). 比如第一行 (-0.8 + 0.3 - 0.5)/3
- **Closest negative**: off diagonal value closest to(but less than) the value on diagonal in each row. By choosing this, force model to learn what diffferentiates these examples and drive those similarity values further apart through training. 比如第一行选取0.3: meaning a similarity of 0.3 has the most to offer model in terms of learning opportunity

$$L_{Original} = max \left(\underbrace{s\left(A,N \right)-s\left(A,P \right)}_{diff} + \alpha, 0 \right)$$

$$L_{1} = max \left(mean\_neg - S\left( A, P \right) +  \alpha, 0 \right)$$

$$L_{2} = max \left(closest\_neg - S\left( A, P \right)+ \alpha, 0 \right)$$

$$L_{Full}\left(A, P, N \right) = L_{1} + L_{2} $$

$$J = \sum_{i=1}^m L_{Full}\left(A^{\left( i \right)}, P^{\left( i \right)}, N^{\left( i \right)} \right) $$


In order to minimize the loss, you want $$diff + \alpha \leq 0$$, 

- **Loss 1**: <span style="background-color:#FFFF00">using mean negative replace similarity of A and N, help model converge faster during training by reducing noise</span>. Reduce noise by trainning on average of several observations rather than training model on each of these off-diagonal examples. 
  - Why reduce noise? We define noise to be a small value that from a distribution that is centered arund 0. So the average of several noise is centered around 0.(Cancel out individual noise from those observations)
- **Loss 2**: create a slightly large penalty by diminishing the effects of more negative similarity of A and N. <span style="color:red">can think of closest negative as finding negative example that results in smallest difference between two cosine similarity(Positive, Negative)</span>. Then add small difference to alpha, able to generate the largest loss among all of other examples in that row -> <span style="background-color:#FFFF00">make the model update weights more</span>


#### One Shot Learning

Classification vs One Shot Learning

- Classification: classify as 1 of K classes, probably use softmax function at the end to find maximum prabability. <span style="color:red">比如k=10, 如果k增加一个类别, expensive to retrain the model. Besides unless you have many examples for the class. model training won't work well</span>
- <span style="background-color:#FFFF00">**One Shot Learning**: one shot learning is to be able to classify new classes **without retraining any models**</span>. You only need to learn the similarity function once. Then can test similarity score against some threshold to see if they are the same. Problem changes to determine which class to measure similarity between two classes
  - 比如下面的例子，比如银行签字，每次有新的签名, can't retrain entire system. Instead, just learn a similarity  -> identify whether two signature are the same or not. 
  - If $$\text{similarity score} > \tau $$ indicates the same 
  - If $$\text{similarity score} \leq \tau$$ indicates the same 

![](/img/post/Natural-Language-Processing/course3/week4pic9.gif)


#### Training / Testing

1. prepare batches with batch size = b. Corresponding questions from each batch are duplicate(batch 1 和 batch 2第一行是duplicate). No duplicates within an indiivual batch(比如batch 1  第一行和第二行不是duplicate).
2. Use these inputs t get outputs vectors for each batch (Embedding -> LSTM -> Vectors -> Cosine Similarity). <span style="color:red">Note two subnetworks have identical parameters so only train one set, then shared by both</span>
   - Note: <span style="background-color:#FFFF00">$$\tau$$ and margin $$\alpha$$ from loss function are tunable hyperparameter</span>
3. When testing model, perform one-shot learning. 
  1. Convert each input an an array of numbers 
  2. Feed arrays into model 
  3. Compare $$v_1, v_2$$ using cosine similarity
  4. Test against a threshold $$\tau$$. If similarity greater than $$\tau$$, questions are classified as duplicates

![](/img/post/Natural-Language-Processing/course3/week4pic10.gif)

<br/><br/><br/>

## 4.1 Neural Machine Translation

#### Seq2Seq

- take one sequence of items such as words, and output another sequence. 
- Map variable-length of sequence to a fixed-length memory. The inputs and outputs length 不一定一样
- In Seq2Seq model, LSTMs and GRUs are typically used to overcome the **vanishing gradient problem**
- **Encode-Decoder**:
  - Encoder takes the input one step at a time, collects information for inputs then move it fowward by hidden state
  - 橘色框 encoders final hidden states, all the information collected from each input step before feeding into the decoder. <span style="background-color:#FFFF00">The final hidden states provide **initial states** </span>for decoder to begin predicting the sequence. 
- <span style="background-color:#FFFF00">**Shortcomings of traditional Seq2Seq** with LSTM</span>: Information bottleneck
  - 因为是<span style="color:red">Seq2seq (Encoder hidden states) uses a fixed length memory</span>. longer sequence become problematic -> lower performance
  - <span style="color:red">Later input steps in the sequence are given more importance</span>. 比如下图中的today

![](/img/post/Natural-Language-Processing/course4/week1pic2.png)

**One Vector per word**: give each word a vector for individual information instead of smash all into one big vector.  **Flaw**: How build a time/memory efficient model that predicts accurately from a long sequence. 

![](/img/post/Natural-Language-Processing/course4/week1pic3.png)

Solution: **Focus attention** in the right place:  

- Prevent sequence overload by giving the model a way to focus on the <span style="color:red">likeliest</span> words at each step. can think of a new layer to process this information. 
- Do this by providing the information specific to each input word

![](/img/post/Natural-Language-Processing/course4/week1pic4.png)


The sequential nature of models <span style="color:red">(RNNs, LSTMs, GRUs) does not allow for parallelization within training examples</span>, which becomes critical at longer sequence lengths, as memory constraints limit batching across examples. Have to wait until the initial computations are complete. This is not good 
- it will take a long time for you to process it 
- you will lose a good amount of information mentioned earlier in the text as you approach the end.  

Therefore, attention mechanisms have become critical  for sequence modeling in various tasks, allowing modeling of dependencies without caring too much about their distance in the input or output sequences. 

#### Alignment

- Many lanuage don't translate exactly into another language. To align words correctly, need to add a attention layer <span style="color:red">to help the decoder understand  which inputs are more important</span>.
-  <span style="background-color:#FFFF00">The attention mechanism solves for longer input sequences by giving **more weight** to more important words.</span>.  More weight -> More influence for decoder output 

![](/img/post/Natural-Language-Processing/course4/week1pic6.png)

1. Get all hidden states ready for encoder and first hidden states for decoder. 比如下面例子，encoder 两个hidden states, decoder一个
2. **Calculate Alignment Score**: score  each of encoder hidden sattes by 计算 <span style="background-color:#FFFF00">**compute dot product between encoder state and decoder hidden state**</span>. <span style="color:red">higher score->more influence of this hidden state activation for output.</span>
3. Run scores through <span style="background-color:#FFFF00">softmax</span>, each score is between 0 and 1, then <span style="color:red">give attention distribution</span>.
4. Take each encoder hidden state, <span style="color:red">multiply by its softmax score,</span> -> <span style="background-color:#FFFF00">**alignment vector**</span>
5. adding up everything alignment vector to <span style="background-color:#FFFF00">**context vector**</span> -> <span style="background-color:#FFFF00">context vector is feeded into decoder</span>

![](/img/post/Natural-Language-Processing/course4/week1pic7.png)


#### Attention Model

- Attention is an added layer that lets a model focus on what's important
- **Queries**, **Values**, and **keys** are used for information retrieval inside the Attention layer
  - **Key** and **Value** pair(key & value are activation from hidden state $$a^{<{t}>}$$): both dimension <span style="color:red">N(input sequence of length from encoder hidden states)</span>. Keys and values have their own respective matrices, but the matrices have the same shape and are often the same. 
  - **Query**: <span style="color:red">from decoder hidden state $$s^{<{t-1}>}$$</span>
  - Both key-value pair and query <span style="background-color:#FFFF00">enter attention layer on the opposite ends of the model</span>


**Scale dot product attention**

1. <span style="color:red">**Dot product**</span> between query and key is calculated, <span style="background-color:#FFFF00">measure similarity. Similar vectors of dot product -> higher value.</span>
2. **Weighted sum** given to each value is determined by the probability that key matches the query. Probabilities calculated by running attention weights through softmax. Value between 0 and 1
3. the query is mapped to next key-value pair, so on so forth


![](/img/post/Natural-Language-Processing/course4/week1pic8.png)

- Query(Q) is as column and words of keys as row
- value socre(V) assigned based on closeness of the match



- <span style="background-color:#FFFF00">Model should be flexible to handle differences in grammear and word ordering in different language. </span>.
  - 比如下面例子，法语到英语, 第五个法语词Zone -> attention knows to look further down at 第八个token


In the matrix, the lighter square shows where the model is actually looking when making the translation of that word. 
- This mapping should not necessarily be one to one. As you can see several words can contribute to translating a  word, depending on the weights (output) of the softmax
- The lighting just tells each word contributing to the input that will be fed into the decoder. 

![](/img/post/Natural-Language-Processing/course4/week1pic9.png)


**Machine Translation Setup**

- keep track of index mappings with word2ind and ind2word dictionaryie
- use start-of ```<SOS>``` and end-of ```<EOS>```(1) sequence tokens

![](/img/post/Natural-Language-Processing/course4/week1pic10_1.png)
![](/img/post/Natural-Language-Processing/course4/week1pic10_2.png)

#### Teacher Forcing

- Teacher forcing use the **ground truth** or the **actual outputs** from decoder feed to next decoder layer as input instead of predicted value **during training**
- <span style="background-color:#FFFF00">Teacher forcing yields faster, faster convergerence, more accurate training</span>

e.g. <span style="color:red">In a sequence model, each wrong prediction make the following predictions even less likely to be correct.</span>.


![](/img/post/Natural-Language-Processing/course4/week1pic11.png)


![](/img/post/Natural-Language-Processing/course4/week1pic12.png)

[Link: What is Teacher Forcing ](https://towardsdatascience.com/what-is-teacher-forcing-3da6217fed1c?gi=fe02fa9e9d0)


#### NMT with Attension

1- Initial select: two copies. Input tokens represented by `0` and the target tokens represented by `1`.

![](/img/post/Natural-Language-Processing/course4/week1pic13_1.png)

2- <span style="color:red">One copy of the input </span> fed into as input encoder to be transformed into the <span style="color:red">key and value vectors</span>. <span style="color:red">A copy of the target</span> tokens goes into the <span style="color:red">pre-attention decoder</span>. 
  - <span style="background-color:#FFFF00">The pre-attention decoder(not  decoder produces the decoded outputs) transform the prediction targets into a different vector space called the **query vector** Q vector</span>, so can calculate the relative weights to give each input word. 
  - `ShiftRight` in pre-attention decoder shifts the target tokens one place to the right, assign the start of sentence ```<SOS>``` to beginning of each sequence, where the <span style="color:red">**teacher forcing**</span> takes place. 
  
3- Inputs and targets are converted to embeddings

![](/img/post/Natural-Language-Processing/course4/week1pic13_2.png)


4- Now have query key and value vectors, you can prepare them for the attention layer:
   1.  Compute $$ QK^T$$
   2.  apply a padding mask before computing the softmax.

![](/img/post/Natural-Language-Processing/course4/week1pic13_3.png)

5- Once, have queries, keys, and values, compute attention. 

6- Residual block adds the queries generated in the pre-attention decoder to the results of the attention layer. Then attention output its activation along with the mask that was previously created.  

![](/img/post/Natural-Language-Processing/course4/week1pic13_4.png)

7- Drop the mask(图中标注的mask(1)) before running everything through the decoder, which is what the second Select is doing. `Select([0,2])` takes the activations from the attention layer（图中标注的attention(0)), and the second copy of the target tokens(图中标注的target tokens(2). <span style="background-color:#FFFF00">They are true targets which the decoder needs to compare against the predictions.</span>

8-  Run through a dense layer with targets vocab size -> gives output. 

9-  Take the outputs through LogSoftmax, which is what transforms the attention weights to a distribution between zero and one.

10- Match the log probabilites against true target tokens (t<span style="color:red">rue target token is outside decoder</span> and pass down to the logsoftmax)

Note: <span style="color:red">图中的 Select([0,2]) -> LSTM -> Dense -> LogSoftmax : 是decoder</span>




![](/img/post/Natural-Language-Processing/course4/week1pic13.png)

![](/img/post/Natural-Language-Processing/course4/week1pic19.png)

![](/img/post/Natural-Language-Processing/course4/week1pic20.png)


![](/img/post/Natural-Language-Processing/course4/NMTModel.png)


#### BLEU Score

BLEU: Bilingual Evaluation Understudy. 缺点: 同义词但n-gram 不一样，low score, 但是good translation. And no consideration of recall

- evaluate the quality of machine-translated text by compaing a candidate texts translation to one or more reference translation.
- <span style="color:red">Usually The closer the BLEU score to one, the better the model. The closer to zero, the worse it is.</span>
-  To get the BLEU score, the candidates and the references are usually based on an *average* of unigram, bigram, trigram or even four-gram.  
   - <span style="background-color:#FFFF00">Unigrams account for adequacy while longer n-grams account for fluency of the translation</span>. 
- Problem
   -  BLEU doesn't consider semantic meaning, so does not take into account the order of n-gram
   -  BLEU doesn't consider sentence structure.e.g "Ate I was hungry beacause!" 如果reference is "I ate because I was hungry", will get a perfect BLEU score

Bervity Penalty: The brevity penalty penalizes generated translations that are too short compared to the closest reference length with an exponential decay. The brevity penalty compensates for the fact that the BLEU score <span style="background-color:#FFFF00">has no recall term.(recall: 是不是reference 中的正确都predict了</span>，referenece length > candidate length, no penalty )

$$BP = min \left(1, e^{1- \frac{\text{ref length}}{\text{candidate length}}} \right)$$

![](/img/post/Natural-Language-Processing/course4/week1pic16.png)


BLEU Score:


$$BLUE = BP \left(\prod_{i=1}^4 precision_i \right)^{\frac{1}{4}}$$

$$precision_i = \frac{\sum_{snt \in cand} \sum_{i \in snt} min\left(m_{cand}^i, m_{ref}^i \right)}{w_t^i}$$

Where: 

- $$m_{cand}^i$$ , is the count of i-gram in candidate matching the reference translation.
- $$m_{ref}^i$$  , is the count of i-gram in the reference translation.
- $$w_{t}^i$$  , is the total number of i-grams in candidate translation.
- $$min\left(m_{cand}^i, m_{ref}^i \right)$$ 表示比如 bigram, (I,am) 在candidate中出现5次，但在reference中只出现3次，就取3次


下面图中的score 是乘以100后的结果

![](/img/post/Natural-Language-Processing/course4/week1pic17.png)


#### ROUGE

F1 score

$$score = 2 \frac{ precision * recall}{precision + recall}$$

recall-Oriented Understudy for Gisting Evaluation:  

- Calculates precision and recall for machine texts by counting the n-gram overlap between the machine texts and a reference text.
- Measures precision and recall between generated text and human-created text <span style="background-color:#FFFF00">where order matters</span>
  - precision: How much of model text was relevant
  - Recall: How much of the reference text is the system text captures?
- Problem:
  - <span style="background-color:#FFFF00">Doesn't take **similar themes or concepts**(同义词) into consideration( low ROUGE score doesn't necessarily mean the the translation is bad)</span> 比如 model predict "I am a fruit-filled pastry" 跟 reference" I am a jelly donut" 意思一样但是score低


![](/img/post/Natural-Language-Processing/course4/week1pic14.png)

*The, cat, had, orange, fur* 都appear。 如果model wants a high recall score, can guess hundred of words and have the chance the words in the true reference sentence. Then use precision


![](/img/post/Natural-Language-Processing/course4/week1pic15.png)


```python
def rouge1_similarity(system, reference):
# system (list of int): tokenized version of the system translation
        
#reference (list of int): tokenized version of the reference translation

    sys_counter = collections.Counter(system)
    ref_counter =  collections.Counter(reference)
    
    overlap = 0
    for token in sys_counter:
        token_count_sys = sys_counter.get(token,0)
        token_count_ref = ref_counter.get(token,0)
        overlap += min(token_count_sys,token_count_ref)

    precision = overlap/sum(sys_counter.values())
    recall = overlap/sum(ref_counter.values())
    if precision + recall != 0:
        # compute the f1-score

        rouge1_score = 2*(precision*recall)/(precision+recall)
    else:
        rouge1_score = 0 
    return rouge1_score
```


#### Greedy Decoding

- Select the <span style="color:red">most probable</span> word at each step(每步选取最大概率的)
- For short sequence, it is fine
- Limitiation: Best word at each time != best for long sequence, 比如model predict 出 I am, am, am, am...  


#### Random Sampling

- Problem of Random Sampling: Often a little too random for accurate translation 
- Solution: <span style="background-color:#FFFF00">assign more weight to more probable words, and less weight to less probable words</span>
- <span style="color:red">**Temperature**</span>: <span style="background-color:#FFFF00">a parameter allowing for more or less randomness in predictions. measured on scale from 0 to 1, indicating low to high randomness</span>
  - Lower temperatue setting = More confident, conservative network. More careful/safe decision for output
  - Higher temperatue setting = More excited, random network(and more mistakes)


Below codeis to generate random samplying from log-softmax output.  the amount of "noise" added to the input by these random samples is scaled by a <span style="background-color:#FFFF00">**temperature**</span> setting. If temperature equal to 0 will return the argmax of log_probs(greedy decoding)

```python
def logsoftmax_sample(log_probs, temperature=1.0):  
#Returns a sample from a log-softmax output, with temperature.

# log_probs: Logarithms of probabilities (often coming from LogSofmax)
    
# temperature: For scaling before sampling (1.0 = default, 0.0 = pick argmax)


  # This is equivalent to sampling from a softmax with temperature.

  u = np.random.uniform(low=1e-6, high=1.0 - 1e-6, size=log_probs.shape)
  g = -np.log(-np.log(u))
  return np.argmax(log_probs + g * temperature, axis=-1)
```

#### Beam Search


- A broader, more exploratory decoding alternative
- Istead of offering a best output like greedy decoding, beam seach select multiple options for the best input based on conditional probability
- **Beam width B**: limit the number of branching paths. Select B number of best alternatives at each time step with the highest probabilities
  - <span style="background-color:#FFFF00">A larger beam width -> better model performance  but slower decoding speed.</span> 
- Problem: 
  - Since the model learns a distribution, that <span style="color:red">**tends to carry more weight**</span> than single tokens
  - Can cause translation problems, 比如 in a speech corpus that hasn't been cleaned. If have filler word "Uhm" which appear as translation with lower probability. at time step, most probable word 是 "Uhm"


![](/img/post/Natural-Language-Processing/course4/week1pic18.png)

#### Minimum Bayes Risk (MBR)

Alternative of Beam Search

1. Generate several random samples using random sampling for outputs
2. Compare each sample against all the others and assign a similarity score (such as ROUGE!)
3. Select the sample with the highest similarity.


Examples: MBR Sampling, generate the scores for 4 samples: (<span style="background-color:#FFFF00">注是 prediction 和prediction 之间算similarity 不是prediction 和 reference 比</span>)

1. Calculate similarity score between sample 1 and sample 2
2. Calculate similarity score between sample 1 and sample 3
3. Calculate similarity score between sample 1 and sample 4
4. Calculate weighted average of first 3 steps (usually a weighted average)
5. Repeat until all samples (2,3,4) have overall scores


<br/><br/><br/>

## 4.2 Transformer

### RNN Disadvantage:

- RNN parallel computing diffcult to implement <span style="color:red">**No parallel computing**</span>.
  -  The more for input, the more time process that sentence
- For long sequence in RNNs there is <span style="background-color:#FFFF00">**loss of information**</span>. LSTM and GRUS help a little(stop working well when process long sequence)
- In RNNs, problem of <span style="background-color:#FFFF00">**vanishing gradients**</span>

Transformers help with all of the above 

**Neural machine translation** use neural network artchitecture: Both Encoder and Decoder take sequential steps. 

![](/img/post/Natural-Language-Processing/course4/week2pic1.png)


**Seq2Seq Architecture**: 

- For large sequences: information tend to loss within the network, <span style="color:red">vanishing gradients problem</span>. 

![](/img/post/Natural-Language-Processing/course4/week2pic2.png)

**Conventional Encoder - Decoder Architecture**

![](/img/post/Natural-Language-Processing/course4/week2pic3_1.png)

#### Transformer

 - transformer are based on attention, not require sequential computation per layer, only one step is needed
- Gradient steps from last output to the first input in a transformer is 1 step. For RNN, the number of steps equal to T
- <span style="background-color:#FFFF00">Transformer don't suffer from vanishing gradient problem </span>which related to the length of sequence
- Transformer differ to Seq2Seq, <span style="color:red">use **Multi-headed attention** layer</span> instead of recurrent layer

![](/img/post/Natural-Language-Processing/course4/week2pic3_2.png)


**Self Attention -> Multiheaded attention**

- Self Attention: learn the dependencies between the words of the sentence.
- Self Attention use query, key, value obtained from every sequential inputs, and output a same length sequential output for each input
- Queries, Keys, and Values go through Dense Layer before Attention layer
-  Multiheaded attention: **parallel** self-attention layers(called **heads**). These heads are further concatenated to produce a single output, which emulates the recurrence sequence effect with attention
- <span style="background-color:#FFFF00">Unlike recurrent layer, multi-headed attention computes the inputs in the sequence **independently** then <span style="background-color:#FFFF00">allows to **parallelize** the computation</span>. But <span style="background-color:#FFFF00">fail to model the sequential information </span>for a given sequence, that's why need positional encoding stage into the transformer model</span>
  - **Positional Encoding**: encodes each input position in the sequence(since word order and position is important for language) to <span style="color:red">retain the positional information</span>. The positional encoding output values to be added to the embeddings. So every word given to the model, have some of information about its order and position. 下面例子中 a positional encoding vector for each word ich, bin which will tell respective position. 

Self Attention: 

![](/img/post/Natural-Language-Processing/course4/week2pic4.png)

Multiheaded attention

![](/img/post/Natural-Language-Processing/course4/week2pic5.png)

Positional Encoding

![](/img/post/Natural-Language-Processing/course4/week2pic5_1.png)



#### Tranformer Application

- Text summarization
- Auto-complete(比如打字，comple, 输出complete)
- Named entity recognition(NER)
- Question answering 
- Translation
- Chat-bots
- Other NLP tasks e.g. Sentiment Analysis, Market Intelligence, Text Classification, Character Recognition, Spell Checking. 


#### Dot-Product Attention

Dot-product Attention is essential for Transformer

- For a good embedding, vectors for English and German 同义词 are similar. 
- Query looks for similar Keys. <span style="color:red">Each key has a probability of being a query a match for the query</span>
- The queries by Keys matrix is called **attention weights**: how much each key similar to each query
- Return sum of the keys weighted by their probabilitys


![](/img/post/Natural-Language-Processing/course4/week2pic6.png)

Feed all embedding vectors into different Linear Layer to get different vectors for queries, keys and values.

![](/img/post/Natural-Language-Processing/course4/week2pic7.gif)


**Math**

- <span style="color:red">Before performing dot product, Keys, Queries, and Values are passed through a Dense Layer</span>
- **Query**: Shape: $$L_Q$$  by D
  - think of D is the embedding dimension of word embedding, $$L_K$$: the length of German sentence
- **Keys**: Shape: $$L_K$$  by D
  -  think of keys  D is the embedding dimension of word embedding, $$L_K$$: the length of English sentence
- **Query** assign each **Key** a probability using <span style="background-color:#FFFF00">dot product</span> if dot product large -> Q and K are similar. This allow the model to focus on the right place when translating each word
  - <span style="background-color:#FFFF00">Attenion weights: $$W_A = softmax\left(QK^T\right)$$, shape is $$L_Q x L_K$$. 每个key-query pair gets a probability</span>
  - Weights or Scores <span style="background-color:#FFFF00">表示relative importance of **Keys** for specific **Query**</span>. Attention weights can be understood as alignments score. 
  - However, <span style="color:red">similarity number not add up to 1, cannot be used as probabilities</span>. Solution: use **softmax** turn these weights to probability
- Finally, multiply these probabilites with **Values**, get weighted sum  of sequence(**attention result/context vector**). weight each **value** $$v_i$$ by the probability that key $$k_i$$ matches the query.
- Attention mechansim calculates dynamic or alignments weights 表示 relative importance of the inputs(**Keys**) in sequence for particular output (**Queries**). Multiply dynamic weights or alignments with input sequences(**Values**) to get a single context vector
- GPUs and TPUs is used for speed-up matrix multiplications

$$Z = attention\left( Q, K, V \right) = softmax\left( QK^T\right ) V = W_A V$$

![](/img/post/Natural-Language-Processing/course4/Attn_dot1.png)

![](/img/post/Natural-Language-Processing/course4/Attn_dot2.png)


#### Causal Attention

Three ways of Attention

- **Encoder/decoder Attention**: One sentence(decoder) looks at another one(encoder) Garman attends to English
- **Causal (self) attention**: In one sentence, words look at previous words(used for generation text/summary). 比如 “I am happy" happy look at "I" 和 "am"
- **Bi-directional self attention**: In one sentence, words look at both previous and future words (used in Bert/T5)

![](/img/post/Natural-Language-Processing/course4/week2pic8.png)

**Causal attention**: 

- <span style="color:red">Queries/Keys are words from the same sentence</span>(That's why called self-attention). It is used in language models where try to generate sentences.
  - 比如下面例子，after generating "*my*", model may look at vector "*I*" to retrieve more information 
  - <span style="background-color:#FFFF00">Query seach among past words only</span>
- <span style="color:red"> Causal attention cannot attend words in future </span>. 因为future word还没有generated yet


![](/img/post/Natural-Language-Processing/course4/week2pic11.png)

**Math**: 

- $$ softmax\left( QK^T \right)$$ shape is $$L_Q$$ by $$L_K$$, <span style="color:red"> allow model attend words in future</span>
- <span style="background-color:#FFFF00">add mask(a constant triangular matrix, has 0 on diagonal and below it, minus inifinity on other places ) to weights $$QK^T$$</span> 
- $$ softmax\left( QK^T + M \right)$$. Adding M let queries attending words in the past  untouched. All other values become minus inifinity. After softmax, all minus infinity become to 0(exponential of negative infinity equal 0) -> prevent words from attending to future

![](/img/post/Natural-Language-Processing/course4/week2pic12.png)


![](/img/post/Natural-Language-Processing/course4/causalAttn_1.png)
![](/img/post/Natural-Language-Processing/course4/causalAttn_2.png)



#### Multi-headed Attention

- Each head uses individually different linear transformations to represent word
- Different heads can learn different relationships between words 比如下图 have N different heads and heads are being concatenated. Each one linear transformation results in one head


![](/img/post/Natural-Language-Processing/course4/week2pic14.png)

比如下图input of multi-headed attention is triple,

1. Use fully connected layer dense layer on each query, key and value to create parallel attention heads, (3个合成一个head)
2. Split these vectors into number of heads and perform attention on them as each head was different.
3. Then result of attention will be concatenated back together.
4. Put through a final fully connected layer to make different heads into a joint representation(Linear绿色框). The scale dot-product is used in dot-product attention model except scale factor $$\frac{1}{\sqrt{dk}}$$
   - $$d_k$$ is the key and query dimenion. It is a normalization prevents the gradients from the function to be extremly small when large values of $$D_k$$ is used


![](/img/post/Natural-Language-Processing/course4/week2pic15.png)


d_head is dimensionality for each head, linear layer create n_heads vecotr each with each size d_head, separate head don't interact with each other


![](/img/post/Natural-Language-Processing/course4/week2pic16.gif)

1. create embedding for input words
2. calculate keys and values matrices, packing all embedding into matrix for every head
3. Then train weight matrices one per head to obtain new weighted queries, $$W_i^Q$$: ith head weighted matrix for Query
4. with weighted query, key and value matrices, calculate result matrix $$Z_i$$: ith head by multiply ouput weight $$W^0$$


![](/img/post/Natural-Language-Processing/course4/week2pic17.png)

A multi-headed model jointly attends to information from different representation at different positions over the projected versions of queries, keys adn values. <span style="background-color:#FFFF00">Have to apply attention model parallel</span> reach different output values. Then these output values are then concatenated and weighted.


![](/img/post/Natural-Language-Processing/course4/week2pic18.png)

#### Transformer Decoder

1. Input is tokenized sentence, a vector of integer, with shift right layer to add start token
2. Sentence get embedded with word embeddings
   - If input shape is batch by lengths, after embedding, shape is batch by lengths by d_models(size of embedding, usually 512,1024, nowadays up to 10k or more)
3. position decoding: add embedding the information about position. The information is to learn vector representing 1,2,3 up to max lengths that put into the model
   - The embedded first word will get added with vector representing one, The embedded second word will get added wit vector representing two, produce so called positional input embedding 
4. multi-headed attention layer
   - This model process each word, each position in the input sequence from positional input embedding . The attention itself searches other positions in the sequence to help identify relationships. Each word in the sequence is weighted
   - Each layer of attention, there is a resuidual connection around it, followed by a layer normalization step to speed up training and significantly reduce overall processing time
   - Then Each word is passed through a feed-forward layer, that's embeddings are fed into a neural network. Then add drop out at the end as regularization
   - A layer normalization step is repeated N times.(下图2 N表示的位置)
   - Finally the encoder layer output is obtained
5. Feed-forward layer with ReLU:
  - Some non-linear transformation are introducted by fully connected feed-forward layers with ReLu activation function for each input have shared parameters for efficiency 
  - The feed forward neural network output vectors will replace the hidden states of original RNN encoder.
6. After each attention and feed-forward layer, put a residual or skip connection. Add inputs of that layer to its output and perform layer normalization
7. Step 4,5,6 重复 N times
8. Final a dense(fully-connected) layer for outputs and a softmax layer, output batch by length by vocabulary size
9.  calculate 记录 softmax for corss entropy loss

![](/img/post/Natural-Language-Processing/course4/week2pic19.png)

![](/img/post/Natural-Language-Processing/course4/week2pic20.png)

![](/img/post/Natural-Language-Processing/course4/week2pic21.png)


#### Transformer Summarizer

Use Transformer model to produce the summary for article. Transformer predict next work and your inputs in news article. At test or inference time, input the ```article <EOS>``` token(first word of the summary) to the model ask for next word. Then ask for next work and next by random sampling until get ```<EOS>``` When run transformed model, generates a probability distrbution over all possible words. Will sample from this distribution. So each time get a different summary. 

![](/img/post/Natural-Language-Processing/course4/week2pic23.png)

- Input: tokenized as a sequence of integers. 0 表示 padding, 1 表示 EOS
- Loss weights: 0s until the first ```<EOS>``` and then 1 on the start of the summary
  - Don't want a huge loss because its not able to predict the correct one
  - Instead of averaging the loss for every word in the whole sequence, weight the loss for the words within the article with 0s and ones within the summary with 1s. So model only focus on summary
  - However, little data for summaries, actually helps to weight the article loss with nonzero number 比如 0.2, 0.5, or even 1. model able to learn word relationship that are common in the news

```python
#article, summary integer vector

joint = np.array(list(article) + [EOS, SEP] + list(summary) + [EOS])
mask = [0] * (len(list(article)) + 2) + [1] * (len(list(summary)) + 1) # Accounting for EOS and SEP

```

![](/img/post/Natural-Language-Processing/course4/week2pic22.png)

Cost function: cross entropy function that ignores the words from the article to be summarized

$$J = -\frac{1}{m} \sum_j^m \sum_i^K y_j^i log \hat y_j^i $$

where j: over summary. i: batch elements

<br/><br/><br/>



## 4.3 Question Answering

![](/img/post/Natural-Language-Processing/course4/week3pic2.png)


#### Transfer Learning


![](/img/post/Natural-Language-Processing/course4/week3pic1.gif)

Transfer Learning:  e.g. use pretrain model (movie review) on course review. 

- Reduce training time, faster convergence
- Improve predictions
- require a small datasets, because model learn a lot from other tasks


![](/img/post/Natural-Language-Processing/course4/week3pic3.png)

Two methods in Transfer learning

- feature based method, word vectors(use pretrain CBOW(embedding) weights as word vectors)
- fune tuning method , 
  - take a exisitng weights as initialized weights and fine tune them on new task
  - <span style="background-color:#FFFF00">Add a new layer and only fine tune new layer keep other layer frozen</span> 比如 movie review predict 3 ratings, course review provide 5 ratings, add a new layer to match new dimension(5)

![](/img/post/Natural-Language-Processing/course4/week3pic4.png)

![](/img/post/Natural-Language-Processing/course4/week3pic5.png)

Generaly, a bigger data, a larger model -> better performance. 比如 unlabeled data 大于 label data.  

- 对于unlabeled data 用于 pre-training. 比如CBOW, learn the word from the context(self-supervised learning)
- labelled data 用于 downstream task using the model weights, 比如 what day is today, model predict March 14th

![](/img/post/Natural-Language-Processing/course4/week3pic6.png)


The model that is trained bidirectionally may have a deeper sense of context and language flow than unidirectional models.

#### ELMo, GPT, BERT, T5

**ELMo**: CBOW using C as windows size, ELMo use full context using RNN (<span style="color:red">Bi-directional</span> LSTM), suffer from long-term dependency 

![](/img/post/Natural-Language-Processing/course4/week3pic7.png)

**GPT**(Decoder): uni-directional. In transformer, using self-attention(Each word can peek at itself), but in GPT, only look at previous attention(No peeking)



**BERT**: decoder, bi-drectional

BERT Pre-training Tasks:

-  Multi-Mask Langauage modelling. 比如 mask 两个词在sentence中，让model 学会predict 这两个词
-  Next sentence Prediction. Given Sentence A, 然后给几个选项, predict which onesentence B

**T5** using Encoder & Decoder

![](/img/post/Natural-Language-Processing/course4/week3pic8.png)

![](/img/post/Natural-Language-Processing/course4/week3pic9.png)


#### BERT

- A multi layer bidrectional transformer
- Use positional embeddings
- Famous model is BERT_base, has: (New model come out now has more parameters)
    - 12 layers(12 transformer blocks)
    - 12 attentions heads
    - 110 million parameters

1. Start with Embedding $$E_1, E_2 ... E_N$$
2. Go to Transformer block(图中的蓝色圈)
3. Get $$T_1, T_2 ... T_N$$

![](/img/post/Natural-Language-Processing/course4/week3pic10.png)

- Pretraining: use unlabelled data over different pretraining tasks
  - Mask language modelling(MLM) : (mask 15% percent of words) , train data generator choose 15% of these positions at random for prediction. Mask them 80% of the time, replace them with a random token 10% of the time, then keep as is 10% of the time.  Note: could be multiple masked spans in a sentence. 
    - Add a Dense layer after encoder outputs, multiply output vector by the embedding matrix then transform them into vocabulary dimension and add softmax at the end
  - Next sentence prediction is also used when pre-training: Given two sentences, if true means two sentence follow one another.
- Fine-tuning: initialized with pre-trained parameters and all of pararmeters are fine-tuned using labeled data from downstream tasks

**Objective**

1. start with positional embedding which indicate the position in the sentence of the word
2. Then have segment embeddings: 表示if it is sentence A or setnence B
3. Then have token embedding, have CLS token 表示beginning of sentence 和 SEP token 表示 end of sentence. 
4. Take the sum of those embedding to get a new input

![](/img/post/Natural-Language-Processing/course4/week3pic11.png)

$$T_i$$ embedding are used to predict masked word using softmax. 绿色的C embedding are used for next sentence prediction

![](/img/post/Natural-Language-Processing/course4/week3pic12.gif)

![](/img/post/Natural-Language-Processing/course4/week3pic13.png)


**Fine Tuning**

![](/img/post/Natural-Language-Processing/course4/week3pic14.gif)


#### T5

T5 transformer known as Text to Text transformer. Can used for 

- Classification
- Question Answering
- Machine Translation
- Summarization
- Sentiment

Model Architecture: Use Encoder/decoder, 12 transformer blocks each, 220 million parameters

- Sbasic encoder-encoder representation. Fully visible attention in encoder and causal attention in decoder
- Language model with single transformer layer stack which are fed the concatenation of inputs and target, use causal attention
- Prefix Language model allow fully visible masking over inputs and causal masking

![](/img/post/Natural-Language-Processing/course4/week3pic15.png)


- Examples-proportional mixing, 每个dataset 不管多大多小，都take 10%
- Example mixing, regardless size of data, take equal sample
- Temperature scaled mixing: play the parratmeters to get something between Examples-proportional mixing and Example mixing

![](/img/post/Natural-Language-Processing/course4/week3pic16.png)

**Graudal Unfreezing**: freeze one layer at a time.  比如下图 freeze last layer, fine-tuned using that keep other fixed. Then freeze 倒数第二个... gradual freezing each layer

![](/img/post/Natural-Language-Processing/course4/week3pic17.gif)

**Adapter layers**: add existing neural network or a neural network to each feed forward and each block of the transformer. Then these new feed forward networks designed that output dimension match input, allows them to be inserted without having ay structural change。 <span style="background-color:#FFFF00">When fine-tuning, only new adapter layers and layer normalization are updated</span>

![](/img/post/Natural-Language-Processing/course4/week3pic18.png)

A single model can simultaneously perform many tasks at once. Model most of parameters are shared across all of the tasks. Might train a single model on many tasks, but when reporting performance, can select different checkpoints for each task. Do the train at 2^18 steps

![](/img/post/Natural-Language-Processing/course4/week3pic19.png)

#### GLUE Benchmark

GLUE: General Language Understanding Evaluation

- A collection used to train, evaluate, analyze natural language understanding systems
- has a lot of datasets. Each Dataset with different genres, and of different size and difficulties. 比如some are for coreference resolution, other used for simple sentiment analysis
- Used with a **leaderboard**: people can use dataset, see how well models perform compared to others


Tasks Evaluated on

- Sentence grammatical or not? Sentence make sense or not?
- Sentiment
- Paraphrase
- Similarity
- Questions duplicates
- Answerable: whether question can be answered or not?
- Contradiction
- Entailment
- Winograd: try to identify whether a pronoun refer to a certain noun or another noun. 

Evaluation / Application

- researchers use GLUE as a benchmark
- Model agnostic, doesn't matter which model you used 
- allow use of transfer learning because have access to several datasets


<br/><br/><br/>

## 4.4 Chatbot

Long Text Sequence: Chanllenges due to size in training.

- Writing Books: 变得困难辨认 book written by human or AI
- Chatbots: 变得困难辨认 conversation you have real or computer

[AI Storytelling](https://play.aidungeon.io/main/landing): Dragon model for Dungeon is based on GPT-3. It generates an interactive story based on all previous turns as inputs. That makes for a task that uses very long sequences.

Process long text sequence is core of chatbot. Chatbot use all previous pieces of converversation as inputs for next reply -> big context windows

- Context-based question: need both a question and relevant text from where to retrieve answer
- Close loop question. no need extra text with a question or prompt from human. All knowledge is stored in weights of model during training 
  
#### Transformer Issues

- Attention on sequence of Length L takes $$L^2$$ time and memory. 比如attention on two sentences of length L, need to compare each word in first sentence to each word in second sentence. 比如 L = 10000, $$L^2$$ = 100 M, 如果每秒process 10M, take 10 sec to compute
- N layers take N times as much memory. e.g. GPT-3 has 96 layers and new models will have more. Even modern GPU can struggle this dimensionality
- **Attention Complexity**: Attention is $$softmax\left( QK^T \right)V$$, Q,K,V are all size L by $$d_model$$, Then $$QK^T$$ size is L by L. For long sequence, usually don't need consider all L positions, instead focus on area of interest. 比如translate a long text from English to German, don't need to consider every word at once. Instead focus on single word being translated and those immediately around it by using attention. 
- <span style="background-color:#FFFF00">The more layer model has, the more memory need.</span> 这是因为需要store forward pass, acivation for backprop. Can overcome this memory requirements by recomputing activations, 但是需要done efficiently to minimize taking too much extra time. 比如GPT-3 has 96 layers 会take a very long time to recompute activations, and model will continue to get bigger.
  - Compute vs memory tradeoff


**Solve Dot product Attention Complexity**

e.g. 比如下图，can see what attention is doing, 比如word it, attention focus on certain words to determine if it refers to the streets or to be animal. it 只能refer to noun not other words 可以ignore other word. A pronoun(it) is a word that substitutes for a noun. That's why only want to look up nearest neighbor to speed up attention


![](/img/post/Natural-Language-Processing/course4/week4pic1.png)

**Nearest Neighbors**: Compute the nearest neighbors to q among vectors {$$k_1, ...k_n$$}

- Attention computes $$d\left(q,k_i \right)$$ for i from 1 to n which can be slow 
- Faster approximate uses locality sensitive hashing(LSH)
  - Locality sensitive: if q is close to $$k_i$$ -> hash(q) == hash($$k_i$$)
  - <span style="background-color:#FFFF00">When choose hash, want to make buckets roughly the same size</span>
  - only run attention on keys that are in the same hash buckets as the query (就像上边 noun 和 pronoun的例子)
  - Achieve by randomly cutting space: hash(x) = sign(xR) where R: [d,n_hash_bins]. R is random, size 是 d(dimension) 乘以 number of hash bins. Sign tell which side of the plane hash will be on. The process is repeated depending on the number of hashes you have

#### LSH Attention

**Standard Attenion**:

$$A\left(Q,K,V\right) = softmax\left(Qk^T\right)V$$

**LSH Attention**: <span style="background-color:#FFFF00">Note LSH is a probabilistic, not deterministic model 因为inherent randomness within LSH algorithm. Meaning hash can change along with buckets that vector map to</span>

1. First hash Q and K 
2. perform standard attention but within same-hash bins. This reduces the search space for each K to the same LSH bucket as Q. Can repeat this process multiple time to increase the probability of finding Q and K in the same bin. 可以done efficiently by parallel computing

Integrate LSH to attention layer:

1. modify model so outputs a single vector at each position which serves both as a query and a key. Called QK attention and performs just as regular attention
2. map each vector to a bucket with LSH. 
3. Sort vectors by LSH bucket
4. Do attention only in each bucket. Use batch(parallel) computation
  1. split sorted sequence into fixed size chunks which allow parallel computation
  2. Let each chunk attend within itself and adjacent chunks(比如图中 blue 相互计算, 黄色相互计算, 红色相互计算) 因为一个hash bucket may split more than one chunk


### Reversible Layers:

<span style="color:red">Memory grow linearly with the number of layers</span>

比如 want to run transformer on entire text of book, 也许有 1 million token to process. each token has associated feature size 512 (比如embedding) -> model input就有 2 GB, 在16GB的GPU, 相当于1/8 not touch layer yet. 而layer 有transformer layer and feedforward layer. 比如model 有 12个attention, 12个feedforward. 每个layer input 和 output 也是2GB, do backprop, forward path需要store intermediate quantities in meomory. 比如只save activation from boundaries between each layers 不保存individual layer就已经50GB (任何device 都不能fit) 而modern transformer much deeper than 12 layers

![](/img/post/Natural-Language-Processing/course4/week4pic3.gif)

Transformer network precedes by adding residuals to hidden state. To run reverse, can substract residuals in oppsite order, start with outputs of model. Instead of store residuals, able to recompute quickly instead where residual connection come in.<span style="color:red"> Key idea is start with two copies of model inputs, then each layer only update one</span>. The activation don't update is the one to compute residuals. 

Compute using one side of network plus feed foward from other side to compute $$y_2$$, similarly one side of network plus attention to computer other side to compute $$y_1$$

![](/img/post/Natural-Language-Processing/course4/week4pic4.png)

Foward layer for residual block: combine standard attention and feed forward residual layers from regular transformer to a single reversible residual block and nothing save in the memory except for $$y_1, y_2$$ for output layer instead of activiation for every individual layer  



![](/img/post/Natural-Language-Processing/course4/week4pic5.png)

#### Reformer

Reformer is a transformer model designed to be memory efficient so it can handle very large context windows of upto 1 million words.

- use LSH Attention: reduce complexity of attending over long sequences
- use Reversible Residual Layers:  more efficienctly use memory available

下面图from Reformer paper, highlight standard attention takes longer as sequence length increases. However, LSH attention takes roughly the same amount of time as sequence increase. The only difference is number of hashes. More hashes take slightly longer than fewer hashes, regardless of seqeunce sequence, 

![](/img/post/Natural-Language-Processing/course4/week4pic6.png)


## Resource

[The Real Meaning of Ich Bin ein Berliner](https://www.theatlantic.com/magazine/archive/2013/08/the-real-meaning-of-ich-bin-ein-berliner/309500/): Word Alignment: 比如德语 Berliner 可以指柏林人，也可以值一种donut 甜甜圈. 比如下面English word 多于German word.

[Jukebox - A neural network that generates music!](https://openai.com/blog/jukebox/)

[GPT-3 Can also help with auto-programming!](https://beta.openai.com/?app=productivity&example=4_2_0)


[Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer (Raffel et al, 2019)](https://arxiv.org/abs/1910.10683)

[Reformer: The Efficient Transformer (Kitaev et al, 2020)](https://arxiv.org/abs/2001.04451)

[Attention Is All You Need (Vaswani et al, 2017)](https://arxiv.org/abs/1706.03762)

[Deep contextualized word representations (Peters et al, 2018)](https://arxiv.org/pdf/1802.05365.pdf)

[The Illustrated Transformer (Alammar, 2018)](http://jalammar.github.io/illustrated-transformer/)

[The Illustrated GPT-2 (Visualizing Transformer Language Models) (Alammar, 2019)](http://jalammar.github.io/illustrated-gpt2/)

[BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding (Devlin et al, 2018)](https://arxiv.org/abs/1810.04805)

[How GPT3 Works - Visualizations and Animations (Alammar, 2020)](http://jalammar.github.io/how-gpt3-works-visualizations-animations/)
